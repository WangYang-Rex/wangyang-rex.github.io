<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端-洋仔</title>
  <subtitle>专注于前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://html-js.site/"/>
  <updated>2017-07-06T06:55:37.000Z</updated>
  <id>http://html-js.site/</id>
  
  <author>
    <name>wangyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack的重要功能——Plugins</title>
    <link href="http://html-js.site/2017/06/23/webpack%E7%9A%84%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94Plugins/"/>
    <id>http://html-js.site/2017/06/23/webpack的重要功能——Plugins/</id>
    <published>2017-06-23T06:57:18.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>webpack</code>中另一个非常重要的功能是<code>Plugins</code>。<br>插件（<code>Plugins</code>）是用来拓展<code>webpack</code>功能的，它们会在整个构建过程中生效，执行相关的任务。<br><code>Loaders</code>和<code>Plugins</code>常常被弄混，但是他们其实是完全不同的东西：<code>Loaders</code>是在打包构建过程中用来处理源文件的（<code>JSX，Scss，Less..</code>），一次处理一个;插件并不直接操作单个文件，它直接对整个构建过程其作用。<br><code>webpack</code>有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<a id="more"></a>
<h2 id="使用插件的方法"><a href="#使用插件的方法" class="headerlink" title="使用插件的方法"></a>使用插件的方法</h2><p>要使用某个插件，需要通过<code>npm</code>安装它，然后在<code>webpack.config.js</code>中的<code>plugins</code>关键字部分添加该插件的一个实例（<code>plugins</code>是一个数组，<code>new</code>一个插件即可）。<br>如添加一个实现版权声明的插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">        <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,  </div><div class="line">        <span class="attr">entry</span>:  __dirname + <span class="string">"/app/main.js"</span>,  </div><div class="line">        <span class="attr">output</span>: &#123;...&#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">                <span class="attr">loaders</span>: [  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, <span class="attr">loader</span>: <span class="string">"json"</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> &#125;<span class="comment">//这里添加PostCSS  </span></div><div class="line">                ]  </div><div class="line">    &#125;,  </div><div class="line">        <span class="attr">postcss</span>: [  </div><div class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  </div><div class="line">        ],  </div><div class="line">        <span class="attr">plugins</span>: [  </div><div class="line">                <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"Copyright Flying Unicorns inc."</span>)    </div><div class="line">    ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;...&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="几个常用的插件"><a href="#几个常用的插件" class="headerlink" title="几个常用的插件"></a>几个常用的插件</h2><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>这个插件的作用是依据一个简单的模板，帮助生成最终的<code>HTML5</code>文件，这个文件中自动引用了打包后的<code>JS</code>文件。每次编译都在文件名中插入一个不同的哈希值。<br>安装命令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev html-webpack-plugin</div></pre></td></tr></table></figure></p>
<p>这个插件自动完成了之前手动做的一些事情，在正式使用之前需要对项目结构做一些改变：</p>
<ol>
<li>移除public文件夹，利用此插件，html5文件会自动生成，此外CSS已经通过前面的操作打包到JS中了。</li>
<li><p>在app目录下，创建一个HTML文件模板index.tmpl.html，这个模板包含title等其它需要的元素，在编译过程中，本插件会依据此模板生成最终的HTML页面，会自动添加所依赖的 css, js，favicon等文件，模板源代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;  </div><div class="line">&lt;html lang="en"&gt;  </div><div class="line">    &lt;head&gt;  </div><div class="line">    &lt;/head&gt;  </div><div class="line">    &lt;body&gt;  </div><div class="line">            &lt;div id='root'&gt;  </div><div class="line">            &lt;/div&gt;  </div><div class="line">    &lt;/body&gt;  </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>更新webpack的配置文件，方法同上，新建一个build文件夹用来存放最终的输出文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);<span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);  </div><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">        <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,  </div><div class="line">        <span class="attr">entry</span>:  __dirname + <span class="string">"/app/main.js"</span>,  </div><div class="line">        <span class="attr">output</span>: &#123;  </div><div class="line">                <span class="attr">path</span>: __dirname + <span class="string">"/build"</span>,  </div><div class="line">                <span class="attr">filename</span>: <span class="string">"bundle.js"</span>  </div><div class="line">        &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">                <span class="attr">loaders</span>: [  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, <span class="attr">loader</span>: <span class="string">"json"</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span> &#125;,  </div><div class="line">                &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> &#125;  </div><div class="line">            ]  </div><div class="line">        &#125;,  </div><div class="line">        <span class="attr">postcss</span>: [  </div><div class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  </div><div class="line">        ],  </div><div class="line">        <span class="attr">plugins</span>: [  </div><div class="line">                <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  </div><div class="line">                    <span class="attr">template</span>: __dirname + <span class="string">"/app/index.tmpl.html"</span><span class="comment">//new 一个这个插件的实例，并传入相关的参数  </span></div><div class="line">                &#125;)  </div><div class="line">        ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">                <span class="attr">colors</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">inline</span>: <span class="literal">true</span>  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h3><p><code>Hot Module Replacement（HMR）</code>也是<code>webpack</code>里很有用的一个插件，它允许在修改组件代码后，自动刷新实时预览修改后的效果。<br>在<code>webpack</code>中实现<code>HMR</code>也很简单，只需要做两项配置</p>
<ol>
<li>在webpack配置文件中添加HMR插件；</li>
<li>在Webpack Dev Server中添加“hot”参数。</li>
</ol>
<p>不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在JS模块中执行一个<code>Webpack</code>提供的<code>API</code>才能实现热加载，虽然这个<code>API</code>不难使用，但是如果是<code>React</code>模块，使用已经熟悉的<code>Babel</code>可以更方便的实现功能热加载。<br>具体实现方法如下：</p>
<ol>
<li>Babel和webpack是独立的工具；</li>
<li>二者可以一起工作；</li>
<li>二者都可以通过插件拓展功能；</li>
<li>HMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额；</li>
<li>Babel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);  </div><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);  </div><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">        <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,  </div><div class="line">        <span class="attr">entry</span>: __dirname + <span class="string">"/app/main.js"</span>,  </div><div class="line">        <span class="attr">output</span>: &#123;  </div><div class="line">                <span class="attr">path</span>: __dirname + <span class="string">"/build"</span>,  </div><div class="line">                <span class="attr">filename</span>: <span class="string">"bundle.js"</span>  </div><div class="line">        &#125;,  </div><div class="line">        <span class="attr">module</span>: &#123;  </div><div class="line">                <span class="attr">loaders</span>: [  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, <span class="attr">loader</span>: <span class="string">"json"</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> &#125;  </div><div class="line">                ]     </div><div class="line">        &#125;,  </div><div class="line">        <span class="attr">postcss</span>: [  </div><div class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  </div><div class="line">        ],  </div><div class="line">    <span class="attr">plugins</span>: [  </div><div class="line">                <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  </div><div class="line">                    <span class="attr">template</span>: __dirname + <span class="string">"/app/index.tmpl.html"</span>  </div><div class="line">                &#125;),  </div><div class="line">                <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()<span class="comment">//热加载插件  </span></div><div class="line">        ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">                <span class="attr">colors</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">inline</span>: <span class="literal">true</span>,  </div><div class="line">            <span class="attr">hot</span>: <span class="literal">true</span>  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>安装react-transform-hmr：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-plugin-react-transform react-transform-hmr</div></pre></td></tr></table></figure></p>
<p>配置Babel<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;  </div><div class="line">        <span class="string">"presets"</span>: [<span class="string">"react"</span>, <span class="string">"es2015"</span>],  </div><div class="line">        <span class="string">"env"</span>: &#123;  </div><div class="line">                <span class="string">"development"</span>: &#123;  </div><div class="line">                    <span class="string">"plugins"</span>: [[<span class="string">"react-transform"</span>, &#123;  </div><div class="line">                    <span class="string">"transforms"</span>: [&#123;  </div><div class="line">                            <span class="string">"transform"</span>: <span class="string">"react-transform-hmr"</span>,  </div><div class="line">                    <span class="string">"imports"</span>: [<span class="string">"react"</span>],  </div><div class="line">                    <span class="string">"locals"</span>: [<span class="string">"module"</span>]  </div><div class="line">                    &#125;]  </div><div class="line">                    &#125;]]  </div><div class="line">        &#125;  </div><div class="line">            &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用React时，可以热加载模块了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;中另一个非常重要的功能是&lt;code&gt;Plugins&lt;/code&gt;。&lt;br&gt;插件（&lt;code&gt;Plugins&lt;/code&gt;）是用来拓展&lt;code&gt;webpack&lt;/code&gt;功能的，它们会在整个构建过程中生效，执行相关的任务。&lt;br&gt;&lt;code&gt;Loaders&lt;/code&gt;和&lt;code&gt;Plugins&lt;/code&gt;常常被弄混，但是他们其实是完全不同的东西：&lt;code&gt;Loaders&lt;/code&gt;是在打包构建过程中用来处理源文件的（&lt;code&gt;JSX，Scss，Less..&lt;/code&gt;），一次处理一个;插件并不直接操作单个文件，它直接对整个构建过程其作用。&lt;br&gt;&lt;code&gt;webpack&lt;/code&gt;有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack最强大的功能———Loaders</title>
    <link href="http://html-js.site/2017/06/23/webpack%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94%E2%80%94Loaders/"/>
    <id>http://html-js.site/2017/06/23/webpack最强大的功能———Loaders/</id>
    <published>2017-06-23T02:06:43.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p><code>Loaders</code>是<code>webpack</code>中最强大的功能之一了。通过使用不同的<code>loader</code>，<code>webpack</code>通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，如分析<code>JSON</code>文件并把它转换为<code>JavaScript</code>文件；或把下一代的<code>js</code>文件（<code>ES6，ES7</code>)转换为现代浏览器可以识别的<code>JS</code>文件；或对<code>React</code>的开发而言，合适的<code>Loaders</code>可以把<code>react</code>的<code>JSX</code>文件转换为<code>JS</code>文件。</p>
<p><code>Loaders</code>需要单独安装并且需要在<code>webpack.config.js</code>下的<code>modules</code>关键字下进行配置。安装命令为<code>npm install --save-dev json-loader</code>，<code>Loaders</code>的配置选项包括以下几方面：</p>
<ul>
<li>test  一个匹配loaders所处理的文件的拓展名的正则表达式（必须）</li>
<li>loader  loader的名称（必须）</li>
<li>include/exclude  手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）</li>
<li>query  为loaders提供额外的设置选项（可选）<a id="more"></a>
</li>
</ul>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p><code>Loaders</code>很好，不过有的<code>Loaders</code>使用起来比较复杂，如<code>Babel</code>。<br><code>Babel</code>其实是一个编译<code>javascript</code>的平台，它的强大之处表现在可以通过编译达到以下目的：</p>
<ul>
<li>1) 下一代的<code>JavaScript</code>标准（<code>ES6，ES7</code>），这些标准目前并未被当前的浏览器完全的支持；</li>
<li>2) 使用基于<code>JavaScript</code>进行了拓展的语言，如<code>React</code>的<code>JSX</code>。<br><code>Babel</code>其实是几个模块化的包，其核心功能位于称为<code>babel-core</code>的<code>npm</code>包中，不过<code>webpack</code>把它们整合在一起使用，但是对于每一个需要的功能或拓展，都需要安装单独的包（用得最多的是解析Es6的<code>babel-preset-es2015</code>包和解析<code>JSX</code>的<code>babel-preset-react</code>包）。<br>一次性安装这些依赖包（npm一次性安装多个依赖模块，模块之间用空格隔开）：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>webpack</code>中配置<code>Babel</code>的方法如下（在<code>webpack.config.js</code>的<code>module</code>部分的<code>loaders</code>里进行配置即可）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>webpack</code>进行以上配置后，允许使用<code>ES6</code>以及<code>JSX</code>的语法。</p>
<p><strong>Babel的配置选项：</strong><br><code>Babel</code>其实可以完全在<code>webpack.config.js</code>中进行配置，但考虑到<code>babel</code>具有非常多的配置选项，在单一的<code>webpack.config.js</code>文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把<code>babel</code>的配置选项放在一个单独的名为 <code>&quot;.babelrc&quot;</code> 的配置文件中。现在的<code>babel</code>的配置并不算复杂，不过之后会再加一些东西，因此现在就提取出相关部分，分两个配置文件进行配置（<code>webpack</code>会自动调用<code>.babelrc</code>里的<code>babel</code>配置选项），如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>.babelrc：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;  </div><div class="line">    <span class="string">"presets"</span>: [<span class="string">"react"</span>, <span class="string">"es2015"</span>]  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><code>webpack</code>的优点：把所有的文件都可以当做模块处理，包括<code>JavaScript</code>代码，也包括<code>CSS</code>和<code>fonts</code>以及图片等，通过合适的<code>loaders</code>，它们都可以被当做模块被处理。<br><strong>1）CSS</strong><br><code>webpack</code>提供两个工具处理样式表，<code>css-loader</code> 和 <code>style-loader</code>，二者处理的任务不同，<code>css-loader</code>使得能够使用类似<code>@import</code> 和 <code>url(...)</code>的方法实现 <code>require()</code>的功能，<code>style-loader</code>将所有的计算后的样式加入页面中，二者组合在一起能够把样式表嵌入<code>webpack</code>打包后的JS文件中。<br>安装命令：<code>npm install --save-dev style-loader css-loader</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：感叹号的作用在于使同一文件能够使用不同类型的<code>loader</code>。</p>
<p><strong>2）CSS modules</strong><br><code>CSS modules</code> 的技术就意在把<code>JS</code>的模块化思想带入<code>CSS</code>中来，通过<code>CSS</code>模块，所有的类名，动画名默认都只作用于当前模块。<code>Webpack</code>从一开始就对<code>CSS</code>模块化提供了支持，在<code>CSS loader</code>中进行配置后，所需要做的一切就是把<code>modules</code>传递都所需要的地方，然后就可以直接把<code>CSS</code>的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中具有相同的类名可能会造成的问题。具体的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css?modules'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p>有关<code>Less Loader</code>、<code>Sass Loader</code>、<code>Stylus Loader</code>的介绍请见：<a href="http://blog.csdn.net/zhouziyu2011/article/details/67646875。" target="_blank" rel="external">http://blog.csdn.net/zhouziyu2011/article/details/67646875。</a><br>还有一个<code>CSS</code>的处理平台-<code>PostCSS</code>，可以帮助<code>CSS</code>实现更多的功能，使用<code>PostCSS</code>来为<code>CSS</code>代码自动添加适应不同浏览器的CSS前缀。<br>安装<code>postcss-loader</code> 和 <code>autoprefixer</code>（自动添加前缀的插件）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev postcss-loader autoprefixer。</div></pre></td></tr></table></figure></p>
<p>在<code>webpack.config.js</code>中进行设置，只需要新建一个<code>postcss</code>关键字，并在里面申明依赖的插件，<code>css</code>会自动根据数据添加不同前缀了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">postcss</span>: [  </div><div class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)<span class="comment">//调用autoprefixer插件  </span></div><div class="line">    ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>处理<code>JS</code>的<code>Babel</code>和处理<code>CSS</code>的<code>PostCSS</code>其实也是两个单独的平台，配合<code>Webpack</code>可以很好的发挥它们的作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Loaders&quot;&gt;&lt;a href=&quot;#Loaders&quot; class=&quot;headerlink&quot; title=&quot;Loaders&quot;&gt;&lt;/a&gt;Loaders&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Loaders&lt;/code&gt;是&lt;code&gt;webpack&lt;/code&gt;中最强大的功能之一了。通过使用不同的&lt;code&gt;loader&lt;/code&gt;，&lt;code&gt;webpack&lt;/code&gt;通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，如分析&lt;code&gt;JSON&lt;/code&gt;文件并把它转换为&lt;code&gt;JavaScript&lt;/code&gt;文件；或把下一代的&lt;code&gt;js&lt;/code&gt;文件（&lt;code&gt;ES6，ES7&lt;/code&gt;)转换为现代浏览器可以识别的&lt;code&gt;JS&lt;/code&gt;文件；或对&lt;code&gt;React&lt;/code&gt;的开发而言，合适的&lt;code&gt;Loaders&lt;/code&gt;可以把&lt;code&gt;react&lt;/code&gt;的&lt;code&gt;JSX&lt;/code&gt;文件转换为&lt;code&gt;JS&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Loaders&lt;/code&gt;需要单独安装并且需要在&lt;code&gt;webpack.config.js&lt;/code&gt;下的&lt;code&gt;modules&lt;/code&gt;关键字下进行配置。安装命令为&lt;code&gt;npm install --save-dev json-loader&lt;/code&gt;，&lt;code&gt;Loaders&lt;/code&gt;的配置选项包括以下几方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test  一个匹配loaders所处理的文件的拓展名的正则表达式（必须）&lt;/li&gt;
&lt;li&gt;loader  loader的名称（必须）&lt;/li&gt;
&lt;li&gt;include/exclude  手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）&lt;/li&gt;
&lt;li&gt;query  为loaders提供额外的设置选项（可选）
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>浅谈webpack模块引用的五种方法</title>
    <link href="http://html-js.site/2017/06/23/%E6%B5%85%E8%B0%88webpack%E6%A8%A1%E5%9D%97%E5%BC%95%E7%94%A8%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://html-js.site/2017/06/23/浅谈webpack模块引用的五种方法/</id>
    <published>2017-06-23T01:24:54.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="commonjs格式的require同步语法"><a href="#commonjs格式的require同步语法" class="headerlink" title="commonjs格式的require同步语法"></a>commonjs格式的require同步语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">… <span class="comment">// 使用</span></div></pre></td></tr></table></figure>
<h3 id="commonjs格式的require-ensure异步语法"><a href="#commonjs格式的require-ensure异步语法" class="headerlink" title="commonjs格式的require.ensure异步语法"></a>commonjs格式的require.ensure异步语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>Home.js会被打包成一个单独的chunk文件：1.fb874860b35831bc96a8.js，其名称不具有可读性，因此一般给require.ensure传递第三个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/home<span class="string">');</span></div></pre></td></tr></table></figure></p>
<p>Home.js会被打包成一个具有指定文件名称的chunk文件：home.fb874860b35831bc96a8.js，该文件在bundle目录下。<br>在webpack.config.js文件中配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output: &#123;  </div><div class="line">    <span class="attr">path</span>: __dirname + <span class="string">'/public'</span>,  </div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].js'</span>,  </div><div class="line">    <span class="attr">chunkFilename</span>: <span class="string">'[name].bundle.js'</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Home.js会被打包成一个具有指定文件名称的chunk文件：home.bundle.js，该文件在bundle目录下，而bundle目录又在/public目录下。<br>注意：如果在require.ensure的回调函数中引用了两个以上的模块，webpack会把它们打包在一起。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">    <span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/a-b<span class="string">');</span></div></pre></td></tr></table></figure></p>
<p>a.js和b.js会被打包成一个具有指定文件名称的chunk文件：a-b.bundle.js，，该文件在bundle目录下。如果不希望打包在一起，只能写多个require.ensure分别引用每一个模块。<br>给require.ensure传递的第一个参数可以是空数组，其实也可以是模块，实现预加载懒执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([<span class="string">'./Home'</span>], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/home<span class="string">');</span></div></pre></td></tr></table></figure></p>
<p>Home.js会被下载下来，即所谓的预加载，但不会执行Home.js模块中的代码，当执行到onsthome = require(‘./Home’)一句时才执行，即所谓的懒执行。</p>
<h3 id="webpack自带的require-include"><a href="#webpack自带的require-include" class="headerlink" title="webpack自带的require.include"></a>webpack自带的require.include</h3><p>require.include是webpack自身提供的，它可以实现require.ensure中的预加载功能，而不用把模块写在数组中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([],<span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="built_in">require</span>.include(<span class="string">'./Home'</span>);<span class="comment">// 只加载不执行  </span></div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>require.include的返回值是undefined，如果想使用模块，需要再通过require引入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([],<span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="built_in">require</span>.include(<span class="string">'./Home'</span>);<span class="comment">// 只加载不执行  </span></div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>); <span class="comment">// 执行  </span></div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/home<span class="string">');</span></div></pre></td></tr></table></figure></p>
<h3 id="AMD异步加载"><a href="#AMD异步加载" class="headerlink" title="AMD异步加载"></a>AMD异步加载</h3><p>webpack既支持commonjs规范也支持AMD规范。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'./Home'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">home</span>)</span>&#123;  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果写了多个模块，那么这些模块都会被打包成一个文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>a.js和b.js会被打包在一起，但AMD的方式无法传入第三个参数来指定文件名称。<br>require AMD与require.ensure的区别：</p>
<ul>
<li>require AMD传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数；</li>
<li>require.ensure也是传递一个模块数组和回调函数，但是模块只会被下载下来，不会被执行，只有在回调函数中执行到require(模块)一句时，该模块才会被执行。<br>在webpack.config.js文件中配置：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">entry</span>: <span class="string">'index.js'</span>  </div><div class="line">    output: &#123;  </div><div class="line">            <span class="attr">path</span>: __dirname + <span class="string">'/public'</span>,  </div><div class="line">            <span class="attr">filename</span>: <span class="string">'[name].js'</span>,  </div><div class="line">            <span class="attr">chunkFilename</span>: <span class="string">'[name].bundle.js'</span>  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ES6的import"><a href="#ES6的import" class="headerlink" title="ES6的import"></a>ES6的import</h3><p>import会被转化为commonjs格式或是AMD格式，所以它不是一种新的模块引用方式。babel默认会把ES6的模块转化为commonjs规范，因此不需要再把它转成AMD规范。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'./Home'</span>;</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;commonjs格式的require同步语法&quot;&gt;&lt;a href=&quot;#commonjs格式的require同步语法&quot; class=&quot;headerlink&quot; title=&quot;commonjs格式的require同步语法&quot;&gt;&lt;/a&gt;commonjs格式的require同步语法&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; home = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./Home&#39;&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;… &lt;span class=&quot;comment&quot;&gt;// 使用&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;commonjs格式的require-ensure异步语法&quot;&gt;&lt;a href=&quot;#commonjs格式的require-ensure异步语法&quot; class=&quot;headerlink&quot; title=&quot;commonjs格式的require.ensure异步语法&quot;&gt;&lt;/a&gt;commonjs格式的require.ensure异步语法&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([], &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt; =&amp;gt; &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; home = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./Home&#39;&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    … &lt;span class=&quot;comment&quot;&gt;//使用  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门</title>
    <link href="http://html-js.site/2017/06/22/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://html-js.site/2017/06/22/webpack入门/</id>
    <published>2017-06-22T11:13:44.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在webpack看来，所有的资源文件都是模块，只是处理的方式不同。<br>webpack解决的需求点是：如何更好地加载前端模块。</p>
<h3 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h3><p>只需要指定一个入口文件，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果webpack没有进行全局安装，那么在终端中使用此命令时，需要额外指定其在node_modules中的地址。</p>
<p>若webpack全局安装，使用webpack app/main.js public/bundle.js命令即可。<br>若webpack非全局安装，需使用node_modules.bin\webpack app/main.js public/bundle.js命令。<br>注意：node_modules.bin\webpack的路径需用右斜杠形式，用左斜杠形式会报错。<br><a id="more"></a></p>
<h3 id="通过配置文件来使用webpack"><a href="#通过配置文件来使用webpack" class="headerlink" title="通过配置文件来使用webpack"></a>通过配置文件来使用webpack</h3><p>webpack拥有很多其它比较高级的功能，如<code>loaders</code>和<code>plugins</code>，这些功能其实都可以通过命令行模式实现，但这样不太方便且容易出错，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的<code>javascript</code>模块，可以把所有的与构建相关的信息放在里面。<br>以上面例子为例，在当根目录下新建一个名为<code>webpack.config.js</code>的文件，并进行配置，它包含入口文件路径和存放打包后文件的地方的路径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;    </div><div class="line">    <span class="attr">entry</span>: __dirname + <span class="string">"/app/main.js"</span>, <span class="comment">// 唯一入口文件    </span></div><div class="line">    output: &#123;      </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方      </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：<code>__dirname</code>是<code>node.js</code>中的一个全局变量，它指向当前执行脚本所在的目录。<br>若<code>webpack</code>全局安装，使用<code>webpack</code>命令即可。<br>若<code>webpack</code>非全局安装，需使用<code>node_modules\.bin\webpack</code>命令。<br>这条命令会自动参考<code>webpack.config.js</code>文件中的配置选项打包项目，按照上面提到的结果查看方法即可查看结果。</p>
<h3 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h3><p>执行类似于<code>node_modules\.bin\webpack</code>这样的命令其实是容易出错的，<code>npm</code>可以引导任务执行，对其进行配置后可以使用简单的<code>npm start</code>命令来代替这些繁琐的命令。在<code>package.json</code>中对<code>npm</code>的脚本部分进行相关设置即可：<br>默认的<code>test</code>直接删除，设置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;  </div><div class="line">    <span class="string">"start"</span>: <span class="string">"webpack"</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：添加注释<code>//</code>或者<code>/**/</code>在<code>JSON</code>文件中是不允许的，若用<code>js</code>的方式添加注释会报错。<br><code>package.json</code>中的脚本部分已经默认在命令前添加了<code>node_modules\.bin</code>路径，所以无论是全局还是局部安装的<code>webpack</code>，都不需要在前面指明详细的路径了。<br>无论是全局安装还是非全局安装，都只需要使用<code>npm start</code>命令，按照上面提到的结果查看方法即可查看结果。</p>
<h3 id="生成Source-Maps（调试更容易）"><a href="#生成Source-Maps（调试更容易）" class="headerlink" title="生成Source Maps（调试更容易）"></a>生成Source Maps（调试更容易）</h3><p>打包后的文件往往不容易找到出错的源代码的位置，<code>Source Maps</code>可以解决这个问题。<br>通过简单的配置后，<code>webpack</code>在打包时可以生成<code>source maps</code>，提供一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。<br>在<code>webpack</code>的配置文件中配置<code>source maps</code>，需要配置<code>devtool</code>，它有以下四种不同的配置选项，各具优缺点，描述如下：<br><code>devtool</code>选项  配置结果 </p>
<ul>
<li>source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的<code>source map</code>，但是它会减慢打包文件的构建速度。</li>
<li>cheap-module-source-map 在一个单独的文件中生成一个不带列映射的<code>map</code>，不带列映射提高项目构建速度，但也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便。</li>
<li>eval-source-map 使用<code>eval</code>打包源文件模块，在同一个文件中生成干净的完整的<code>source map</code>。这个选项可以在不影响构建速度的前提下生成完整的<code>sourcemap</code>，但是对打包后输出的<code>JS</code>文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项。</li>
<li>cheap-module-eval-source-map 这是在打包文件时最快的生成<code>source map</code>的方法，生成的<code>Source map</code>会和打包后的<code>JS</code>文件同行显示，没有列映射，和<code>eval-source-map</code>选项具有相似的缺点。</li>
</ul>
<p>上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的构建速度的后果就是对打包后的文件的的执行有一定影响。<br>在学习阶段以及在小到中性的项目上，<code>eval-source-map</code>是一个很好的选项，不过记得只在开发阶段使用它；<code>cheap-module-eval-source-map</code>方法构建速度更快，但是不利于调试，推荐在大型项目考虑da时间成本是使用。</p>
<p>以上述例子为例，继续配置webpack.config.js文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>, <span class="comment">// 配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>, <span class="comment">// 已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>, <span class="comment">// 打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span> <span class="comment">// 打包后输出文件的文件名  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h3><p><code>webpack</code>提供一个可选的本地开发服务器，这个本地服务器基于<code>node.js</code>构建，可以实现浏览器监测代码的修改，并自动刷新修改后的结果，不过它是一个单独的组件，在<code>webpack</code>中进行配置之前需要单独安装它作为项目依赖，安装命令为<code>npm install --save-dev webpack-dev-server</code>。<br><code>devserver</code>作为<code>webpack</code>配置选项中的一项，具有以下配置选项：</p>
<ul>
<li>contentBase 默认<code>webpack-dev-server</code>会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录</li>
<li>port 设置默认监听端口，如果省略，默认为<code>8080</code></li>
<li>inline 设置为<code>true</code>，当源文件改变时会自动刷新页面</li>
<li>colors 设置为<code>true</code>，使终端输出的文件为彩色的</li>
<li>historyApiFallback 在开发单页应用时非常有用，它依赖于<code>HTML5 history API</code>，如果设置为<code>true</code>，所有的跳转将指向<code>index.html</code></li>
</ul>
<p>以上述例子为例，继续配置<code>webpack.config.js</code>文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>, <span class="comment">// 配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>, <span class="comment">// 已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>, <span class="comment">// 打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span> <span class="comment">// 打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>webpack有两个重要的功能：Loaders和Plugins。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在webpack看来，所有的资源文件都是模块，只是处理的方式不同。&lt;br&gt;webpack解决的需求点是：如何更好地加载前端模块。&lt;/p&gt;
&lt;h3 id=&quot;使用webpack&quot;&gt;&lt;a href=&quot;#使用webpack&quot; class=&quot;headerlink&quot; title=&quot;使用webpack&quot;&gt;&lt;/a&gt;使用webpack&lt;/h3&gt;&lt;p&gt;只需要指定一个入口文件，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果webpack没有进行全局安装，那么在终端中使用此命令时，需要额外指定其在node_modules中的地址。&lt;/p&gt;
&lt;p&gt;若webpack全局安装，使用webpack app/main.js public/bundle.js命令即可。&lt;br&gt;若webpack非全局安装，需使用node_modules.bin\webpack app/main.js public/bundle.js命令。&lt;br&gt;注意：node_modules.bin\webpack的路径需用右斜杠形式，用左斜杠形式会报错。&lt;br&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>npmlist</title>
    <link href="http://html-js.site/2017/06/07/npmlist/"/>
    <id>http://html-js.site/2017/06/07/npmlist/</id>
    <published>2017-06-07T02:48:19.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里收集了一些目前用到的一些npm库以及相关的功能</p>
<h3 id="node-glob-获取对应规则的文件-路径-所有文件"><a href="#node-glob-获取对应规则的文件-路径-所有文件" class="headerlink" title="node-glob  获取对应规则的文件/路径/所有文件"></a>node-glob  获取对应规则的文件/路径/所有文件</h3><blockquote>
<p>node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.<br>这个glob工具基于javascript.它使用了 minimatch 库来进行匹配<br><a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">https://github.com/isaacs/node-glob</a><br><a id="more"></a></p>
</blockquote>
<h3 id="inquirer-js-常见的交互式命令行用户接口的集合"><a href="#inquirer-js-常见的交互式命令行用户接口的集合" class="headerlink" title="inquirer.js 常见的交互式命令行用户接口的集合"></a>inquirer.js 常见的交互式命令行用户接口的集合</h3><p>创建交互式命令行用户接口<br><img src="/images/page/inquirer/1.png" alt=""></p>
<p>github地址： <a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="external">https://github.com/SBoudrias/Inquirer.js</a></p>
<h3 id="commander-js-node-js命令行接口的完整解决方案"><a href="#commander-js-node-js命令行接口的完整解决方案" class="headerlink" title="commander.js node.js命令行接口的完整解决方案"></a>commander.js node.js命令行接口的完整解决方案</h3><p><a href="http://nodejs.org" target="_blank" rel="external">node.js</a> 命令行接口的完整解决方案，灵感来自 Ruby 的 commander。<br><a href="http://tj.github.com/commander.js/" target="_blank" rel="external">API 文档</a><br>本文所有的例子都可以用 <code>node name.js &lt;command/option&gt;</code> 执行<br>吐槽：commander.js中文文档真的好难找哇</p>
<h3 id="portscanner-端口检查器"><a href="#portscanner-端口检查器" class="headerlink" title="portscanner 端口检查器"></a>portscanner 端口检查器</h3><p>portscanner可以检查对应端口是否被占用<br><a href="https://github.com/baalexander/node-portscanner" target="_blank" rel="external">https://github.com/baalexander/node-portscanner</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里收集了一些目前用到的一些npm库以及相关的功能&lt;/p&gt;
&lt;h3 id=&quot;node-glob-获取对应规则的文件-路径-所有文件&quot;&gt;&lt;a href=&quot;#node-glob-获取对应规则的文件-路径-所有文件&quot; class=&quot;headerlink&quot; title=&quot;node-glob  获取对应规则的文件/路径/所有文件&quot;&gt;&lt;/a&gt;node-glob  获取对应规则的文件/路径/所有文件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.&lt;br&gt;这个glob工具基于javascript.它使用了 minimatch 库来进行匹配&lt;br&gt;&lt;a href=&quot;https://github.com/isaacs/node-glob&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/isaacs/node-glob&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node-glob</title>
    <link href="http://html-js.site/2017/06/02/node-glob/"/>
    <id>http://html-js.site/2017/06/02/node-glob/</id>
    <published>2017-06-02T09:38:16.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.<br>这个glob工具基于javascript.它使用了 minimatch 库来进行匹配<br><a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">https://github.com/isaacs/node-glob</a></p>
</blockquote>
<a id="more"></a>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install glob</div></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">"glob"</span>)</div><div class="line"></div><div class="line"><span class="comment">// options 是可选的</span></div><div class="line">glob(<span class="string">"**/*.js"</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">  <span class="comment">// files 是匹配到的文件的数组.</span></div><div class="line">  <span class="comment">// 如果 `nonull` 选项被设置为true, 而且没有找到任何文件,那么files就是glob规则本身,而不是空数组</span></div><div class="line">  <span class="comment">// er是当寻找的过程中遇的错误</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>“globs” 就是模型,比如当你在命令行里输入 ls <em>.js,  又或者是你在 .gitignore 文件里写的 bulid/</em> 这些.<br>在解析路径模型的时候, 大括号里用多个逗号隔开的内容会被展开, 里面的部分也可以包含”/“ ,比如  <code>a{/b/c, bcd}</code>  会被展开成 <code>a/b/c</code> 和 <code>abcd</code></p>
<h2 id="路径中的某一段可以使用下面的这些字符表示-他们各自都有很炫的作用"><a href="#路径中的某一段可以使用下面的这些字符表示-他们各自都有很炫的作用" class="headerlink" title="路径中的某一段可以使用下面的这些字符表示,他们各自都有很炫的作用:"></a>路径中的某一段可以使用下面的这些字符表示,他们各自都有很炫的作用:</h2><h3 id="1-匹配该路径段中0个或多个任意字符"><a href="#1-匹配该路径段中0个或多个任意字符" class="headerlink" title="1. * : 匹配该路径段中0个或多个任意字符:"></a>1. * : 匹配该路径段中0个或多个任意字符:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//*:匹配路径中某部分:0个或多个字符</span></div><div class="line">glob(<span class="string">"js/*.js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>获取js目录下的所有js文件.(不包括以’.’开头的文件)</p>
<h3 id="2-匹配该路径段中1个任意字符"><a href="#2-匹配该路径段中1个任意字符" class="headerlink" title="2. ? : 匹配该路径段中1个任意字符:"></a>2. ? : 匹配该路径段中1个任意字符:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//?:匹配路径中某部分:1个字符</span></div><div class="line">glob(<span class="string">"js/?.js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>获取js目录下所有名字只有1个字的js.</p>
<h3 id="3-…-匹配该路径段中在指定范围内字符"><a href="#3-…-匹配该路径段中在指定范围内字符" class="headerlink" title="3. […] : 匹配该路径段中在指定范围内字符:"></a>3. […] : 匹配该路径段中在指定范围内字符:</h3><p>注意不能组合,只能是其中一个字符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[]:匹配路径中某部分:指定的范围</span></div><div class="line">glob(<span class="string">"js/a[0-3].js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下a开头,第二个字符为0-3之间(包括0和3)的js(a03.js不能被匹配到)</p>
<h3 id="4-pattern-pattern-pattern-匹配括号中多个模型的0个或多个或任意个的组合"><a href="#4-pattern-pattern-pattern-匹配括号中多个模型的0个或多个或任意个的组合" class="headerlink" title="4. *(pattern|pattern|pattern) : 匹配括号中多个模型的0个或多个或任意个的组合"></a>4. *(pattern|pattern|pattern) : 匹配括号中多个模型的0个或多个或任意个的组合</h3><p>注意|前后不能有空格<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//*(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的0个或多个.</span></div><div class="line"><span class="comment">//除了三个模型本身,如果是组合也可以,比如ab.js,但是仅仅包含某个模型是不行的,比如a4.js.</span></div><div class="line">glob(<span class="string">"js/*(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下a.js,a1.js,b.js,或者a,a1,b这几个字符的组合的js,比如ab.js</p>
<h3 id="5-pattern-pattern-pattern-匹配不包含任何模型"><a href="#5-pattern-pattern-pattern-匹配不包含任何模型" class="headerlink" title="5. !(pattern|pattern|pattern) : 匹配不包含任何模型"></a>5. !(pattern|pattern|pattern) : 匹配不包含任何模型</h3><p>需要注意: !(pattern|pattern|pattern)  不等于 !(*(pattern|pattern|pattern))<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//!(pattern|pattern|pattern): 匹配路径中的某部分: 不包含任何模型.</span></div><div class="line"><span class="comment">//带有a或者b的,都排除.需要注意的是,它并非是*(a|b)的取反</span></div><div class="line">glob(<span class="string">"js/!(a|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下名字中不包含a,也不包含b的所有文件.</p>
<h3 id="6-pattern-pattern-pattern-匹配多个模型中的0个或任意1个"><a href="#6-pattern-pattern-pattern-匹配多个模型中的0个或任意1个" class="headerlink" title="6. ?(pattern|pattern|pattern) : 匹配多个模型中的0个或任意1个."></a>6. ?(pattern|pattern|pattern) : 匹配多个模型中的0个或任意1个.</h3><p>它和 4 的区别是,不可以组合.必须完全匹配<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//?(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的0个或1个.</span></div><div class="line"><span class="comment">//精确匹配模型,不可以组合.</span></div><div class="line">glob(<span class="string">"js/?(a|a2|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下a.js,a2.js,b.js</p>
<h3 id="7-pattern-pattern-pattern-匹配多个模型中的1个或多个"><a href="#7-pattern-pattern-pattern-匹配多个模型中的1个或多个" class="headerlink" title="7. +(pattern|pattern|pattern) : 匹配多个模型中的1个或多个."></a>7. +(pattern|pattern|pattern) : 匹配多个模型中的1个或多个.</h3><p>它和 4 的区别是,必须有一个,为空不匹配<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//+(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的1个或多个.</span></div><div class="line"><span class="comment">//可以是任意一个模型,也可以是他们的组合,比如ab.js</span></div><div class="line">glob(<span class="string">"js/+(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="8-pattern-pat-pat-erN-匹配多个模型中的任意1个"><a href="#8-pattern-pat-pat-erN-匹配多个模型中的任意1个" class="headerlink" title="8. @(pattern|pat*|pat?erN) : 匹配多个模型中的任意1个."></a>8. @(pattern|pat*|pat?erN) : 匹配多个模型中的任意1个.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的1个.</span></div><div class="line"><span class="comment">//精确匹配模型,不可以组合.和?的区别就是不可以为空.必须要是其中的一个.</span></div><div class="line">glob(<span class="string">"js/@(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>和 6 的区别是不匹配为空的情况</p>
<h3 id="9-和-1-一样-可以匹配任何内容-但不仅匹配路径中的某一段-而且可以匹配-‘a-b-c’-这样带有’-‘的内容-所以-它还可以匹配子文件夹下的文件"><a href="#9-和-1-一样-可以匹配任何内容-但不仅匹配路径中的某一段-而且可以匹配-‘a-b-c’-这样带有’-‘的内容-所以-它还可以匹配子文件夹下的文件" class="headerlink" title="9.  : 和 1 一样,可以匹配任何内容,但不仅匹配路径中的某一段,而且可以匹配 ‘a/b/c’ 这样带有’/‘的内容,所以,它还可以匹配子文件夹下的文件."></a>9. <strong> : 和 1 一样,可以匹配任何内容,但</strong>不仅匹配路径中的某一段,而且可以匹配 ‘a/b/c’ 这样带有’/‘的内容,所以,它还可以匹配子文件夹下的文件.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//**: 不是一个单独的路径中的某部分,而是可以带有'/',所以所有当前文件夹和子文件夹下都进行匹配</span></div><div class="line">glob(<span class="string">"**/@(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>获取当前目录所有文件夹及子文件夹下的a.js,a1.js,b.js<br>还有一种方式是设置 <code>matchBase</code> 属性为<code>true</code> ,同样可以起到在当前路径下搜索所有子文件夹的效果:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//matchBase: 设置为true以后,在当前目录下所有的文件夹和子文件夹里寻找匹配的文件</span></div><div class="line">glob(<span class="string">"@(a|a1|b).js"</span>,&#123;<span class="attr">matchBase</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="没有获取到任何匹配文件"><a href="#没有获取到任何匹配文件" class="headerlink" title="没有获取到任何匹配文件:"></a>没有获取到任何匹配文件:</h3><p>当glob没有获取到任何匹配的文件是,并不会像shell里那样返回模型本身,files参数返回的是一个空数组,如果需要让files返回的是模型本身,需要设置 <code>nonull</code> 属性为 <code>true</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//nonull: 设置为true以后,如果没有找到匹配的文件,不返回空字符串,而是返回原始glob语句</span></div><div class="line">glob(<span class="string">"@(c|d|e).js"</span>,&#123;<span class="attr">nonull</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="同步获取匹配文件列表"><a href="#同步获取匹配文件列表" class="headerlink" title="同步获取匹配文件列表:"></a>同步获取匹配文件列表:</h3><p>前面讲到的都是异步的方法,传入一个回调,当获取到匹配的文件的时候执行回调.如果需要同步的获取文件列表,可以这样做:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> files = glob.sync(pattern, [options])</div></pre></td></tr></table></figure></p>
<h2 id="Glob类"><a href="#Glob类" class="headerlink" title="Glob类:"></a>Glob类:</h2><p>通过实例化一个glob.Glob类,可以获得一个glob对象:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Glob = <span class="built_in">require</span>(<span class="string">"glob"</span>).Glob</div><div class="line"><span class="keyword">var</span> mg = <span class="keyword">new</span> Glob(pattern, options, cb)</div></pre></td></tr></table></figure></p>
<p>实例化的时候传入的参数和glob(pattern,options,cb)是一样的.<br>它能够得到一个返回值,这个返回值是一个EventEmitter.<br>如果在选项中设置 <code>sync</code> 属性为 <code>true</code>, 表示同步获取.不可以传入cb回调. 要获取匹配结果,可以通过 <code>g.found</code> 来获取:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globInstance = <span class="keyword">new</span> glob.Glob(<span class="string">"@(a|a1|b).js"</span>,&#123;<span class="attr">nonull</span>:<span class="literal">true</span>,<span class="attr">matchBase</span>:<span class="literal">true</span>,<span class="attr">sync</span>:<span class="literal">true</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(globInstance.found);</div></pre></td></tr></table></figure></p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件:"></a>事件:</h3><ul>
<li>end :  end事件会在文件匹配结束,找出所有匹配结果的时候触发,它接受的参数就是找到的文件的数组</li>
<li>match :  match事件会在每次匹配到一个文件的时候触发,它接受的参数就是匹配到的文件</li>
<li>error :  error事件会在匹配遇到错误的时候触发.接受的参数就是错误信息</li>
<li>abort :  当实例调用了.abort()方法时,abort事件被触发</li>
</ul>
<p>###　方法:</p>
<ul>
<li>pause 暂停匹配搜索</li>
<li>resume 继续匹配搜索</li>
<li>abort 永远停止匹配搜索,不能继续<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globInstance = <span class="keyword">new</span> glob.Glob(<span class="string">"js/@(a|a1|b).js"</span>,&#123;<span class="attr">nonull</span>:<span class="literal">true</span>&#125;);</div><div class="line">globInstance.on(<span class="string">'match'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(file)</div><div class="line">&#125;);</div><div class="line">globInstance.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">files</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;);</div><div class="line">globInstance.on(<span class="string">'abort'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'abort'</span>)</div><div class="line">&#125;);</div><div class="line">globInstance.pause();</div><div class="line">globInstance.resume();</div><div class="line">globInstance.abort();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h3><ul>
<li>minimatch glob所使用的minimatch对象.</li>
<li>options 传递给函数的options选项.</li>
<li>aborted 调用过abort()函数后它的值就是true.</li>
<li>cache</li>
<li>statCache</li>
<li>symlinks</li>
<li>realpathCache </li>
</ul>
<h3 id="options选项"><a href="#options选项" class="headerlink" title="options选项:"></a>options选项:</h3><p>options用于配置模型匹配时候的匹配方式. 所有可以被传入到minimatch里的参数也都可以被传入到glob,另外node-glob还自己添加了一些配置项.</p>
<p>所有的选项如果没有特殊说明,默认值都是false</p>
<p>所有的选项也都适用于Glob类.</p>
<ul>
<li>cwd :检索目录</li>
<li>root </li>
<li>dot </li>
<li>nomount </li>
<li>mark</li>
<li>nosort </li>
<li>stat</li>
<li>… </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.&lt;br&gt;这个glob工具基于javascript.它使用了 minimatch 库来进行匹配&lt;br&gt;&lt;a href=&quot;https://github.com/isaacs/node-glob&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/isaacs/node-glob&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>inquirer.js-常见的交互式命令行用户接口的集合</title>
    <link href="http://html-js.site/2017/05/31/inquirer-js-%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%9B%86%E5%90%88/"/>
    <id>http://html-js.site/2017/05/31/inquirer-js-常见的交互式命令行用户接口的集合/</id>
    <published>2017-05-31T02:46:27.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>创建交互式命令行用户接口<br><img src="/images/page/inquirer/1.png" alt=""></p>
<p>github地址： <a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="external">https://github.com/SBoudrias/Inquirer.js</a></p>
<a id="more"></a>
<h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install inquirer</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>);</div><div class="line">inquirer.prompt([<span class="comment">/* Pass your questions in here */</span>]).then(<span class="function"><span class="keyword">function</span> (<span class="params">answers</span>) </span>&#123;</div><div class="line">	<span class="comment">// Use user feedback for... whatever!!</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Pizza delivery prompt example</div><div class="line"> * run example by writing `node pizza.js` in your console</div><div class="line"> */</div><div class="line"><span class="meta"></span></div><div class="line">'use strict';</div><div class="line"><span class="keyword">var</span> inquirer = <span class="built_in">require</span>(<span class="string">'..'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hi, welcome to Node Pizza'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> questions = [</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'confirm'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'toBeDelivered'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'Is this for delivery?'</span>,</div><div class="line">    <span class="attr">default</span>: <span class="literal">false</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'input'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'phone'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'What\'s your phone number?'</span>,</div><div class="line">    <span class="attr">validate</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> pass = value.match(<span class="regexp">/^([01]&#123;1&#125;)?[-.\s]?\(?(\d&#123;3&#125;)\)?[-.\s]?(\d&#123;3&#125;)[-.\s]?(\d&#123;4&#125;)\s?((?:#|ext\.?\s?|x\.?\s?)&#123;1&#125;(?:\d+)?)?$/i</span>);</div><div class="line">      <span class="keyword">if</span> (pass) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> <span class="string">'Please enter a valid phone number'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'list'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'size'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'What size do you need?'</span>,</div><div class="line">    <span class="attr">choices</span>: [<span class="string">'Large'</span>, <span class="string">'Medium'</span>, <span class="string">'Small'</span>],</div><div class="line">    <span class="attr">filter</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> val.toLowerCase();</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'input'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'quantity'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'How many do you need?'</span>,</div><div class="line">    <span class="attr">validate</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> valid = !<span class="built_in">isNaN</span>(<span class="built_in">parseFloat</span>(value));</div><div class="line">      <span class="keyword">return</span> valid || <span class="string">'Please enter a number'</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">filter</span>: <span class="built_in">Number</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'expand'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'toppings'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'What about the toppings?'</span>,</div><div class="line">    <span class="attr">choices</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">key</span>: <span class="string">'p'</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">'Pepperoni and cheese'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'PepperoniCheese'</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">key</span>: <span class="string">'a'</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">'All dressed'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'alldressed'</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">key</span>: <span class="string">'w'</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">'Hawaiian'</span>,</div><div class="line">        <span class="attr">value</span>: <span class="string">'hawaiian'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'rawlist'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'beverage'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'You also get a free 2L beverage'</span>,</div><div class="line">    <span class="attr">choices</span>: [<span class="string">'Pepsi'</span>, <span class="string">'7up'</span>, <span class="string">'Coke'</span>]</div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'input'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'comments'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'Any comments on your purchase experience?'</span>,</div><div class="line">    <span class="attr">default</span>: <span class="string">'Nope, all good!'</span></div><div class="line">  &#125;,</div><div class="line">  &#123;</div><div class="line">    <span class="attr">type</span>: <span class="string">'list'</span>,</div><div class="line">    <span class="attr">name</span>: <span class="string">'prize'</span>,</div><div class="line">    <span class="attr">message</span>: <span class="string">'For leaving a comment, you get a freebie'</span>,</div><div class="line">    <span class="attr">choices</span>: [<span class="string">'cake'</span>, <span class="string">'fries'</span>],</div><div class="line">    <span class="attr">when</span>: <span class="function"><span class="keyword">function</span> (<span class="params">answers</span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> answers.comments !== <span class="string">'Nope, all good!'</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">];</div><div class="line"></div><div class="line">inquirer.prompt(questions).then(<span class="function"><span class="keyword">function</span> (<span class="params">answers</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'\nOrder receipt:'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(answers, <span class="literal">null</span>, <span class="string">'  '</span>));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>运行效果：<br><img src="/images/page/inquirer/2.png" alt=""><br><img src="/images/page/inquirer/3.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建交互式命令行用户接口&lt;br&gt;&lt;img src=&quot;/images/page/inquirer/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;github地址： &lt;a href=&quot;https://github.com/SBoudrias/Inquirer.js&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/SBoudrias/Inquirer.js&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="nodejs" scheme="http://html-js.site/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>commander.js-node.js 命令行接口的完整解决方案</title>
    <link href="http://html-js.site/2017/05/26/commander-js-node-js-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%8C%E6%95%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://html-js.site/2017/05/26/commander-js-node-js-命令行接口的完整解决方案/</id>
    <published>2017-05-26T01:52:17.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Commander-js"><a href="#Commander-js" class="headerlink" title="Commander.js"></a>Commander.js</h1><p><a href="http://nodejs.org" target="_blank" rel="external">node.js</a> 命令行接口的完整解决方案，灵感来自 Ruby 的 commander。<br><a href="http://tj.github.com/commander.js/" target="_blank" rel="external">API 文档</a><br>本文所有的例子都可以用 <code>node name.js &lt;command/option&gt;</code> 执行<br>吐槽：commander.js中文文档真的好难找哇<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install commander</div></pre></td></tr></table></figure>
<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p>定义并使用 commander 的选项功能 <code>.option()</code> 方法。作为这些选项的文档，下面的例子会解析来自 <code>progress.argv</code> 指定的参数和选项，留下剩余未被选择的参数放到 <code>program.args</code> 数组中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Module dependencies.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .option(<span class="string">'-p, --peppers'</span>, <span class="string">'Add peppers'</span>)</div><div class="line">  .option(<span class="string">'-P, --pineapple'</span>, <span class="string">'Add pineapple'</span>)</div><div class="line">  .option(<span class="string">'-b, --bbq-sauce'</span>, <span class="string">'Add bbq sauce'</span>)</div><div class="line">  .option(<span class="string">'-c, --cheese [type]'</span>, <span class="string">'Add the specified type of cheese [marble]'</span>, <span class="string">'marble'</span>)</div><div class="line">  .parse(process.argv);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'you ordered a pizza with:'</span>);</div><div class="line"><span class="keyword">if</span> (program.peppers) <span class="built_in">console</span>.log(<span class="string">'  - peppers'</span>);</div><div class="line"><span class="keyword">if</span> (program.pineapple) <span class="built_in">console</span>.log(<span class="string">'  - pineapple'</span>);</div><div class="line"><span class="keyword">if</span> (program.bbqSauce) <span class="built_in">console</span>.log(<span class="string">'  - bbq'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'  - %s cheese'</span>, program.cheese);</div></pre></td></tr></table></figure></p>
<p>短标志可以作为单独的参数传递。像 <code>-abc</code> 等于 <code>-a -b -c</code>。多词组成的选项，像“–template-engine”会变成 <code>program.templateEngine</code> 等。</p>
<h2 id="强制多态"><a href="#强制多态" class="headerlink" title="强制多态"></a>强制多态</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> val.split(<span class="string">'..'</span>).map(<span class="built_in">Number</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> val.split(<span class="string">','</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">collect</span>(<span class="params">val, memo</span>) </span>&#123;</div><div class="line">  memo.push(val);</div><div class="line">  <span class="keyword">return</span> memo;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">increaseVerbosity</span>(<span class="params">v, total</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> total + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .usage(<span class="string">'[options] &lt;file ...&gt;'</span>)</div><div class="line">  .option(<span class="string">'-i, --integer &lt;n&gt;'</span>, <span class="string">'An integer argument'</span>, <span class="built_in">parseInt</span>)</div><div class="line">  .option(<span class="string">'-f, --float &lt;n&gt;'</span>, <span class="string">'A float argument'</span>, <span class="built_in">parseFloat</span>)</div><div class="line">  .option(<span class="string">'-r, --range &lt;a&gt;..&lt;b&gt;'</span>, <span class="string">'A range'</span>, range)</div><div class="line">  .option(<span class="string">'-l, --list &lt;items&gt;'</span>, <span class="string">'A list'</span>, list)</div><div class="line">  .option(<span class="string">'-o, --optional [value]'</span>, <span class="string">'An optional value'</span>)</div><div class="line">  .option(<span class="string">'-c, --collect [value]'</span>, <span class="string">'A repeatable value'</span>, collect, [])</div><div class="line">  .option(<span class="string">'-v, --verbose'</span>, <span class="string">'A value that can be increased'</span>, increaseVerbosity, <span class="number">0</span>)</div><div class="line">  .parse(process.argv);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">' int: %j'</span>, program.integer);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' float: %j'</span>, program.float);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' optional: %j'</span>, program.optional);</div><div class="line">program.range = program.range || [];</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' range: %j..%j'</span>, program.range[<span class="number">0</span>], program.range[<span class="number">1</span>]);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' list: %j'</span>, program.list);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' collect: %j'</span>, program.collect);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' verbosity: %j'</span>, program.verbose);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' args: %j'</span>, program.args);</div></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .option(<span class="string">'-s --size &lt;size&gt;'</span>, <span class="string">'Pizza size'</span>, /^(large|medium|small)$/i, <span class="string">'medium'</span>)</div><div class="line">  .option(<span class="string">'-d --drink [drink]'</span>, <span class="string">'Drink'</span>, /^(coke|pepsi|izze)$/i)</div><div class="line">  .parse(process.argv);</div><div class="line">  </div><div class="line"><span class="built_in">console</span>.log(<span class="string">' size: %j'</span>, program.size);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">' drink: %j'</span>, program.drink);</div></pre></td></tr></table></figure>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>一个命令的最后一个参数可以是可变参数, 并且只能是最后一个参数。为了使参数可变，你需要在参数名后面追加 …。 下面是个示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Module dependencies.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .command(<span class="string">'rmdir &lt;dir&gt; [otherDirs...]'</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span> (<span class="params">dir, otherDirs</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rmdir %s'</span>, dir);</div><div class="line">    <span class="keyword">if</span> (otherDirs) &#123;</div><div class="line">      otherDirs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">oDir</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'rmdir %s'</span>, oDir);</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program.parse(process.argv);</div></pre></td></tr></table></figure></p>
<p>数组 是可以用于给可变参数传值的。 这适用于 <code>program.args</code> 以及参数传递，以你的行动证明上述。 你可以如上所示的去尝试。</p>
<h2 id="指定参数的语法"><a href="#指定参数的语法" class="headerlink" title="指定参数的语法"></a>指定参数的语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'../'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .arguments(<span class="string">'&lt;cmd&gt; [env]'</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span> (<span class="params">cmd, env</span>) </span>&#123;</div><div class="line">     cmdValue = cmd;</div><div class="line">     envValue = env;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program.parse(process.argv);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> cmdValue === <span class="string">'undefined'</span>) &#123;</div><div class="line">   <span class="built_in">console</span>.error(<span class="string">'no command given!'</span>);</div><div class="line">   process.exit(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'command:'</span>, cmdValue);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'environment:'</span>, envValue || <span class="string">"no environment given"</span>);</div></pre></td></tr></table></figure>
<h2 id="Git-风格的子命令"><a href="#Git-风格的子命令" class="headerlink" title="Git 风格的子命令"></a>Git 风格的子命令</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// file: ./examples/pm</span></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'..'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .command(<span class="string">'install [name]'</span>, <span class="string">'install one or more packages'</span>)</div><div class="line">  .command(<span class="string">'search [query]'</span>, <span class="string">'search with optional query'</span>)</div><div class="line">  .command(<span class="string">'list'</span>, <span class="string">'list packages installed'</span>, &#123;<span class="attr">isDefault</span>: <span class="literal">true</span>&#125;)</div><div class="line">  .parse(process.argv);</div></pre></td></tr></table></figure>
<p>当说明参数调用 <code>.command()</code> 时，没有 <code>.action(callback)</code> 应调用来处理子命令，否则会出错。这告诉 <code>commander</code>，你要使用单独的可执行文件的子命令，就像 <code>git(1)</code> 和其他流行工具一样。 <code>Commander</code> 将尝试在入口脚本的目录中搜索可执行文件，（像<code>./examples/pm</code>）与名称 <code>program-command</code>，像 <code>pm-install</code>，<code>pm-search</code>。</p>
<p>对 <code>.command()</code> 的调用，可以传递选项。指定 <code>opts.noHelp</code> 为 <code>true</code> 将从生成的帮助输出中删除选项。如果没有其他子命令指定，指定 <code>opts.isDefault</code> 为 <code>true</code> 将运行子命令。</p>
<p>如果打算全局<code>（--global）</code>安装该命令，请确保可执行文件有适当的模式，如 <code>&#39;755&#39;</code>。</p>
<h3 id="–harmony"><a href="#–harmony" class="headerlink" title="–harmony"></a>–harmony</h3><p>您可以启用 <code>--harmoney</code> 选项在两个方面：</p>
<ul>
<li>用 #!/usr/bin/env node –harmony 在子命令脚本中。注意一些系统版本不支持此模式。</li>
<li>用 –harmoney 选项时调用的命令，像 node –harmony examples/pm publish。–harmoney 选项当产生一个子命令进程时保留选项。</li>
</ul>
<h2 id="自动化帮助信息-–help"><a href="#自动化帮助信息-–help" class="headerlink" title="自动化帮助信息 –help"></a>自动化帮助信息 –help</h2><p>帮助信息是 commander 基于你的程序自动生成的，下面是 <code>--help</code> 生成的帮助信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ ./examples/pizza --help</div><div class="line"></div><div class="line">   Usage: pizza [options]</div><div class="line"></div><div class="line">   An application <span class="keyword">for</span> pizzas ordering</div><div class="line"></div><div class="line">   Options:</div><div class="line"></div><div class="line">     -h, --help           output usage information</div><div class="line">     -V, --version        output the version number</div><div class="line">     -p, --peppers        Add peppers</div><div class="line">     -P, --pineapple      Add pineapple</div><div class="line">     -b, --bbq            Add bbq sauce</div><div class="line">     -c, --cheese &lt;type&gt;  Add the specified type <span class="keyword">of</span> cheese [marble]</div><div class="line">     -C, --no-cheese      You <span class="keyword">do</span> not want any cheese</div></pre></td></tr></table></figure></p>
<h2 id="自定义帮助"><a href="#自定义帮助" class="headerlink" title="自定义帮助"></a>自定义帮助</h2><p>你可以显示任何 <code>-h</code>, <code>--help</code> 信息，通过监听 <code>--help</code> 。一旦你完成了 Commander 将自动退出，你的程序的其余部分不会展示。例如在下面的 “stuff” 将不会在执行 <code>--help</code> 时输出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env node</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Module dependencies.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .option(<span class="string">'-f, --foo'</span>, <span class="string">'enable some foo'</span>)</div><div class="line">  .option(<span class="string">'-b, --bar'</span>, <span class="string">'enable some bar'</span>)</div><div class="line">  .option(<span class="string">'-B, --baz'</span>, <span class="string">'enable some baz'</span>);</div><div class="line"></div><div class="line"><span class="comment">// must be before .parse() since</span></div><div class="line"><span class="comment">// node's emit() is immediate</span></div><div class="line"></div><div class="line">program.on(<span class="string">'--help'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'  Examples:'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">''</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'    $ custom-help --help'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'    $ custom-help -h'</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">''</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">program.parse(process.argv);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'stuff'</span>);</div></pre></td></tr></table></figure></p>
<p>下列帮助信息是运行 <code>node script-name.js -h</code> or <code>node script-name.js --help</code> 时输出的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Usage: custom-help [options]</div><div class="line"></div><div class="line">Options:</div><div class="line"></div><div class="line">  -h, --help     output usage information</div><div class="line">  -V, --version  output the version number</div><div class="line">  -f, --foo      enable some foo</div><div class="line">  -b, --bar      enable some bar</div><div class="line">  -B, --baz      enable some baz</div><div class="line"></div><div class="line">Examples:</div><div class="line"></div><div class="line">  $ custom-help --help</div><div class="line">  $ custom-help -h</div></pre></td></tr></table></figure></p>
<h3 id="outputHelp-cb"><a href="#outputHelp-cb" class="headerlink" title=".outputHelp(cb)"></a>.outputHelp(cb)</h3><p>不退出输出帮助信息。 可选的回调可在显示帮助文本后处理。 如果你想显示默认的帮助（例如，如果没有提供命令），你可以使用类似的东西：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"><span class="keyword">var</span> colors = <span class="built_in">require</span>(<span class="string">'colors'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .command(<span class="string">'getstream [url]'</span>, <span class="string">'get stream URL'</span>)</div><div class="line">  .parse(process.argv);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!process.argv.slice(<span class="number">2</span>).length) &#123;</div><div class="line">    program.outputHelp(make_red);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">make_red</span>(<span class="params">txt</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> colors.red(txt); <span class="comment">// 在控制台上显示红色的帮助文本</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="help-cb"><a href="#help-cb" class="headerlink" title=".help(cb)"></a>.help(cb)</h3><p>输出帮助信息并立即退出。 可选的回调可在显示帮助文本后处理。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</div><div class="line"></div><div class="line">program</div><div class="line">  .version(<span class="string">'0.0.1'</span>)</div><div class="line">  .option(<span class="string">'-C, --chdir &lt;path&gt;'</span>, <span class="string">'change the working directory'</span>)</div><div class="line">  .option(<span class="string">'-c, --config &lt;path&gt;'</span>, <span class="string">'set config path. defaults to ./deploy.conf'</span>)</div><div class="line">  .option(<span class="string">'-T, --no-tests'</span>, <span class="string">'ignore test hook'</span>)</div><div class="line"></div><div class="line">program</div><div class="line">  .command(<span class="string">'setup [env]'</span>)</div><div class="line">  .description(<span class="string">'run setup commands for all envs'</span>)</div><div class="line">  .option(<span class="string">"-s, --setup_mode [mode]"</span>, <span class="string">"Which setup mode to use"</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span>(<span class="params">env, options</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> mode = options.setup_mode || <span class="string">"normal"</span>;</div><div class="line">    env = env || <span class="string">'all'</span>;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'setup for %s env(s) with %s mode'</span>, env, mode);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program</div><div class="line">  .command(<span class="string">'exec &lt;cmd&gt;'</span>)</div><div class="line">  .alias(<span class="string">'ex'</span>)</div><div class="line">  .description(<span class="string">'execute the given remote cmd'</span>)</div><div class="line">  .option(<span class="string">"-e, --exec_mode &lt;mode&gt;"</span>, <span class="string">"Which exec mode to use"</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span>(<span class="params">cmd, options</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'exec "%s" using %s mode'</span>, cmd, options.exec_mode);</div><div class="line">  &#125;).on(<span class="string">'--help'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'  Examples:'</span>);</div><div class="line">    <span class="built_in">console</span>.log();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'    $ deploy exec sequential'</span>);</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'    $ deploy exec async'</span>);</div><div class="line">    <span class="built_in">console</span>.log();</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program</div><div class="line">  .command(<span class="string">'*'</span>)</div><div class="line">  .action(<span class="function"><span class="keyword">function</span>(<span class="params">env</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'deploying "%s"'</span>, env);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">program.parse(process.argv);</div></pre></td></tr></table></figure>
<p>更多的 <a href="https://github.com/tj/commander.js/tree/master/examples" target="_blank" rel="external">演示 </a>可以在这里找到.</p>
<p>参考链接：<br><a href="https://github.com/tj/commander.js" target="_blank" rel="external">commander.js github项目地址</a><br><a href="https://github.com/tj/commander.js/blob/master/Readme_zh-CN.md" target="_blank" rel="external">commander.js 中文文档</a><br><a href="http://tj.github.io/commander.js/" target="_blank" rel="external">commander.js api</a><br><a href="http://zhiye.li/2015-01-15-intro-to-commander.js-zh-cn.html" target="_blank" rel="external">使用commander.js创建nodejs命令行工具 by zhiyelee</a><br><a href="http://blog.fens.me/nodejs-commander/" target="_blank" rel="external">Commander写自己的Nodejs命令</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Commander-js&quot;&gt;&lt;a href=&quot;#Commander-js&quot; class=&quot;headerlink&quot; title=&quot;Commander.js&quot;&gt;&lt;/a&gt;Commander.js&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://nodejs.org&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node.js&lt;/a&gt; 命令行接口的完整解决方案，灵感来自 Ruby 的 commander。&lt;br&gt;&lt;a href=&quot;http://tj.github.com/commander.js/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;API 文档&lt;/a&gt;&lt;br&gt;本文所有的例子都可以用 &lt;code&gt;node name.js &amp;lt;command/option&amp;gt;&lt;/code&gt; 执行&lt;br&gt;吐槽：commander.js中文文档真的好难找哇&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>当你不知道干什么的时候，可以看看这些</title>
    <link href="http://html-js.site/2017/05/22/%E5%BD%93%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E8%BF%99%E4%BA%9B/"/>
    <id>http://html-js.site/2017/05/22/当你不知道干什么的时候，可以看看这些/</id>
    <published>2017-05-22T09:15:38.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可以看看电影视频"><a href="#可以看看电影视频" class="headerlink" title="可以看看电影视频"></a>可以看看电影视频</h2><p><a href="https://movie.douban.com/top250" target="_blank" rel="external">豆瓣电影250</a> 随便挑一个都是百看不厌<br><a href="http://open.163.com/" target="_blank" rel="external">网易公开课</a> 不带目的随便看几个ted<br><a href="http://letshareba.com/movie" target="_blank" rel="external">最近正在热映电影</a> 可以看看评分，然后去电影院看看</p>
<h2 id="可以看看知乎"><a href="#可以看看知乎" class="headerlink" title="可以看看知乎"></a>可以看看知乎</h2><p><a href="https://www.zhihu.com/collection/37406996" target="_blank" rel="external">知乎5000斩</a> 都是5K赞以上的回答</p>
<a id="more"></a>
<h2 id="可以开发些小工具"><a href="#可以开发些小工具" class="headerlink" title="可以开发些小工具"></a>可以开发些小工具</h2><p><a href="https://leetcode.com/" target="_blank" rel="external">leetcode</a> 做几道题，消磨下时间<br><a href="https://www.zhihu.com/question/36132174/answer/70798699" target="_blank" rel="external">爬虫可以干什么</a> 可以开发些有趣的东西<br><a href="https://www.zhihu.com/question/27621722" target="_blank" rel="external">能利用爬虫技术做到哪些很酷很有趣很有用的事情？</a> 有些真是脑洞大开<br><a href="http://www.ishuchao.com/topic/294" target="_blank" rel="external">V2EX上最值得收藏的100个话题</a> 有好多可以自己实现下<br><a href="http://www.pythonchallenge.com/" target="_blank" rel="external">python challenge</a> 至今还未通关的python挑战</p>
<h2 id="可以看看大神们的博客"><a href="#可以看看大神们的博客" class="headerlink" title="可以看看大神们的博客"></a>可以看看大神们的博客</h2><blockquote>
<p>放些我经常看的博主们</p>
</blockquote>
<p><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">阮一峰</a> 阮老师<br><a href="http://coolshell.cn/" target="_blank" rel="external">酷壳</a> 左耳朵耗子<br><a href="http://mindhacks.cn/" target="_blank" rel="external">刘未鹏</a> 思维改变生活<br><a href="http://blog.csdn.net/v_JULY_v" target="_blank" rel="external">July</a> 看看题解和思路<br><a href="https://www.byvoid.com/" target="_blank" rel="external">byVoid</a> 算法，node，c++大神<br><a href="http://www.zhangxinxu.com/wordpress/" target="_blank" rel="external">张鑫旭</a> css大神<br><a href="http://www.cnblogs.com/aaronjs/" target="_blank" rel="external">Aaron</a> 以大多数人的努力程度之低，根本轮不到拼天赋<br><a href="http://www.cnblogs.com/yexiaochai" target="_blank" rel="external">叶小钗</a> 开始新的旅途<br><a href="http://barretlee.com/" target="_blank" rel="external">李靖</a> 小胡子哥<br><a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html" target="_blank" rel="external">汤姆大叔</a> 每次看都有不同的体会</p>
<h2 id="这里收藏些开发工具类"><a href="#这里收藏些开发工具类" class="headerlink" title="这里收藏些开发工具类"></a>这里收藏些开发工具类</h2><blockquote>
<p>这里放些我开发生活经常用到的工具类网站</p>
</blockquote>
<p><a href="https://tinypng.com/" target="_blank" rel="external">图片在线压缩</a><br><a href="http://tool.chinaz.com/regex/?jdfwkey=lskex1" target="_blank" rel="external">正则表达式</a></p>
<h2 id="找找好用的Mac软件"><a href="#找找好用的Mac软件" class="headerlink" title="找找好用的Mac软件"></a>找找好用的Mac软件</h2><p><a href="http://www.waitsun.com/" target="_blank" rel="external">爱情守望者</a> 网站做得比较良心<br><a href="https://github.com/hzlzh/Best-App" target="_blank" rel="external">Best App</a> 收集&amp;推荐优秀的 Apps/硬件/技巧/周边等 － 感谢jason提供</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;可以看看电影视频&quot;&gt;&lt;a href=&quot;#可以看看电影视频&quot; class=&quot;headerlink&quot; title=&quot;可以看看电影视频&quot;&gt;&lt;/a&gt;可以看看电影视频&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://movie.douban.com/top250&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;豆瓣电影250&lt;/a&gt; 随便挑一个都是百看不厌&lt;br&gt;&lt;a href=&quot;http://open.163.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;网易公开课&lt;/a&gt; 不带目的随便看几个ted&lt;br&gt;&lt;a href=&quot;http://letshareba.com/movie&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;最近正在热映电影&lt;/a&gt; 可以看看评分，然后去电影院看看&lt;/p&gt;
&lt;h2 id=&quot;可以看看知乎&quot;&gt;&lt;a href=&quot;#可以看看知乎&quot; class=&quot;headerlink&quot; title=&quot;可以看看知乎&quot;&gt;&lt;/a&gt;可以看看知乎&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/collection/37406996&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;知乎5000斩&lt;/a&gt; 都是5K赞以上的回答&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://html-js.site/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>前端进阶之路</title>
    <link href="http://html-js.site/2017/05/17/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
    <id>http://html-js.site/2017/05/17/前端进阶之路/</id>
    <published>2017-05-17T07:49:24.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近一直忙于项目和业务，略疲惫，好在还是利用空闲学习了不少的东西，自勉</p>
</blockquote>
<h2 id="React和Vue对比"><a href="#React和Vue对比" class="headerlink" title="React和Vue对比"></a>React和Vue对比</h2><p>相同点:</p>
<ul>
<li>数据驱动视图，提供响应式的视图组件</li>
<li>都有Virtual DOM，组件化开发，通过props参数进行父子组件数据的传递，都实现webComponents规范</li>
<li>数据流动单向</li>
<li>都支持服务端渲染</li>
<li>都有支持native的方案，React的<code>React native</code>，Vue的<code>weex</code><a id="more"></a>
不同点：</li>
<li>社区：React社区还是要比vue大很多；</li>
<li>开发模式：React在view层侵入性还是要比Vue大很多的,React严格上只针对MVC的view层，Vue则是MVVM模式的一种实现；</li>
<li>数据绑定：Vue有实现了双向数据绑定，React数据流动是单向的</li>
<li>数据渲染：对于大规模数据渲染，React要比Vue更快，渲染机制启动时候要做的工作比较多；</li>
<li>数据更新方面：Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少。React在复杂的应用里有两个选择:<ol>
<li>手动添加 shouldComponentUpdate 来避免不需要的 vdom re-render。 </li>
<li>Components 尽可能都用 pureRenderMixin，然后采用 redux 结构 + Immutable.js；</li>
</ol>
</li>
<li>开发风格的偏好：React 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript 了，即”all in js”；Vue进阶之后推荐的是使用 webpack + vue-loader 的单文件组件格式，即html,css,js写在同一个文件；</li>
<li>使用场景：React配合Redux架构适合超大规模多人协作的复杂项目;Vue则适合小快灵的项目。对于需要对 DOM 进行很多自定义操作的项目，Vue 的灵活性优于 React；</li>
<li>Vue要比React更好上手，具体可能体现在很多人不熟悉React的JSX语法和函数式编程的思想，以及想要发挥出React的最大威力需要学习它一系列生态的缘故；</li>
<li>Vue着重提高开发效率,让前端程序员更快速方便的开发应用。React着重于变革开发思想，提升前端程序员编程的深度与创造力,让前端工程师成为真正的程序员而不是UI的构建者；</li>
</ul>
<h2 id="gulp和webpack区别"><a href="#gulp和webpack区别" class="headerlink" title="gulp和webpack区别"></a>gulp和webpack区别</h2><p>gulp是一种工具，我们可以用它来优化前端的工作流程，比如自动刷新页面、combo、压缩css、js、编译less等等。具体体现为：在gulp的配置文件中书写一个个的task，webpack则是一种打包工具，或者说是一种模块化解决方案，实际上很大一部分人刚开始使用webpack的方式就是通过gulp-webpack这个插件，写好task来使用webpack对前端的一些文件进行打包;<br>gulp的处理任务需要自己去写，webpack则有现成的解决方案，只需要在webpack.config.js配置好即可;</p>
<h2 id="防止重复发送Ajax请求"><a href="#防止重复发送Ajax请求" class="headerlink" title="防止重复发送Ajax请求"></a>防止重复发送Ajax请求</h2><p>用户点击之后按钮disabled;<br>函数节流<br>abort掉上一个请求。</p>
<h2 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h2><ul>
<li>事件捕获阶段(capturing phase)。事件从document一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
<li>事件处理阶段(target phase)。事件到达目标元素, 触发目标元素的监听函数。</li>
<li>事件冒泡阶段(bubbling phase)。事件从目标元素冒泡到document, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行。</li>
</ul>
<h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><h3 id="Expires策略"><a href="#Expires策略" class="headerlink" title="Expires策略"></a>Expires策略</h3><p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。</p>
<h3 id="Cache-Control策略"><a href="#Cache-Control策略" class="headerlink" title="Cache-Control策略"></a>Cache-Control策略</h3><p>Cache-Control与Expires的作用一致，都是指明当前资源的<strong>有效期</strong>，控制浏览器是否直接从浏览器缓读取数据还是重新发请求到服务器取数据。只不过Cache-Control的<strong>选择更多，设置更细致</strong>，如果同时设置的话，其<strong>优先级高于Expires</strong>。</p>
<p>以上是设置缓存时间的两种方法。那么当缓存时间过了咋整呢？有人肯定说了，那就再次发起请求啊，这是对的。问题是如果服务器资源并没有更新呢？比如说我有一个jQuery.js文件已经缓存了，当它的缓存时间到了之后服务器的jQuery.js文件也没有更新，那实际上我们直接使用本地缓存的文件就可以啊！没必要浪费带宽和时间去重新请求一个新的文件啊！这时候我们就需要再进一步看一下HTTP协议里这几个参数的作用了。</p>
<p>###　Last-Modified/If-Modified-Since</p>
<p>首先Last-Modified/If-Modified-Since要配合Cache-Control使用。</p>
<ul>
<li>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间(这个参数是和Cache-Control一起过来的)。</li>
<li>If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 <code>If-Modified-Since</code>，表示请求时间。<strong>web服务器收到请求后发现有头If-Modified-Since ，则与被请求资源的最后修改时间进行比对</strong>。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。</li>
</ul>
<h3 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h3><p>Etag/If-None-Match也要配合Cache-Control使用。</p>
<ul>
<li>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器觉得）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</li>
<li>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</li>
</ul>
<h3 id="ETag和Last-Modified"><a href="#ETag和Last-Modified" class="headerlink" title="ETag和Last-Modified"></a>ETag和Last-Modified</h3><p>HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p>
<ul>
<li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>
<p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p>
<h2 id="Ajax的状态值与HTTP状态码"><a href="#Ajax的状态值与HTTP状态码" class="headerlink" title="Ajax的状态值与HTTP状态码"></a>Ajax的状态值与HTTP状态码</h2><h3 id="Ajax的状态值"><a href="#Ajax的状态值" class="headerlink" title="Ajax的状态值"></a>Ajax的状态值</h3><ul>
<li>0: (未初始化)还没有调用send()方法。</li>
<li>1: (载入)已经调用send()方法，正在派发请求。</li>
<li>2: (载入完成)send()已经执行完成，已经接收到全部的响应内容。</li>
<li>3: (交互)正在解析响应内容。</li>
<li>4: (完成)响应内容已经解析完成，用户可以调用。</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul>
<li>200 &amp; OK: 请求成功；</li>
<li>204 &amp; No Content: 请求处理成功，但没有资源可以返回；</li>
<li>206 &amp; Partial Content: 对资源某一部分进行请求(比如对于只加载了一般的图片剩余部分的请求)；</li>
<li>301 &amp; Move Permanently: 永久性重定向；</li>
<li>302 &amp; Found： 临时性重定向；</li>
<li>303 &amp; See Other: 请求资源存在另一个URI，应使用get方法请求；</li>
<li>304 &amp; Not Modified: 服务器判断本地缓存未更新，可以直接使用本地的缓存；</li>
<li>307 &amp; Temporary Redirect: 临时重定向；</li>
<li>400 &amp; Bad Request: 请求报文存在语法错误；</li>
<li>401 &amp; Unauthorized: 请求需要通过HTTP认证；</li>
<li>403 &amp; Forbidden: 请求资源被服务器拒绝，访问权限的问题；</li>
<li>404 &amp; Not Found: 服务器上没有请求的资源；</li>
<li>500 &amp; Internal Server Error: 服务器执行请求时出现错误；</li>
<li>502 &amp; Bad Gateway: 错误的网关；</li>
<li>503 &amp; Service Unavailable: 服务器超载或正在维护，无法处理请求；</li>
<li>504 &amp; Gateway timeout: 网关超时；</li>
</ul>
<h2 id="React-router原理"><a href="#React-router原理" class="headerlink" title="React-router原理"></a>React-router原理</h2><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><ul>
<li>老浏览器的history: 主要通过hash来实现，对应<code>createHashHistory</code></li>
<li>高版本浏览器: 通过html5里面的history，对应<code>createBrowserHistory</code></li>
<li>node环境下: 主要存储在memeory里面，对应<code>createMemoryHistory</code></li>
</ul>
<p>内部createHistory实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 内部的抽象实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createHistory</span>(<span class="params">options=&#123;&#125;</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  return &#123;</div><div class="line">    listenBefore, <span class="comment">// 内部的hook机制，可以在location发生变化前执行某些行为，AOP的实现</span></div><div class="line">    listen, <span class="comment">// location发生改变时触发回调</span></div><div class="line">    transitionTo, <span class="comment">// 执行location的改变</span></div><div class="line">    push, <span class="comment">// 改变location</span></div><div class="line">    replace,</div><div class="line">    go,</div><div class="line">    goBack,</div><div class="line">    goForward,</div><div class="line">    createKey, <span class="comment">// 创建location的key，用于唯一标示该location，是随机生成的</span></div><div class="line">    createPath,</div><div class="line">    createHref,</div><div class="line">    createLocation, <span class="comment">// 创建location</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>createLocation方法:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createLocation</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    pathname, <span class="comment">// url的基本路径</span></div><div class="line">    search, <span class="comment">// 查询字段</span></div><div class="line">    hash, <span class="comment">// url中的hash值</span></div><div class="line">    state, <span class="comment">// url对应的state字段</span></div><div class="line">    action, <span class="comment">// 分为push、replace、pop三种</span></div><div class="line">    key <span class="comment">// 生成方法为: Math.random().toString(36).substr(2, length)</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>三种方法各自执行URL前进的方式：</p>
<ul>
<li>createBrowserHistory: pushState、replaceState</li>
<li>createHashHistory: location.hash=<em>*</em> location.replace()</li>
<li>createMemoryHistory: 在内存中进行历史记录的存储</li>
</ul>
<p>伪代码实现:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// createBrowserHistory(HTML5)中的前进实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  const historyState = &#123; key &#125;;</div><div class="line">  ...</div><div class="line">  if (location.action === <span class="string">'PUSH'</span>) ) &#123;</div><div class="line">    <span class="built_in">window</span>.history.pushState(historyState, <span class="literal">null</span>, path);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.history.replaceState(historyState, <span class="literal">null</span>, path)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// createHashHistory的内部实现</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  if (location.action === <span class="string">'PUSH'</span>) ) &#123;</div><div class="line">    <span class="built_in">window</span>.location.hash = path;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">window</span>.location.replace(</div><div class="line">    <span class="built_in">window</span>.location.pathname + <span class="built_in">window</span>.location.search + <span class="string">'#'</span> + path</div><div class="line">  );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// createMemoryHistory的内部实现</span></div><div class="line">entries = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishTransition</span>(<span class="params">location</span>) </span>&#123;</div><div class="line">  ...</div><div class="line">  switch (location.action) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'PUSH'</span>:</div><div class="line">      entries.push(location);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    <span class="keyword">case</span> <span class="string">'REPLACE'</span>:</div><div class="line">      entries[current] = location;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="React-router的基本原理"><a href="#React-router的基本原理" class="headerlink" title="React-router的基本原理"></a>React-router的基本原理</h3><p><code>URL</code>对应<code>Location</code>对象，而<code>UI</code>是由<code>react</code>的 <code>components</code>来决定的，这样就转变成<code>location</code>与<code>components</code>之间的同步问题。</p>
<h2 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h2><p>每一个对象都会在内部链接到另一个对象(该对象的原型对象)，该对象有一个原型<code>prototype</code>，当访问对象的属性或是方法的时候，不仅仅会在原对象上查找，还会顺着原型链在原型对象的原型链上查找，直到查到<code>null</code>(所有原型链的顶层)为止。原型是JavaScript实现继承的基础，<code>new</code>关键字做的主要的事情就是将实例对象的<code>__proto__</code>属性指向原型对象的<code>prototype</code>。</p>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><ul>
<li>闭包是javascript支持<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0" target="_blank" rel="external">头等函数</a>的一种方式，它是一个能够引用其内部作用域变量(在本作用域第一次声明的变量)的表达式，这个表达式可以赋值给某个变量，可以作为参数传递给函数，也可以作为一个函数返回值返回。</li>
<li>闭包是函数开始执行的时候被分配的一个<a href="http://baike.baidu.com/link?url=x9za8fl-K8Gsdc0IFBbC5fTininX3H8qVBuSPsChIJd8bmzTRXvd8scDL1uCYKLS26m6GMbXgHFC5K8yXz7nZ3eImibufpfwiBWzlBDAyT_" target="_blank" rel="external">栈帧</a>，在函数执行结束返回后仍不会被释放(就好像一个栈帧被分配在堆里而不是栈里！)</li>
</ul>
<h3 id="闭包的应用："><a href="#闭包的应用：" class="headerlink" title="闭包的应用："></a>闭包的应用：</h3><ul>
<li><p>比如写柯里化函数的时候利用闭包，保存参数在内存中；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</div><div class="line">  	<span class="comment">//格式化arguments</span></div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      	<span class="comment">//收集所有的参数在同一个数组中，进行计算</span></div><div class="line">      	<span class="keyword">var</span> _args = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">      	<span class="keyword">return</span> fun.apply(<span class="literal">null</span>, _args);</div><div class="line">  	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>模拟私有变量或是私有方法；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> people = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</div><div class="line">  	<span class="keyword">var</span> num = num;</div><div class="line">  	<span class="keyword">return</span> &#123;</div><div class="line">    	<span class="attr">increase</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          	num++;</div><div class="line">		&#125;,</div><div class="line">      	<span class="attr">get</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">          	<span class="keyword">return</span> num;</div><div class="line">      	&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> man = people(<span class="number">4</span>);</div><div class="line">man.increase();</div><div class="line">man.get();</div></pre></td></tr></table></figure>
</li>
<li><p>避免引用错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">  	(<span class="function"><span class="keyword">function</span>(<span class="params">_i</span>) </span>&#123;</div><div class="line">      	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      		<span class="built_in">console</span>.log(_i)</div><div class="line">		&#125;, <span class="number">1000</span>)</div><div class="line">  	&#125;)(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="图片懒加载与预加载"><a href="#图片懒加载与预加载" class="headerlink" title="图片懒加载与预加载"></a>图片懒加载与预加载</h2><ul>
<li>图片懒加载的原理就是暂时不设置图片的<code>src</code>属性，而是将图片的<code>url</code>隐藏起来，比如先写在<code>data-src</code>里面，等某些事件触发的时候(比如滚动到底部，点击加载图片)再将图片真实的<code>url</code>放进<code>src</code>属性里面，从而实现图片的延迟加载</li>
<li>图片预加载，是指在一些需要展示大量图片的网站，实现图片的提前加载。从而提升用户体验。常用的方式有两种，一种是隐藏在css的<code>background</code>的<code>url</code>属性里面，一种是通过javascript的<code>Image</code>对象设置实例对象的<code>src</code>属性实现图片的预加载。相关代码如下：</li>
</ul>
<h3 id="CSS预加载图片方式："><a href="#CSS预加载图片方式：" class="headerlink" title="CSS预加载图片方式："></a>CSS预加载图片方式：</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#preload-01</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(http://domain.tld/image-01.png) no-repeat -<span class="number">9999px</span> -<span class="number">9999px</span>; &#125;  </div><div class="line"><span class="selector-id">#preload-02</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(http://domain.tld/image-02.png) no-repeat -<span class="number">9999px</span> -<span class="number">9999px</span>; &#125;  </div><div class="line"><span class="selector-id">#preload-03</span> &#123; <span class="attribute">background</span>: <span class="built_in">url</span>(http://domain.tld/image-03.png) no-repeat -<span class="number">9999px</span> -<span class="number">9999px</span>; &#125;</div></pre></td></tr></table></figure>
<h3 id="Javascript预加载图片的方式："><a href="#Javascript预加载图片的方式：" class="headerlink" title="Javascript预加载图片的方式："></a>Javascript预加载图片的方式：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">preloadImg</span>(<span class="params">url</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</div><div class="line">    img.src = url;</div><div class="line">    <span class="keyword">if</span>(img.complete) &#123;</div><div class="line">        <span class="comment">//接下来可以使用图片了</span></div><div class="line">        <span class="comment">//do something here</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">//接下来可以使用图片了</span></div><div class="line">            <span class="comment">//do something here</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域的方式有很多种，最常用的是<code>jsonp</code>主要利用了<code>script</code>的开放策略:通过<code>script</code>标签引入一个<code>js</code>或者是一个其他后缀形式（如<code>php</code>，<code>jsp</code>等）的文件，此文件返回一个<code>js</code>函数的调用。缺点在于只支持<code>get</code>请求而且存在安全问题。<br><strong>CORS</strong>跨域，关键在于服务器，如果服务器实现了CORS跨域的接口，那么就可以使用ajax(请求路径为绝对路径)进行跨域请求。CORS请求分为两种，一种是简单请求，一种是非简单请求。简单请求是指请求方法在<code>HEAD</code>,<code>GET</code>,<code>POST</code>三者之间并且请求头信息局限在</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
<h3 id="非简单请求请求头："><a href="#非简单请求请求头：" class="headerlink" title="非简单请求请求头："></a>非简单请求请求头：</h3><ul>
<li>（1）Access-Control-Request-Method<br>  该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法</li>
<li>（2）Access-Control-Request-Headers<br>  该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段<br>  执行简单请求的时候，浏览器会在请求头信息增加<code>origin</code>字段，服务器据此来判断请求域名是否在许可范围之内，来决定是否返回<code>Access-Control-Allow-Origin</code>字段。响应头有以下几种：<ul>
<li>（1）Access-Control-Allow-Origin<br>  该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个*，表示接受任意域名的请求。</li>
<li>（2）Access-Control-Allow-Credentials<br>  该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在<code>CORS</code>请求之中。设为<code>true</code>，即表示服务器明确许可，<code>Cookie</code>可以包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。</li>
<li>（3）Access-Control-Expose-Headers<br>  该字段可选。<code>CORS</code>请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</li>
<li>(4) Access-Control-Max-Age<br> <code>Access-Control-Max-Age</code> 首部字段指明了预检请求的响应的有效时间。</li>
<li>(5) Access-Control-Allow-Methods<br> <code>Access-Control-Allow-Methods</code> 首部字段用于预检请求的响应。其指明了实际请求所允许使用的 HTTP 方法。</li>
<li>(6) Access-Control-Allow-Headers<br> <code>Access-Control-Allow-Headers</code>首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段。<br>其他方法：<code>document.domin</code>,<code>html5</code>的<code>postMessage</code>,<code>window.name</code>等</li>
</ul>
</li>
</ul>
<h2 id="函数节流和函数防抖"><a href="#函数节流和函数防抖" class="headerlink" title="函数节流和函数防抖"></a>函数节流和函数防抖</h2><p>函数节流让指函数有规律的进行调用，应用场景：window.resize，游戏中子弹发射(1s只能发射一颗子弹)等；<br>函数防抖让函数在”调用’’之后的一段时间后生效，应用场景:输入框(例：在用户停止输入的500ms后再处理用户数据)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//函数节流</span></div><div class="line"><span class="comment">/*</span></div><div class="line">* @params &#123;Function&#125; fun 调用函数</div><div class="line">* @params &#123;delay&#125; number 延迟时间</div><div class="line">*/</div><div class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fun, delay, ...rest</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> last = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        <span class="keyword">const</span> now = + <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">        <span class="keyword">if</span> (now - last &gt; delay) &#123;</div><div class="line">            fun(rest);</div><div class="line">            last = now;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//实例</span></div><div class="line"><span class="keyword">const</span> throttleExample  = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>), <span class="number">1000</span>);</div><div class="line"><span class="comment">//调用</span></div><div class="line">throttleExample();</div><div class="line">throttleExample();</div><div class="line">throttleExample();</div><div class="line"><span class="comment">//函数防抖</span></div><div class="line"><span class="keyword">const</span> debouce = <span class="function">(<span class="params">fun, delay, ...rest</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">        clearTimeout(timer);</div><div class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            fun(rest);</div><div class="line">        &#125;, delay);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//实例</span></div><div class="line"><span class="keyword">const</span> debouceExample = debouce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>), <span class="number">1000</span>);</div><div class="line"><span class="comment">//调用</span></div><div class="line">debouceExample();</div><div class="line">debouceExample();</div><div class="line">debouceExample();</div></pre></td></tr></table></figure></p>
<h2 id="AMD和CMD的区别"><a href="#AMD和CMD的区别" class="headerlink" title="AMD和CMD的区别"></a>AMD和CMD的区别</h2><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<br>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>
<ul>
<li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。</li>
<li>CMD 推崇依赖就近，AMD 推崇依赖前置。</li>
<li>AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</li>
</ul>
<h2 id="JavaScript内存泄露的原因以及如何去手动释放内存"><a href="#JavaScript内存泄露的原因以及如何去手动释放内存" class="headerlink" title="JavaScript内存泄露的原因以及如何去手动释放内存"></a>JavaScript内存泄露的原因以及如何去手动释放内存</h2><h3 id="易出现泄露的场景"><a href="#易出现泄露的场景" class="headerlink" title="易出现泄露的场景"></a>易出现泄露的场景</h3><ul>
<li>XMLHttpRequest 泄漏发生在IE7-8,释放方法，将XMLHttpRequest实例对象设置为Null；</li>
<li>DOM&amp;BOM等COM对象循环绑定 泄漏发生在IE6-8，释放方法，切断循环引用，将对对象的应用设置为Null；</li>
<li>定时器(严格上说不能算是泄露，是被闭包持有了，是正常的表现)，对于闭包中无用的变量可以使用delete操作符进行释放；</li>
</ul>
<h3 id="JavaScript垃圾回收机制"><a href="#JavaScript垃圾回收机制" class="headerlink" title="JavaScript垃圾回收机制"></a>JavaScript垃圾回收机制</h3><ul>
<li>引用计数<br>  此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。<br>  限制：无法处理循环引用。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</li>
<li>标记清除<br>  当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。<br>垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。</li>
</ul>
<h2 id="柯里化函数"><a href="#柯里化函数" class="headerlink" title="柯里化函数"></a>柯里化函数</h2><p>所谓的柯里化函数简单的说就是将本来接受多个参数的函数变为只接受一个参数的函数。柯里化函数的模板和实例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> currying = <span class="function"><span class="keyword">function</span>(<span class="params">fun</span>) </span>&#123;</div><div class="line">  	<span class="comment">//格式化arguments</span></div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">  	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      	<span class="comment">//收集所有的参数在同一个数组中，进行计算</span></div><div class="line">      	<span class="keyword">var</span> _args = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</div><div class="line">      	<span class="keyword">return</span> fun.apply(<span class="literal">null</span>, _args);</div><div class="line">  	&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> add = currying(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</div><div class="line">  	<span class="keyword">return</span> args.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> a + b;</div><div class="line">    &#125;);</div><div class="line">&#125;)</div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 经典面试题</div><div class="line"> * 函数参数不定回调函数数目不定</div><div class="line"> * 编写函数实现:</div><div class="line"> * add(1,2,3,4,5)==15</div><div class="line"> * add(1,2)(3,4)(5)==15</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 第一次执行时，定义一个数组专门用来存储所有的参数</span></div><div class="line">    <span class="keyword">var</span> _args = [].slice.call(<span class="built_in">arguments</span>);</div><div class="line">    <span class="comment">// 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值</span></div><div class="line">    <span class="keyword">var</span> adder = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> _adder = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            [].push.apply(_args, [].slice.call(<span class="built_in">arguments</span>));</div><div class="line">            <span class="keyword">return</span> _adder;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">// 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回</span></div><div class="line">        _adder.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> _args.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> a + b;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> _adder;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> adder.apply(<span class="literal">null</span>, _args);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出结果，可自由组合的参数</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));  <span class="comment">// 15</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// 15</span></div><div class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>));  <span class="comment">// 15</span></div></pre></td></tr></table></figure></p>
<h2 id="Less常用特性"><a href="#Less常用特性" class="headerlink" title="Less常用特性"></a>Less常用特性</h2><ul>
<li>变量(@color = #fff)</li>
<li>混合(Mixin)</li>
<li>内置函数(颜色，字符串，类型判断，数学)</li>
<li>循环</li>
<li>嵌套</li>
<li>运算</li>
<li>导入(@import)</li>
</ul>
<h2 id="ES6常用特性"><a href="#ES6常用特性" class="headerlink" title="ES6常用特性"></a>ES6常用特性</h2><ul>
<li>变量定义(let和const,可变与不可变，const定义对象的特殊情况)</li>
<li>解构赋值</li>
<li>模板字符串</li>
<li>数组新API(例：Array.from(),entries(),values(),keys())</li>
<li>箭头函数(rest参数，扩展运算符，::绑定this)</li>
<li>Set和Map数据结构(set实例成员值唯一存储key值，map实例存储键值对(key-value))</li>
<li>Promise对象(前端异步解决方案进化史，generator函数，async函数)</li>
<li>Class语法糖(super关键字)</li>
</ul>
<h2 id="react中setState的原理"><a href="#react中setState的原理" class="headerlink" title="react中setState的原理"></a>react中setState的原理</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目:"></a>题目:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">value</span>: <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">      <span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>: <span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;);</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value);</div><div class="line">	&#125;, <span class="number">0</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//答案: 0、0、0、2、3；</span></div></pre></td></tr></table></figure>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>当<code>setState</code>方法调用的时候<code>React</code>就会重新调用<code>render</code>方法来重新渲染组件；<code>setState</code>通过一个队列来更新<code>state</code>,当调用<code>setState</code>方法的时候会将需要更新的<code>state</code>放入这个状态队列中，这个队列会高效的批量更新<code>state</code>;<br><img src="/images/page/qianduanjinjie/1.svg" alt=""></p>
<p>源码地址:<a href="https://github.com/facebook/react/blob/35962a00084382b49d1f9e3bd36612925f360e5b/src/renderers/shared/reconciler/ReactUpdates.js" target="_blank" rel="external">enqueueUpdate</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</div><div class="line">  ensureInjected();</div><div class="line">  <span class="comment">//判断是否处于批量更新模式</span></div><div class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</div><div class="line">    <span class="comment">//关键！下面的代码片段是这个方法的源码</span></div><div class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果处于批量更新模式，则将这个组件保存在dirtyComponents</span></div><div class="line">  dirtyComponents.push(component);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>源码地址:<a href="https://github.com/facebook/react/blob/35962a00084382b49d1f9e3bd36612925f360e5b/src/renderers/shared/reconciler/ReactDefaultBatchingStrategy.js" target="_blank" rel="external">ReactDefaultBatchingStrategy</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//batchingStrategy对象</span></div><div class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</div><div class="line">  <span class="comment">//注意默认为false</span></div><div class="line">  isBatchingUpdates: <span class="literal">false</span>,</div><div class="line">  <span class="attr">batchedUpdates</span>: <span class="function"><span class="keyword">function</span>(<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</div><div class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</div><div class="line">      callback(a, b, c, d, e);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//关键！！！事务的理解</span></div><div class="line">      transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e);</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>源码地址：<a href="https://github.com/facebook/react/blob/401e6f10587b09d4e725763984957cf309dfdc30/src/shared/utils/Transaction.js" target="_blank" rel="external">Transaction</a><br><img src="/images/page/qianduanjinjie/2.png" alt=""></p>
<p>如图：事务会将所需要执行的方法(图中的<code>anyMethod</code>)使用<code>wrapper</code>封装起来，再通过<code>perform</code>方法执行该方法，但在<code>perform</code>执行之前会先执行所有<code>wrapper</code>中的<code>initialize</code>方法，<code>perform</code>方法执行结束后，再执行所有的<code>close</code>方法；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Transaction = <span class="built_in">require</span>(<span class="string">'./Transaction'</span>);</div><div class="line"><span class="comment">// 我们自己定义的</span></div><div class="line"><span class="keyword">var</span> MyTransaction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">  <span class="comment">//do something</span></div><div class="line">&#125;;</div><div class="line"><span class="built_in">Object</span>.assign(MyTransaction.prototype, Transaction.Mixin, &#123;</div><div class="line">  	<span class="comment">//需要自定义一个getTransactionWrappers对象，获取所有需要封装的initialize方法和close方法</span></div><div class="line">  	getTransactionWrappers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    </div><div class="line">  		<span class="keyword">return</span> [&#123;      </div><div class="line">          	<span class="attr">initialize</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'before method perform'</span>);      </div><div class="line">            &#125;,      </div><div class="line">          	<span class="attr">close</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;        </div><div class="line">              <span class="built_in">console</span>.log(<span class="string">'after method perform'</span>);      </div><div class="line">            &#125;    </div><div class="line">        &#125;];  </div><div class="line">	&#125;;</div><div class="line">&#125;);</div><div class="line"><span class="comment">//实例化一个transaction</span></div><div class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> MyTransaction();</div><div class="line"><span class="comment">//需要调用的方法</span></div><div class="line"><span class="keyword">var</span> testMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</div><div class="line">&#125;</div><div class="line">transaction.perform(testMethod);</div><div class="line"><span class="comment">//before method perform</span></div><div class="line"><span class="comment">//test</span></div><div class="line"><span class="comment">//after method perform</span></div></pre></td></tr></table></figure></p>
<p>理解题目的关键是，整个组件渲染到DOM中的过程就已经处于一次大的事务中了，因此在<code>componentDidMount</code>方法中调用<code>setState</code>的时候<code>ReactDefaultBatchingStrategy.isBatchingUpdates = true</code>;这句代码已经执行过了，所以<code>setState</code>的结果并没有立即生效，而是扔进了<code>dirtyComponent</code>;因此执行三次<code>setState</code>的结果<code>this.state.value</code>的值依然是0,而<code>setTimeout</code>中的两次<code>setState</code>由于没有调用过<code>batchedUpdates</code>方法(<code>isBatchingUpdates</code>默认为<code>false</code>)，所以<code>setState</code>方法立即生效，第二次<code>setSState</code>同理</p>
<h2 id="XSS与CSRF介绍"><a href="#XSS与CSRF介绍" class="headerlink" title="XSS与CSRF介绍"></a>XSS与CSRF介绍</h2><p>XSS是一种跨站脚本攻击，是属于代码注入的一种，攻击者通过将代码注入网页中，其他用户看到会受到影响(代码内容有请求外部服务器);<br>CSRF是一种跨站请求伪造，冒充用户发起请求，完成一些违背用户请求的行为(删帖，改密码，发邮件，发帖等)<br>防御方法举例:<br>    对一些关键字和特殊字符进行过滤(&lt;&gt;,?,script等)，或对用户输入内容进行URL编码(encodeURIComponent);<br>    Cookie不要存放用户名和密码，对cookie信息进行MD5等算法散列存放，必要时可以将IP和cookie绑定;</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近一直忙于项目和业务，略疲惫，好在还是利用空闲学习了不少的东西，自勉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;React和Vue对比&quot;&gt;&lt;a href=&quot;#React和Vue对比&quot; class=&quot;headerlink&quot; title=&quot;React和Vue对比&quot;&gt;&lt;/a&gt;React和Vue对比&lt;/h2&gt;&lt;p&gt;相同点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据驱动视图，提供响应式的视图组件&lt;/li&gt;
&lt;li&gt;都有Virtual DOM，组件化开发，通过props参数进行父子组件数据的传递，都实现webComponents规范&lt;/li&gt;
&lt;li&gt;数据流动单向&lt;/li&gt;
&lt;li&gt;都支持服务端渲染&lt;/li&gt;
&lt;li&gt;都有支持native的方案，React的&lt;code&gt;React native&lt;/code&gt;，Vue的&lt;code&gt;weex&lt;/code&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://html-js.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习-字符串的扩展</title>
    <link href="http://html-js.site/2017/04/12/ES6%E5%AD%A6%E4%B9%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://html-js.site/2017/04/12/ES6学习-字符串的扩展/</id>
    <published>2017-04-12T07:02:34.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。</p>
<h3 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h3><p>JavaScript 允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;\u0061&quot;</div><div class="line">// &quot;a&quot;</div></pre></td></tr></table></figure></p>
<p>但是，这种表示法只限于码点在<code>\u0000</code>~<code>\uFFFF</code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;\uD842\uDFB7&quot;</div><div class="line">// &quot;𠮷&quot;</div><div class="line"></div><div class="line">&quot;\u20BB7&quot;</div><div class="line">// &quot; 7&quot;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>上面代码表示，如果直接在<code>\u</code>后面跟上超过<code>0xFFFF</code>的数值（比如<code>\u20BB7</code>），JavaScript会理解成<code>\u20BB+7</code>。由于<code>\u20BB</code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;\u&#123;20BB7&#125;&quot;</div><div class="line">// &quot;𠮷&quot;</div><div class="line"></div><div class="line">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</div><div class="line">// &quot;ABC&quot;</div><div class="line"></div><div class="line">let hello = 123;</div><div class="line">hell\u&#123;6F&#125; // 123</div><div class="line"></div><div class="line">&apos;\u&#123;1F680&#125;&apos; === &apos;\uD83D\uDE80&apos;</div><div class="line">// true</div></pre></td></tr></table></figure></p>
<p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>
<p>有了这种表示法之后，JavaScript 共有6种方法可以表示一个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;\z&apos; === &apos;z&apos;  // true</div><div class="line">&apos;\172&apos; === &apos;z&apos; // true</div><div class="line">&apos;\x7A&apos; === &apos;z&apos; // true</div><div class="line">&apos;\u007A&apos; === &apos;z&apos; // true</div><div class="line">&apos;\u&#123;7A&#125;&apos; === &apos;z&apos; // true</div></pre></td></tr></table></figure></p>
<h3 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h3><p>JavaScript内部，字符以UTF-16的格式储存，每个字符固定为<code>2</code>个字节。对于那些需要<code>4</code>个字节储存的字符（Unicode码点大于<code>0xFFFF</code>的字符），JavaScript会认为它们是两个字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var s = &quot;𠮷&quot;;</div><div class="line"></div><div class="line">s.length // 2</div><div class="line">s.charAt(0) // &apos;&apos;</div><div class="line">s.charAt(1) // &apos;&apos;</div><div class="line">s.charCodeAt(0) // 55362</div><div class="line">s.charCodeAt(1) // 57271</div></pre></td></tr></table></figure></p>
<p>上面代码中，汉字“𠮷”（注意，这个字不是”吉祥“的”吉“）的码点是<code>0x20BB7</code>，UTF-16编码为<code>0xD842 0xDFB7</code>（十进制为<code>55362 57271</code>），需要4个字节储存。对于这种<code>4</code>个字节的字符，JavaScript不能正确处理，字符串长度会误判为<code>2</code>，而且<code>charAt</code>方法无法读取整个字符，<code>charCodeAt</code>方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6提供了<code>codePointAt</code>方法，能够正确处理<code>4</code>个字节储存的字符，返回一个字符的码点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷a&apos;;</div><div class="line"></div><div class="line">s.codePointAt(0) // 134071</div><div class="line">s.codePointAt(1) // 57271</div><div class="line"></div><div class="line">s.codePointAt(2) // 97</div></pre></td></tr></table></figure></p>
<p><code>codePointAt</code>方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，<code>codePointAt</code>方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点<code>134071</code>（即十六进制的<code>20BB7</code>）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，<code>codePointAt</code>方法的结果与<code>charCodeAt</code>方法相同。</p>
<p>总之，<code>codePointAt</code>方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与<code>charCodeAt</code>方法相同。</p>
<p><code>codePointAt</code>方法返回的是码点的十进制值，如果想要十六进制的值，可以使用<code>toString</code>方法转换一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷a&apos;;</div><div class="line"></div><div class="line">s.codePointAt(0).toString(16) // &quot;20bb7&quot;</div><div class="line">s.codePointAt(2).toString(16) // &quot;61&quot;</div></pre></td></tr></table></figure></p>
<p>你可能注意到了，<code>codePointAt</code>方法的参数，仍然是不正确的。比如，上面代码中，字符<code>a</code>在字符串<code>s</code>的正确位置序号应该是1，但是必须向<code>codePointAt</code>方法传入2。解决这个问题的一个办法是使用<code>for...of</code>循环，因为它会正确识别32位的UTF-16字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var s = &apos;𠮷a&apos;;</div><div class="line">for (let ch of s) &#123;</div><div class="line">  console.log(ch.codePointAt(0).toString(16));</div><div class="line">&#125;</div><div class="line">// 20bb7</div><div class="line">// 61</div></pre></td></tr></table></figure></p>
<p><code>codePointAt</code>方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function is32Bit(c) &#123;</div><div class="line">  return c.codePointAt(0) &gt; 0xFFFF;</div><div class="line">&#125;</div><div class="line"></div><div class="line">is32Bit(&quot;𠮷&quot;) // true</div><div class="line">is32Bit(&quot;a&quot;) // false</div></pre></td></tr></table></figure></p>
<h3 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h3><p>ES5提供<code>String.fromCharCode</code>方法，用于从码点返回对应字符，但是这个方法不能识别<code>32</code>位的<code>UTF-16</code>字符（Unicode编号大于<code>0xFFFF</code>）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String.fromCharCode(0x20BB7)</div><div class="line">// &quot;ஷ&quot;</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>String.fromCharCode</code>不能识别大于0xFFFF的码点，所以<code>0x20BB7</code>就发生了溢出，最高位<code>2</code>被舍弃了，最后返回码点<code>U+0BB7</code>对应的字符，而不是码点<code>U+20BB7</code>对应的字符。</p>
<p>ES6提供了<code>String.fromCodePoint</code>方法，可以识别<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode</code>方法的不足。在作用上，正好与<code>codePointAt</code>方法相反。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String.fromCodePoint(0x20BB7)</div><div class="line">// &quot;𠮷&quot;</div><div class="line">String.fromCodePoint(0x78, 0x1f680, 0x79) === &apos;x\uD83D\uDE80y&apos;</div><div class="line">// true</div></pre></td></tr></table></figure></p>
<p>上面代码中，如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，<code>fromCodePoint</code>方法定义在String对象上，而<code>codePointAt</code>方法定义在字符串的实例对象上。</p>
<h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被<code>for...of</code>循环遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for (let codePoint of &apos;foo&apos;) &#123;</div><div class="line">  console.log(codePoint)</div><div class="line">&#125;</div><div class="line">// &quot;f&quot;</div><div class="line">// &quot;o&quot;</div><div class="line">// &quot;o&quot;</div></pre></td></tr></table></figure></p>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于<code>0xFFFF</code>的码点，传统的<code>for</code>循环无法识别这样的码点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> text = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; text.length; i++) &#123;</div><div class="line">  <span class="built_in">console</span>.log(text[i]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// " "</span></div><div class="line"><span class="comment">// " "</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> text) &#123;</div><div class="line">  <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// "𠮷"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，字符串<code>text</code>只有一个字符，但是<code>for</code>循环会认为它包含两个字符（都不可打印），而<code>for...of</code>循环会正确识别出这一个字符。</p>
<h3 id="at"><a href="#at" class="headerlink" title="at()"></a>at()</h3><p>ES5对字符串对象提供<code>charAt</code>方法，返回字符串给定位置的字符。该方法不能识别码点大于<code>0xFFFF</code>的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;abc&apos;.charAt(0) // &quot;a&quot;</div><div class="line">&apos;𠮷&apos;.charAt(0) // &quot;\uD842&quot;</div></pre></td></tr></table></figure></p>
<p>上面代码中，charAt方法返回的是UTF-16编码的第一个字节，实际上是无法显示的。</p>
<p>目前，有一个提案，提出字符串实例的<code>at</code>方法，可以识别Unicode编号大于<code>0xFFFF</code>的字符，返回正确的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&apos;abc&apos;.at(0) // &quot;a&quot;</div><div class="line">&apos;𠮷&apos;.at(0) // &quot;𠮷&quot;</div></pre></td></tr></table></figure></p>
<h3 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h3><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> <span class="comment">//false</span></div><div class="line"></div><div class="line"><span class="string">'\u01D1'</span>.length <span class="comment">// 1</span></div><div class="line"><span class="string">'\u004F\u030C'</span>.length <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>上面代码表示，JavaScript将合成字符视为两个字符，导致两种表示方法不相等。</p>
<p>ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize()</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p><code>normalize</code>方法可以接受一个参数来指定<code>normalize</code>的方式，参数的四个可选值如下。</p>
<pre><code>- `NFC`，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。
- `NFD`，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
- `NFKC`，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）
- `NFKD`，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length <span class="comment">// 1</span></div><div class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<p>上面代码表示，<code>NFC</code>参数返回字符的合成形式，<code>NFD</code>参数返回字符的分解形式。</p>
<p>不过，<code>normalize</code>方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过<code>Unicode</code>编号区间判断。</p>
<h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><p>传统上，JavaScript只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<pre><code>- **includes()：**返回布尔值，表示是否找到了参数字符串。
- **startsWith()：**返回布尔值，表示参数字符串是否在源字符串的头部。
- **endsWith()：**返回布尔值，表示参数字符串是否在源字符串的尾部。
</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</div><div class="line"></div><div class="line">s.startsWith(<span class="string">'Hello'</span>) <span class="comment">// true</span></div><div class="line">s.endsWith(<span class="string">'!'</span>) <span class="comment">// true</span></div><div class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</div><div class="line"></div><div class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></div><div class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></div><div class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p><code>repeat</code>方法返回一个新字符串，表示将原字符串重复<code>n</code>次。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></div><div class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>参数如果是小数，会被取整。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="number">2.9</span>) <span class="comment">// "nana"</span></div></pre></td></tr></table></figure></p>
<p>如果<code>repeat</code>的参数是负数或者<code>Infinity</code>，会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="literal">Infinity</span>)</div><div class="line"><span class="comment">// RangeError</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="number">-1</span>)</div><div class="line"><span class="comment">// RangeError</span></div></pre></td></tr></table></figure></p>
<p>但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于<code>-0</code>，<code>repeat</code>视同为0。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="number">-0.9</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>参数<code>NaN</code>等同于0。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="literal">NaN</span>) <span class="comment">// ""</span></div></pre></td></tr></table></figure></p>
<p>如果<code>repeat</code>的参数是字符串，则会先转换成数字。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="comment">// ""</span></div><div class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="comment">// "nanana"</span></div></pre></td></tr></table></figure></p>
<h3 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h3><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></div><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></div><div class="line"></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>padStart</code>和<code>padEnd</code>一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></div><div class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="comment">// 'xxx'</span></div></pre></td></tr></table></figure></p>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)</div><div class="line"><span class="comment">// '0123456abc'</span></div></pre></td></tr></table></figure></p>
<p>如果省略第二个参数，默认使用空格补全长度。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="comment">// '   x'</span></div><div class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="comment">// 'x   '</span></div></pre></td></tr></table></figure></p>
<p><code>padStart</code>的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000001"</span></div><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000000012"</span></div><div class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="comment">// "0000123456"</span></div></pre></td></tr></table></figure></p>
<p>另一个用途是提示字符串格式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-MM-12"</span></div><div class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="comment">// "YYYY-09-12"</span></div></pre></td></tr></table></figure></p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>传统的JavaScript语言，输出模板通常是这样写的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(</div><div class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</div><div class="line">  <span class="string">'items in your basket, '</span> +</div><div class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</div><div class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></div><div class="line">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</div><div class="line">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</div><div class="line">  are on sale!</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 普通字符串</span></div><div class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></div><div class="line"></div><div class="line"><span class="comment">// 多行字符串</span></div><div class="line"><span class="string">`In JavaScript this is</span></div><div class="line"> not legal.`</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span></div><div class="line">string text line 2`);</div><div class="line"></div><div class="line"><span class="comment">// 字符串中嵌入变量</span></div><div class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</div><div class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></div></pre></td></tr></table></figure></p>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> greeting = <span class="string">`\`Yo\` World!`</span>;</div></pre></td></tr></table></figure></p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;first&lt;/li&gt;</div><div class="line">  &lt;li&gt;second&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`);</div></pre></td></tr></table></figure></p>
<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<code>&lt;ul&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用<code>trim</code>方法消除它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'#list'</span>).html(<span class="string">`</span></div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li&gt;first&lt;/li&gt;</div><div class="line">  &lt;li&gt;second&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`.trim());</div></pre></td></tr></table></figure></p>
<p>模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</div><div class="line">      <span class="comment">// 传统写法为</span></div><div class="line">      <span class="comment">// 'User '</span></div><div class="line">      <span class="comment">// + user.name</span></div><div class="line">      <span class="comment">// + ' is not authorized to do '</span></div><div class="line">      <span class="comment">// + action</span></div><div class="line">      <span class="comment">// + '.'</span></div><div class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></div><div class="line"><span class="comment">// "1 + 2 = 3"</span></div><div class="line"></div><div class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></div><div class="line"><span class="comment">// "1 + 4 = 5"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>模板字符串之中还能调用函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></div><div class="line"><span class="comment">// foo Hello World bar</span></div></pre></td></tr></table></figure></p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的<code>toString</code>方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 变量place没有声明</span></div><div class="line"><span class="keyword">var</span> msg = <span class="string">`Hello, <span class="subst">$&#123;place&#125;</span>`</span>;</div><div class="line"><span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
<p>由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">`Hello <span class="subst">$&#123;<span class="string">'World'</span>&#125;</span>`</span></div><div class="line"><span class="comment">// "Hello World"</span></div></pre></td></tr></table></figure></p>
<p>模板字符串甚至还能嵌套。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> tmpl = <span class="function"><span class="params">addrs</span> =&gt;</span> <span class="string">`</span></div><div class="line">  &lt;table&gt;</div><div class="line">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></div><div class="line">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class="line">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</div><div class="line">  `).join(<span class="string">''</span>)&#125;</div><div class="line">  &lt;/table&gt;</div><div class="line">`;</div></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> data = [</div><div class="line">    &#123; <span class="attr">first</span>: <span class="string">'&lt;Jane&gt;'</span>, <span class="attr">last</span>: <span class="string">'Bond'</span> &#125;,</div><div class="line">    &#123; <span class="attr">first</span>: <span class="string">'Lars'</span>, <span class="attr">last</span>: <span class="string">'&lt;Croft&gt;'</span> &#125;,</div><div class="line">];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(tmpl(data));</div><div class="line"><span class="comment">// &lt;table&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// &lt;/table&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div><div class="line"></div><div class="line"><span class="comment">// 写法二</span></div><div class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</div><div class="line"><span class="keyword">let</span> func = <span class="built_in">eval</span>.call(<span class="literal">null</span>, str);</div><div class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></div></pre></td></tr></table></figure></p>
<h3 id="实例：模板编译"><a href="#实例：模板编译" class="headerlink" title="实例：模板编译"></a>实例：模板编译</h3><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> template = <span class="string">`</span></div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt;</div><div class="line">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</div><div class="line">  &lt;% &#125; %&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">`;</div></pre></td></tr></table></figure></p>
<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置JavaScript代码，使用<code>&lt;%= ... %&gt;</code>输出JavaScript表达式。</p>
<p>怎么编译这个模板字符串呢？</p>
<p>一种思路是将其转换为JavaScript表达式字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">echo(<span class="string">'&lt;ul&gt;'</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; data.supplies.length; i++) &#123;</div><div class="line">  echo(<span class="string">'&lt;li&gt;'</span>);</div><div class="line">  echo(data.supplies[i]);</div><div class="line">  echo(<span class="string">'&lt;/li&gt;'</span>);</div><div class="line">&#125;;</div><div class="line">echo(<span class="string">'&lt;/ul&gt;'</span>);</div></pre></td></tr></table></figure></p>
<p>这个转换使用正则表达式就行了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</div><div class="line"><span class="keyword">var</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</div><div class="line"></div><div class="line">template = template</div><div class="line">  .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</div><div class="line">  .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</div><div class="line"></div><div class="line">template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</div></pre></td></tr></table></figure></p>
<p>然后，将<code>template</code>封装在一个函数里面返回，就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> script =</div><div class="line"><span class="string">`(function parse(data)&#123;</span></div><div class="line">  var output = "";</div><div class="line"></div><div class="line">  function echo(html)&#123;</div><div class="line">    output += html;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="subst">$&#123; template &#125;</span></div><div class="line"></div><div class="line">  return output;</div><div class="line">&#125;)`;</div><div class="line"></div><div class="line"><span class="keyword">return</span> script;</div></pre></td></tr></table></figure></p>
<p>将上面的内容拼装成一个模板编译函数<code>compile</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</div><div class="line">  <span class="keyword">var</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</div><div class="line"></div><div class="line">  template = template</div><div class="line">    .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</div><div class="line">    .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</div><div class="line"></div><div class="line">  template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> script =</div><div class="line">  <span class="string">`(function parse(data)&#123;</span></div><div class="line">    var output = "";</div><div class="line"></div><div class="line">    function echo(html)&#123;</div><div class="line">      output += html;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="subst">$&#123; template &#125;</span></div><div class="line"></div><div class="line">    return output;</div><div class="line">  &#125;)`;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> script;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>compile</code>函数的用法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> parse = <span class="built_in">eval</span>(compile(template));</div><div class="line">div.innerHTML = parse(&#123; <span class="attr">supplies</span>: [ <span class="string">"broom"</span>, <span class="string">"mop"</span>, <span class="string">"cleaner"</span> ] &#125;);</div><div class="line"><span class="comment">//   &lt;ul&gt;</span></div><div class="line"><span class="comment">//     &lt;li&gt;broom&lt;/li&gt;</span></div><div class="line"><span class="comment">//     &lt;li&gt;mop&lt;/li&gt;</span></div><div class="line"><span class="comment">//     &lt;li&gt;cleaner&lt;/li&gt;</span></div><div class="line"><span class="comment">//   &lt;/ul&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert<span class="string">`123`</span></div><div class="line"><span class="comment">// 等同于</span></div><div class="line">alert(<span class="number">123</span>)</div></pre></td></tr></table></figure></p>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</div><div class="line"><span class="comment">// 等同于</span></div><div class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串前面有一个标识名<code>tag</code>，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p>
<p>函数<code>tag</code>依次会接收到多个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>tag</code>函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p><code>tag</code>函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p>
<p><code>tag</code>函数所有参数的实际值如下。</p>
<pre><code>- 第一个参数：`[&apos;Hello &apos;, &apos; world &apos;, &apos;&apos;]`
- 第二个参数: 15
- 第三个参数：50
</code></pre><p>也就是说，<code>tag</code>函数实际上以下面的形式调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>)</div></pre></td></tr></table></figure></p>
<p>我们可以按照需要编写<code>tag</code>函数的代码。下面是<code>tag</code>函数的一种写法，以及运行结果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</div><div class="line">  <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</div><div class="line">  <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</div><div class="line">  <span class="built_in">console</span>.log(v1);</div><div class="line">  <span class="built_in">console</span>.log(v2);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="string">"OK"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</div><div class="line"><span class="comment">// "Hello "</span></div><div class="line"><span class="comment">// " world "</span></div><div class="line"><span class="comment">// ""</span></div><div class="line"><span class="comment">// 15</span></div><div class="line"><span class="comment">// 50</span></div><div class="line"><span class="comment">// "OK"</span></div></pre></td></tr></table></figure></p>
<p>下面是一个更复杂的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = <span class="number">30</span>;</div><div class="line"><span class="keyword">var</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</div><div class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</div><div class="line">    result += literals[i++];</div><div class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</div><div class="line">      result += <span class="built_in">arguments</span>[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">msg <span class="comment">// "The total is 30 (31.5 with tax)"</span></div></pre></td></tr></table></figure></p>
<p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p>
<p><code>passthru</code>函数采用rest参数的写法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals, ...values</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> output = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</div><div class="line">    output += literals[index] + values[index];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  output += literals[index]</div><div class="line">  <span class="keyword">return</span> output;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> message =</div><div class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">    <span class="keyword">var</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</div><div class="line"></div><div class="line">    <span class="comment">// Escape special characters in the substitution.</span></div><div class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</div><div class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</div><div class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Don't escape special characters in the template.</span></div><div class="line">    s += templateData[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sender = <span class="string">'&lt;script&gt;alert("abc")&lt;/script&gt;'</span>; <span class="comment">// 恶意代码</span></div><div class="line"><span class="keyword">var</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</div><div class="line"></div><div class="line">message</div><div class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></div></pre></td></tr></table></figure></p>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></div><div class="line"><span class="comment">// "欢迎访问xxx，您是第xxxx位访问者！"</span></div></pre></td></tr></table></figure></p>
<p>模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面的hashTemplate函数</span></div><div class="line"><span class="comment">// 是一个自定义的模板处理函数</span></div><div class="line"><span class="keyword">var</span> libraryHtml = hashTemplate<span class="string">`</span></div><div class="line">  &lt;ul&gt;</div><div class="line">    #for book in <span class="subst">$&#123;myBooks&#125;</span></div><div class="line">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</div><div class="line">    #end</div><div class="line">  &lt;/ul&gt;</div><div class="line">`;</div></pre></td></tr></table></figure></p>
<p>除此之外，你甚至可以使用标签模板，在JavaScript语言之中嵌入其他语言。<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">jsx<span class="string">`</span></div><div class="line">  &lt;div&gt;</div><div class="line">    &lt;input</div><div class="line">      ref='input'</div><div class="line">      onChange='<span class="subst">$&#123;<span class="keyword">this</span>.handleChange&#125;</span>'</div><div class="line">      defaultValue='<span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span>' /&gt;</div><div class="line">      <span class="subst">$&#123;<span class="keyword">this</span>.state.value&#125;</span></div><div class="line">   &lt;/div&gt;</div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>上面的代码通过<code>jsx</code>函数，将一个<code>DOM</code>字符串转为<code>React</code>对象。你可以在<code>Github</code>找到jsx函数的<a href="https://gist.github.com/lygaret/a68220defa69174bdec5" target="_blank" rel="external">具体实现</a>。</p>
<p>下面则是一个假想的例子，通过<code>java</code>函数，在JavaScript代码之中运行Java代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">java<span class="string">`</span></div><div class="line">class HelloWorldApp &#123;</div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    System.out.println(“Hello World!”); // Display the string.</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">`</div><div class="line">HelloWorldApp.main();</div></pre></td></tr></table></figure></p>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个<code>raw</code>属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log<span class="string">`123`</span></div><div class="line"><span class="comment">// ["123", raw: Array[1]]</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>console.log</code>接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。</p>
<p>请看下面的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tag<span class="string">`First line\nSecond line`</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</div><div class="line">  <span class="comment">// "First line\\nSecond line"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，tag函数的第一个参数<code>strings</code>，有一个<code>raw</code>属性，也指向一个数组。该数组的成员与<code>strings</code>数组完全一致。比如，<code>strings</code>数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么<code>strings.raw</code>数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，<code>strings.raw</code>数组会将<code>\n</code>视为<code>\\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>
<h3 id="String-raw"><a href="#String-raw" class="headerlink" title="String.raw()"></a>String.raw()</h3><p>ES6还为原生的<code>String</code>对象，提供了一个<code>raw</code>方法。</p>
<p><code>String.raw</code>方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</div><div class="line"><span class="comment">// "Hi\\n5!"</span></div><div class="line"></div><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</div><div class="line"><span class="comment">// 'Hi\\u000A!'</span></div></pre></td></tr></table></figure></p>
<p>如果原字符串的斜杠已经转义，那么<code>String.raw</code>不会做任何处理。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\\n`</span></div><div class="line"><span class="comment">// "Hi\\n"</span></div></pre></td></tr></table></figure></p>
<p><code>String.raw</code>的代码基本如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span> (<span class="params">strings, ...values</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> output = <span class="string">""</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</div><div class="line">    output += strings.raw[index] + values[index];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  output += strings.raw[index]</div><div class="line">  <span class="keyword">return</span> output;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>String.raw</code>方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p><code>String.raw</code>方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有<code>raw</code>属性的对象，且<code>raw</code>属性的值应该是一个数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// 't0e1s2t'</span></div><div class="line"></div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<h3 id="模板字符串的限制"><a href="#模板字符串的限制" class="headerlink" title="模板字符串的限制"></a>模板字符串的限制</h3><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。</p>
<p>举例来说，在标签模板里面可以嵌入Latex语言。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">strings</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="built_in">document</span> = latex<span class="string">`</span></div><div class="line">\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  // 正常工作</div><div class="line">\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错</div><div class="line">\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错</div><div class="line"></div><div class="line">Breve over the h goes \u&#123;h&#125;ere // 报错</div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>document</code>内嵌的模板字符串，对于<code>Latex</code>语言来说完全是合法的，但是<code>JavaScript</code>引擎会报错。原因就在于字符串的转义。</p>
<p>模板字符串会将<code>\u00FF</code>和<code>\u{42}</code>当作<code>Unicode</code>字符进行转义，所以<code>\unicode</code>解析时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。</p>
<p>为了解决这个问题，现在有一个提案，放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回<code>undefined</code>，而不是报错，并且从<code>raw</code>属性上面可以得到原始字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs</span>) </span>&#123;</div><div class="line">  strs[<span class="number">0</span>] === <span class="literal">undefined</span></div><div class="line">  strs.raw[<span class="number">0</span>] === <span class="string">"\\unicode and \\u&#123;55&#125;"</span>;</div><div class="line">&#125;</div><div class="line">tag<span class="string">`\unicode and \u&#123;55&#125;`</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript引擎将第一个字符设置为<code>undefined</code>，但是<code>raw</code>属性依然可以得到原始字符串，因此<code>tag</code>函数还是可以对原字符串进行处理。</p>
<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> bad = <span class="string">`bad escape sequence: \unicode`</span>; <span class="comment">// 报错</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。&lt;/p&gt;
&lt;h3 id=&quot;字符的-Unicode-表示法&quot;&gt;&lt;a href=&quot;#字符的-Unicode-表示法&quot; class=&quot;headerlink&quot; title=&quot;字符的 Unicode 表示法&quot;&gt;&lt;/a&gt;字符的 Unicode 表示法&lt;/h3&gt;&lt;p&gt;JavaScript 允许采用&lt;code&gt;\uxxxx&lt;/code&gt;形式表示一个字符，其中&lt;code&gt;xxxx&lt;/code&gt;表示字符的 Unicode 码点。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;\u0061&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// &amp;quot;a&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是，这种表示法只限于码点在&lt;code&gt;\u0000&lt;/code&gt;~&lt;code&gt;\uFFFF&lt;/code&gt;之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;\uD842\uDFB7&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// &amp;quot;𠮷&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;\u20BB7&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// &amp;quot; 7&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://html-js.site/tags/js/"/>
    
      <category term="es6" scheme="http://html-js.site/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>-webkit-overflow-scrolling:touch移动设备滚动回弹效果</title>
    <link href="http://html-js.site/2017/04/11/webkit-overflow-scrolling/"/>
    <id>http://html-js.site/2017/04/11/webkit-overflow-scrolling/</id>
    <published>2017-04-11T12:25:13.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>-webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果.</p>
<h3 id="值"><a href="#值" class="headerlink" title="值"></a>值</h3><ul>
<li>auto: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。</li>
<li>touch: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */</div><div class="line"></div><div class="line">-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;-webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果.&lt;/p&gt;
&lt;h3 id=&quot;值&quot;&gt;&lt;a h
    
    </summary>
    
    
      <category term="css" scheme="http://html-js.site/tags/css/"/>
    
      <category term="移动开发" scheme="http://html-js.site/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
      <category term="mobile" scheme="http://html-js.site/tags/mobile/"/>
    
  </entry>
  
  <entry>
    <title>cookie</title>
    <link href="http://html-js.site/2017/04/05/cookie/"/>
    <id>http://html-js.site/2017/04/05/cookie/</id>
    <published>2017-04-05T02:59:35.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>咱们不搞一开始就一大堆理论知识介绍，怕把人讲懵了…… 咱们换一个思维方式——“从现象看本质”，先说说我们看到了什么，再从看到的现象中提出问题，最后深入寻找答案。</p>
</blockquote>
<h2 id="我们看到的-cookie"><a href="#我们看到的-cookie" class="headerlink" title="我们看到的 cookie"></a>我们看到的 cookie</h2><p>在 chrome 浏览器中打开一个网站，进入开发者模式，点击<code>Resources</code>栏 -&gt; 选择<code>cookies</code>，我们会看到如下图所示的界面：<br><img src="/images/page/cookie/1.png" alt=""><br><a id="more"></a></p>
<p>解释一下：左边栏<code>Cookies</code>下方会列举当前网页中设置过<code>cookie</code>的域都有哪些。上图中只有一个域，即“ppsc.sankuai.com”。而右侧区域显示的就是某个域下具体的 <code>cookie</code> 列表，对应上图就是<code>roundtables.hz.taeapp.com</code>域下设置的7个<code>cookie</code>。</p>
<p>在这个网页中我发了一个 Ajax 请求，request header如下图所示：<br><img src="/images/page/cookie/2.png" alt=""></p>
<p>从上图中我们会看到<code>request header</code>中自动添加了<code>Cookie</code>字段（通过设置<code>withCredentials: true</code>），<code>Cookie</code>字段的值其实就是我设置的那4个 <code>cookie</code>。这个请求最终会发送到这个服务器上，这个服务器就能从接收到的<code>request header</code>中提取那4个<code>cookie。</code></p>
<p>上面两张图展示了<code>cookie</code>的基本通信流程：设置<code>cookie</code> =&gt; <code>cookie</code>被自动添加到<code>request header</code>中 =&gt; 服务端接收到<code>cookie</code>。这个流程中有几个问题需要好好研究：</p>
<ol>
<li>什么样的数据适合放在<code>cookie</code>中？</li>
<li><code>cookie</code>是怎么设置的？</li>
<li><code>cookie</code>怎么增删查改？</li>
</ol>
<p>我们要带着这几个问题继续往下阅读。</p>
<h2 id="cookie-是怎么工作的？"><a href="#cookie-是怎么工作的？" class="headerlink" title="cookie 是怎么工作的？"></a>cookie 是怎么工作的？</h2><p>首先必须明确一点，存储<code>cookie</code>是浏览器提供的功能。<code>cookie</code> 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 <code>cookie</code> 文件夹来存放各个域下设置的<code>cookie</code>。</p>
<p>当网页要发<code>http</code>请求时，浏览器会先检查是否有相应的<code>cookie</code>，有则自动添加在<code>request header</code>中的<code>cookie</code>字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在<code>cookie</code>中”。</p>
<p>存储在<code>cookie</code>中的数据，每次都会被浏览器自动放在<code>http</code>请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在<code>cookie</code>中，其他类型的数据就不适合了。</p>
<p>但在 <code>localStorage</code> 出现之前，<code>cookie</code>被滥用当做了存储工具。什么数据都放在<code>cookie</code>中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然<code>cookie</code>标准还是做了一些限制的：每个域名下的<code>cookie</code> 的大小最大为4KB，每个域名下的<code>cookie</code>数量最多为20个（但很多浏览器厂商在具体实现时支持大于20个）。</p>
<h2 id="cookie-的格式"><a href="#cookie-的格式" class="headerlink" title="cookie 的格式"></a>cookie 的格式</h2><h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p>JS 原生的 API提供了获取<code>cookie</code>的方法：<code>document.cookie</code>（注意，这个方法只能获取非 HttpOnly 类型的<code>cookie</code>）。在 console 中执行这段代码可以看到结果如下图：<br><img src="/images/page/cookie/3.png" alt=""></p>
<p>打印出的结果是一个字符串类型，因为<code>cookie</code>本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 <code>key=value</code>构成，键值对之间由一个<code>分号</code>和一个<code>空格</code>隔开。</p>
<h3 id="cookie-的属性选项"><a href="#cookie-的属性选项" class="headerlink" title="cookie 的属性选项"></a>cookie 的属性选项</h3><p>每个<code>cookie</code>都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过<code>cookie</code>选项来设置的，<code>cookie</code>选项包括：<code>expires</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>HttpOnly</code>。在设置任一个<code>cookie</code>时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个分号和一个空格隔开。代码示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly&quot;</div></pre></td></tr></table></figure></p>
<h3 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h3><p><code>expires</code>选项用来设置“<code>cookie</code> 什么时间内有效”。<code>expires</code>其实是<code>cookie</code>失效日期，<code>expires</code>必须是 <code>GMT</code> 格式的时间（可以通过 <code>new Date().toGMTString()</code>或者 <code>new Date().toUTCString()</code> 来获得）。</p>
<p>如<code>expires=Thu, 25 Feb 2016 04:18:00 GMT</code>表示<code>cookie</code>讲在2016年2月25日4:18分之后失效，对于失效的<code>cookie</code>浏览器会清空。如果没有设置该选项，则默认有效期为<code>session</code>，即会话<code>cookie</code>。这种<code>cookie</code>在浏览器关闭后就没有了。</p>
<blockquote>
<p><code>expires</code> 是 http/1.0协议中的选项，在新的http/1.1协议中<code>expires</code>已经由 <code>max-age</code> 选项代替，两者的作用都是限制<code>cookie</code> 的有效时间。<code>expires</code>的值是一个时间点（<code>cookie失效时刻= expires</code>），而<code>max-age</code> 的值是一个以秒为单位时间段（<code>cookie失效时刻= 创建时刻+ max-age</code>）。</p>
</blockquote>
<h3 id="domain-和-path"><a href="#domain-和-path" class="headerlink" title="domain 和 path"></a>domain 和 path</h3><p><code>domain</code>是域名，<code>path</code>是路径，两者加起来就构成了 <code>URL</code>，<code>domain</code>和<code>path</code>一起来限制 <code>cookie</code> 能被哪些 <code>URL</code> 访问。</p>
<p>一句话概括：某<code>cookie</code>的 <code>domain</code>为<code>baidu.com</code>, <code>path</code>为“/ ”，若请求的URL(URL 可以是js/html/img/css资源请求，但不包括 XHR 请求)的域名是“baidu.com”或其子域如“api.baidu.com”、“dev.api.baidu.com”，且 URL 的路径是“/ ”或子路径“/home”、“/home/login”，则浏览器会将此 cookie 添加到该请求的 cookie 头部中。</p>
<p>所以<code>domain</code>和<code>path</code>2个选项共同决定了<code>cookie</code>何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。<code>domain</code>的默认值为设置该<code>cookie</code>的网页所在的域名，<code>path</code>默认值为设置该<code>cookie</code>的网页所在的目录。</p>
<blockquote>
<p>特别说明1：<br>发生跨域xhr请求时，即使请求URL的域名和路径都满足 cookie 的 domain 和 path，默认情况下cookie也不会自动被添加到请求头部中。若想知道原因请阅读本文最后一节）</p>
<p>特别说明2：<br>domain是可以设置为页面本身的域名（本域），或页面本身域名的父域，但不能是公共后缀 public suffix。举例说明下：如果页面域名为 www.baidu.com, domain可以设置为“www.baidu.com”，也可以设置为“baidu.com”，但不能设置为“.com”或“com”。</p>
</blockquote>
<h3 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h3><p><code>secure</code>选项用来设置<code>cookie</code>只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 <code>secure</code> 选项的 <code>cookie</code> 才能被发送至服务器。</p>
<p>默认情况下，<code>cookie</code>不会带<code>secure</code>选项(即为空)。所以默认情况下，不管是<code>HTTPS</code>协议还是<code>HTTP</code>协议的请求，<code>cookie</code> 都会被发送至服务端。但要注意一点，secure选项只是限定了在安全情况下才可以传输给服务端，但并不代表你不能看到这个 <code>cookie</code>。</p>
<p>下面我们设置一个 <code>secure</code>类型的 <code>cookie</code>：</p>
<blockquote>
<p>document.cookie = “name=huang; secure”;</p>
</blockquote>
<p>之后你就能在控制台中看到这个 cookie 了，如下图所示：<br><img src="/images/page/cookie/4.png" alt=""></p>
<blockquote>
<p>这里有个坑需要注意下：<br>如果想在客户端即网页中通过 js 去设置<code>secure</code>类型的 <code>cookie</code>，必须保证网页是<code>https</code>协议的。在<code>http</code>协议的网页中是无法设置<code>secure</code>类型cookie的。</p>
</blockquote>
<h3 id="httpOnly"><a href="#httpOnly" class="headerlink" title="httpOnly"></a>httpOnly</h3><p>这个选项用来设置<code>cookie</code>是否能通过 <code>js</code> 去访问。默认情况下，<code>cookie</code>不会带<code>httpOnly</code>选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个<code>cookie</code>的。当<code>cookie</code>带<code>httpOnly</code>选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个<code>cookie</code>。</p>
<p>在客户端是不能通过<code>js</code>代码去设置一个<code>httpOnly</code>类型的<code>cookie</code>的，这种类型的<code>cookie</code>只能通过服务端来设置。</p>
<p>那我们在页面中怎么知道哪些<code>cookie</code>是<code>httpOnly</code>类型的呢？看下图：<br><img src="/images/page/cookie/5.png" alt=""></p>
<p>凡是<code>httpOnly</code>类型的<code>cookie</code>，其 <code>HTTP</code> 一列都会打上√，如上图中的<code>PA_VTIME</code>。你通过<code>document.cookie</code>是不能获取的，也不能修改<code>PA_VTIME</code>的。</p>
<blockquote>
<p>——<code>httpOnly</code>与安全</p>
<p>从上面介绍中，大家是否会有这样的疑问：为什么我们要限制客户端去访问<code>cookie</code>？其实这样做是为了保障安全。</p>
<p>试想：如果任何<code>cookie</code> 都能被客户端通过<code>document.cookie</code>获取会发生什么可怕的事情。当我们的网页遭受了 <code>XSS</code>攻击，有一段恶意的<code>script</code>脚本插到了网页中。这段<code>script</code>脚本做的事情是：通过<code>document.cookie</code>读取了用户身份验证相关的 <code>cookie</code>，并将这些 <code>cookie</code> 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证）。</p>
</blockquote>
<h2 id="如何设置-cookie？"><a href="#如何设置-cookie？" class="headerlink" title="如何设置 cookie？"></a>如何设置 cookie？</h2><p>知道了<code>cookie</code>的格式，<code>cookie</code>的属性选项，接下来我们就可以设置<code>cookie</code>了。首先得明确一点：<code>cookie</code>既可以由服务端来设置，也可以由客户端来设置。</p>
<h3 id="服务端设置-cookie"><a href="#服务端设置-cookie" class="headerlink" title="服务端设置 cookie"></a>服务端设置 cookie</h3><p>不管你是请求一个资源文件（如 html/js/css/图片），还是发送一个<code>ajax</code>请求，服务端都会返回<code>response</code>。而<code>response header</code>中有一项叫<code>set-cookie</code>，是服务端专门用来设置<code>cookie</code>的。如下图所示，服务端返回的<code>response header</code>中有5个<code>set-cookie</code>字段，每个字段对应一个<code>cookie</code>（注意不能将多个<code>cookie</code>放在一个<code>set-cookie</code>字段中），<code>set-cookie</code>字段的值就是普通的字符串，每个<code>cookie</code>还设置了相关属性选项。<br><img src="/images/page/cookie/6.png" alt=""></p>
<p>注意：</p>
<ul>
<li>一个<code>set-Cookie</code>字段只能设置一个<code>cookie</code>，当你要想设置多个 <code>cookie</code>，需要添加同样多的<code>set-Cookie</code>字段。</li>
<li>服务端可以设置<code>cookie</code> 的所有选项：<code>expires</code>、<code>domain</code>、<code>path</code>、<code>secure</code>、<code>HttpOnly</code></li>
</ul>
<h3 id="客户端设置-cookie"><a href="#客户端设置-cookie" class="headerlink" title="客户端设置 cookie"></a>客户端设置 cookie</h3><p>在网页即客户端中我们也可以通过<code>js</code>代码来设置<code>cookie</code>。如我当前打开的网址为<code>http://dxw.st.sankuai.com/mp/</code>，在控制台中我们执行了下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.cookie = &quot;name=Jonh; &quot;;</div></pre></td></tr></table></figure></p>
<p>查看浏览器 <code>cookie</code> 面板如下图所示，<code>cookie</code>确实设置成功了，而且属性选项 <code>domain</code>、<code>path</code>、<code>expires</code>都用了默认值。<br><img src="/images/page/cookie/7.png" alt=""></p>
<p>再执行下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.cookie=&quot;age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;;</div></pre></td></tr></table></figure></p>
<p>查看浏览器<code>cookie</code> 面板，如下图所示，新的<code>cookie</code>设置成功了，而且属性选项 <code>domain</code>、<code>path</code>、<code>expires</code>都变成了设定的值。<br><img src="/images/page/cookie/8.png" alt=""></p>
<p>注意：</p>
<ul>
<li>客户端可以设置<code>cookie</code> 的下列选项：<code>expires</code>、<code>domain</code>、<code>path</code>、<code>secure</code>（有条件：只有在<code>https</code>协议的网页中，客户端设置<code>secure</code>类型的 <code>cookie</code> 才能成功），但无法设置<code>HttpOnly</code>选项。</li>
</ul>
<h3 id="用-js-如何设置多个-cookie"><a href="#用-js-如何设置多个-cookie" class="headerlink" title="用 js 如何设置多个 cookie"></a>用 js 如何设置多个 cookie</h3><p>当要设置多个<code>cookie</code>时， js 代码很自然地我们会这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.cookie = &quot;name=Jonh; age=12; class=111&quot;;</div></pre></td></tr></table></figure></p>
<p>但你会发现这样写只是添加了第一个<code>cookie</code>“name=John”，后面的所有<code>cookie</code>都没有添加成功。所以最简单的设置多个<code>cookie</code>的方法就在重复执行<code>document.cookie = &quot;key=name&quot;</code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.cookie = &quot;name=Jonh&quot;;</div><div class="line">document.cookie = &quot;age=12&quot;;</div><div class="line">document.cookie = &quot;class=111&quot;;</div></pre></td></tr></table></figure></p>
<h2 id="如何修改、删除"><a href="#如何修改、删除" class="headerlink" title="如何修改、删除"></a>如何修改、删除</h2><h3 id="修改-cookie"><a href="#修改-cookie" class="headerlink" title="修改 cookie"></a>修改 cookie</h3><p>要想修改一个<code>cookie</code>，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新<code>cookie</code>时，<code>path/domain</code>这几个选项一定要旧<code>cookie</code> 保持一样。否则不会修改旧值，而是添加了一个新的<code>cookie</code>。</p>
<h3 id="删除-cookie"><a href="#删除-cookie" class="headerlink" title="删除 cookie"></a>删除 cookie</h3><p>删除一个<code>cookie</code> 也挺简单，也是重新赋值，只要将这个新<code>cookie</code>的<code>expires</code> 选项设置为一个过去的时间点就行了。但同样要注意，<code>path/domain/</code>这几个选项一定要旧<code>cookie</code> 保持一样。</p>
<h2 id="cookie-编码"><a href="#cookie-编码" class="headerlink" title="cookie 编码"></a>cookie 编码</h2><p><code>cookie</code>其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当<code>cookie</code>的 <code>key</code> 和 <code>value</code> 中含有这3个特殊字符时，需要对其进行额外编码，一般会用<code>escape</code>进行编码，读取时用<code>unescape</code>进行解码；当然也可以用<code>encodeURIComponent</code>/<code>decodeURIComponent</code>或者<code>encodeURI</code>/<code>decodeURI</code>（<a href="http://www.cnblogs.com/season-huang/p/3439277.html" target="_blank" rel="external">三者的区别可以参考这篇文章</a>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var key = escape(&quot;name;value&quot;);</div><div class="line">var value = escape(&quot;this is a value contain , and ;&quot;);</div><div class="line">document.cookie= key + &quot;=&quot; + value + &quot;; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&quot;;</div></pre></td></tr></table></figure>
<h2 id="跨域请求中-cookie"><a href="#跨域请求中-cookie" class="headerlink" title="跨域请求中 cookie"></a>跨域请求中 cookie</h2><p>之前在介绍 XHR 的一篇文章里面提过：默认情况下，在发生跨域时，cookie 作为一种 credential 信息是不会被传送到服务端的。必须要进行额外设置才可以。具体原因和如何设置可以参考我的这篇文章：<code>你真的会使用XMLHttpRequest吗</code>？</p>
<p>另外，关于跨域资源共享 <code>CORS</code>极力推荐大家阅读阮一峰老师的这篇 <code>跨域资源共享 CORS 详解</code>。</p>
<h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><ol>
<li>什么时候 cookie 会被覆盖：name/domain/path 这3个字段都相同的时候；</li>
<li>关于domain的补充说明（<a href="https://tools.ietf.org/html/rfc6265#section-5.2.3" target="_blank" rel="external">参考1</a>/<a href="http://erik.io/blog/2014/03/04/definitive-guide-to-cookie-domains/" target="_blank" rel="external">参考2</a>）：<ol>
<li>如果显式设置了 domain，则设置成什么，浏览器就存成什么；但如果没有显式设置，则浏览器会自动取 url 的 host 作为 domain 值；</li>
<li>新的规范中，显式设置 domain 时，如果 value 最前面带点，则浏览器处理时会将这个点去掉，所以最后浏览器存的就是没有点的（注意：但目前大多数浏览器并未全部这么实现）</li>
<li>前面带点‘.’和不带点‘.’有啥区别：<ul>
<li>带点：任何 subdomain 都可以访问，包括父 domain</li>
<li>不带点：只有完全一样的域名才能访问，subdomain 不能（但在 IE 下比较特殊，它支持 subdomain 访问）</li>
</ul>
</li>
</ol>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;咱们不搞一开始就一大堆理论知识介绍，怕把人讲懵了…… 咱们换一个思维方式——“从现象看本质”，先说说我们看到了什么，再从看到的现象中提出问题，最后深入寻找答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;我们看到的-cookie&quot;&gt;&lt;a href=&quot;#我们看到的-cookie&quot; class=&quot;headerlink&quot; title=&quot;我们看到的 cookie&quot;&gt;&lt;/a&gt;我们看到的 cookie&lt;/h2&gt;&lt;p&gt;在 chrome 浏览器中打开一个网站，进入开发者模式，点击&lt;code&gt;Resources&lt;/code&gt;栏 -&amp;gt; 选择&lt;code&gt;cookies&lt;/code&gt;，我们会看到如下图所示的界面：&lt;br&gt;&lt;img src=&quot;/images/page/cookie/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://html-js.site/tags/js/"/>
    
      <category term="cookie" scheme="http://html-js.site/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>ReFlux详解</title>
    <link href="http://html-js.site/2017/03/22/ReFlux%E7%BB%86%E8%AF%B4/"/>
    <id>http://html-js.site/2017/03/22/ReFlux细说/</id>
    <published>2017-03-22T07:53:49.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>ps内容较多，请细心看完</p>
</blockquote>
<p>Flux作为一种应用架构（application architecture）或是设计模式（pattern），阐述的是单向数据流（a unidirectional data flow）的思想，并不是一个框架（framework）或者库（library）。</p>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在细说Flux之前，还是得提一下React ，毕竟Flux这个名字，是因为它才逐渐进入到大众视野。<br>React是facebook提出来的一个库，用来构建用户界面（User Interface），它的三大特点（来自官方）：</p>
<ul>
<li>JUST THE UI： 仅仅是一个View（components），可以认为是MVC中V，用来构建UI界面。</li>
<li>VIRTUAL DOM ： 虚拟dom，为的是：高性能dom渲染（利用diff算法）、组件化（向web components看齐）、多端同构（node，react native）。</li>
<li>DATA FLOW： 单向数据流（one-way data flow），指的是：一种自上而下的渲染方式（top-down rendering）。</li>
</ul>
<p>总而言之，对于一个react web应用，它的UI将会由无数个组件（react component）嵌套组合而成，它们之间存在着层级（hierarchy）关系（通过JSX的语法糖可以轻易看出），也就因此有了父组件，子组件和顶层组件的概念。</p>
<p>然而就像上述第一点所说，React仅仅是一个View，对于一个web应用，没有数据就显得毫无意义。</p>
<p>现在，假使我们通过一个WebAPI模块取得了数据，那么如何传递给React 组件（components），从而实现UI渲染呢？结合组件的层级关系，想到上述所说的第三点：自上而下的渲染，我们将数据传递给顶层组件(controller-view)，同样作为父组件的它，便可以通过组件的属性（properties）将一些有用数据传递给它的各个子组件（各取所需数据），就这样一级一级自上而下地传递下去（直到每一个叶子组件），最终，每一个组件都将得到自己渲染所需要的数据，从而完成UI的渲染。</p>
<p>那么，倘若此时数据变化了（比如：对于一个列表而言，用户点击删除按钮，删除了一条数据），我们又该如何通知各个组件进行UI更新呢？</p>
<p>有这样一种清晰的思路：<br>首先，我们应该需要一个数据存储（Store），存储着react web应用当前的状态（State），就像MVC中的Model一样。<br>然后，当用户点击删除按钮时，将会触发一个消息（Action），告诉Store数据变化了，以及哪里变化了（payload）。<br>最后，Store修改了数据之后，再将新的数据传递给最顶层组件，重新完成一次自上而下的渲染（re-render），从而更新了UI（不要过分担心性能问题，VIRTUAL DOM就是用来解决这个的）。</p>
<p>显然上述的几步，React作为一个View是不可能做到的，也正因为这样，<strong>Flux作为一种架构方案才被提出来</strong>，它的思想大体就是上述这几步，通过一个<strong>单向数据的流动</strong>，完成了UI的更新，用一张图可以表示，如下（以Facebook Flux为例）：<br><img src="/images/page/reflux/1.png" alt=""></p>
<p>当然，作为应用数据处理的模式，除了Flux，还有很多（如：传统的MVC，MVVM），只是Flux凭借其单向数据流特点，使得数据流变得简单，易于调试和追踪问题，所以更适合与React进行组合使用。<br>前面，我们就一直在说，<strong>Flux是一种架构，一种模式，并不是一个框架，也不是一个库</strong>，就像我们说MVC（VM）的概念一样，所以，遵循着Flux模式所阐述的思想自然就会出现一些库，如：Facebook Flux、Reflux、Fluxxor、Redux等等。<br>本文主要讲解的Reflux，不过在这之前还是需要先提一下Facebook Flux，从而为后面一些对比做一些铺垫。</p>
<h3 id="Facebook-Flux"><a href="#Facebook-Flux" class="headerlink" title="Facebook Flux"></a>Facebook Flux</h3><p><a href="https://github.com/facebook/flux" target="_blank" rel="external">Facebook Flux</a>，是Facebook在提出Flux架构后，给出的一个对Flux的简单实现，可以认为是Flux库的第一个范例，所以，也有人称之为Original Flux。<br>Facebook Flux中引入了四个概念： Dispatcher、 Actions、Stores、Views（Controller-Views），而它们之间的关系就如同上面的那张图所描述的一样，构成了一个单向数据流的闭环，简化版如下：<br><img src="/images/page/reflux/2.png" alt=""><br>接下来，将以官方的TodoMVC Demo为例，来说明它们各自的作用，以及它们之间是如何配合工作的？（PS：建议读者将源代码clone下来，边看边调试）<br><img src="/images/page/reflux/3.png" alt=""></p>
<h4 id="Views-and-Controller-Views"><a href="#Views-and-Controller-Views" class="headerlink" title="Views and Controller-Views"></a>Views and Controller-Views</h4><p>Facebook Flux中所指的Views，其实就是React Components，用作UI渲染，而相对特别的，Controller-Views指的则是顶层React Component，除了UI渲染外，它还负责接收来自Store变化的数据，并传递给它的Child Component（即Controller-View -&gt; Child Views），用于子View的渲染。<br>在这个例子中，TodoApp就是一个Controller-View，它监听到TodoStore的数据变化后，便会重新从TodoStore中获取数据，然后通过调用组件setState()方法，触发render()方法的执行，从而得到UI的更新（自上而下的渲染）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 从TodoStore中获取数据</div><div class="line">function getTodoState() &#123;</div><div class="line">  return &#123;</div><div class="line">    allTodos: TodoStore.getAll(),</div><div class="line">    areAllComplete: TodoStore.areAllComplete()</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var TodoApp = React.createClass(&#123;</div><div class="line"></div><div class="line">  componentDidMount: function() &#123;</div><div class="line">	// TodoApp监听TodoStore的数据变化</div><div class="line">    TodoStore.addChangeListener(this._onChange);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render: function() &#123;</div><div class="line">	return (</div><div class="line">		&lt;div&gt;&#123;/* 此处代码省去 */&#125;&lt;/div&gt;</div><div class="line">	);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  _onChange: function() &#123;</div><div class="line">	// 重新获取TodoStore的数据，并通过调用setState，触发re-render</div><div class="line">    this.setState(getTodoState());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Stores"><a href="#Stores" class="headerlink" title="Stores"></a>Stores</h3><p>Facebook Flux中的Stores，作为数据存储的模块，类似于MVC中的Model，它负责接收Dispatcher分发过来的actions，针对不同的actionType，对数据就进行不同的操作（如：增删改查），最后再通知View，数据变化了，需要进行UI更新。</p>
<p>在这个例子中，TodoStore通过变量_todos变量存储着整个应用的数据（一个列表），并通过AppDispatcher（Dispatcher实例）注册回调，来接收不同类型的Action指令，进而执行不同的数据操作（mutate data），最后通知TodoApp View数据改变，需要更新UI（re-render）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">// 数据存储（一个列表）</div><div class="line">var _todos = &#123;&#125;;</div><div class="line"></div><div class="line">// 操作数据的函数</div><div class="line">function create(text) &#123;/*此处代码省去*/&#125;</div><div class="line">function update(id, updates) &#123;/*此处代码省去*/&#125;</div><div class="line">function destroy(id) &#123;</div><div class="line">  delete _todos[id];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 接收分发过来的Action</div><div class="line">AppDispatcher.register(function(action) &#123;</div><div class="line">  var text;</div><div class="line">  </div><div class="line">  // 判断Action类型，采取不同的数据操作</div><div class="line">  switch(action.actionType) &#123;</div><div class="line">  </div><div class="line">	// 新增</div><div class="line">    case TodoConstants.TODO_CREATE:</div><div class="line">      text = action.text.trim();</div><div class="line">      if (text !== &apos;&apos;) &#123;</div><div class="line">        create(text);  // 创建数据，并存储</div><div class="line">        TodoStore.emitChange(); // 通知TodoApp数据变化，需要更新UI</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">      </div><div class="line">	// 更新</div><div class="line">    case TodoConstants.TODO_UPDATE_TEXT:/*此处代码省去*/</div><div class="line">	  break;</div><div class="line">	  </div><div class="line">	// 删除</div><div class="line">    case TodoConstants.TODO_DESTROY:/*此处代码省去*/</div><div class="line">	  break;</div><div class="line">	  </div><div class="line">   /*此处省去部分代码*/</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Facebook Flux中，Dispatcher起到了一个中央枢纽（Central Hub）的角色，它存储着一张Stores列表清单，并且负责Actions的分发工作，即Action的一旦触发，Dispatcher将会通知列表清单上的<strong>所有的Stores</strong>，每一个Store则选择性地针对该Action进行特定处理（或者不处理）。<br>在一个应用中，Dispatcher实例只允许有一个（Single），也就是说它将作为一个单例而存在。<br>在这个例子中，AppDispatcher就是这样一个单例，我们在TodoStores通过AppDispatcher.register()注册回调（见上段代码），来接收不同类型的Actions（消息订阅），在TodoActions里通过AppDispatcher.dispatch()执行不同Actions的分发（消息发布），如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var TodoActions = &#123;</div><div class="line">  // 新增Action</div><div class="line">  create: function(text) &#123;</div><div class="line">    AppDispatcher.dispatch(&#123;  // 通知TodoStore对数据进行修改（带有Action类型和关联数据）</div><div class="line">      actionType: TodoConstants.TODO_CREATE, // Action类型：create</div><div class="line">      text: text  // 传递给TodoStore的数据</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  // 更新Action</div><div class="line">  updateText: function(id, text) &#123;</div><div class="line">    AppDispatcher.dispatch(&#123;</div><div class="line">      actionType: TodoConstants.TODO_UPDATE_TEXT, // Action类型：update</div><div class="line">      id: id,</div><div class="line">      text: text</div><div class="line">    &#125;);</div><div class="line">  &#125;,</div><div class="line">  // 删除Action</div><div class="line">  destroy: function(id) &#123;</div><div class="line">    AppDispatcher.dispatch(&#123;</div><div class="line">      actionType: TodoConstants.TODO_DESTROY, // Action类型：destroy</div><div class="line">      id: id</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  /*此处省去部分代码*/</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h3><p>Facebook Flux中的有一个概念叫做Action Creator，可以将它理解为一个方法（即helper method），专门用来创建某种类型的Action。<br>上一段代码中，TodoActions模块就提供了这些helper methods（或者叫做Action Creators），如：<br>TodoActions.create(text)<br>TodoActions.updateText(id, text)<br>TodoActions.destroy(id)<br>…<br>上述每一个方法在内部，都定义了自己的常量类型（actionType），并且将接收的参数作为数据（payload），从而封装成一个完整的Action（即actionType + payload = Action）。<br>最后，再统一通过调用Dispatcher.dispatch()将特定的Action以消息的形式分发出去（即传递给Stores），Stores在得到Action后，便可以通过Action.actionType来判定采取某种操作（或者忽略这个Action），而执行操作时需要用到的数据则来自Action.payload。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>Facebook Flux中提出的这四个概念，承担着各自角色，通过互相协作，形成了一个单向数据流的闭环。<br>——【推荐大家看下这篇文章<a href="https://code-cartoons.com/a-cartoon-guide-to-flux-6157355ab207" target="_blank" rel="external">《A cartoon guide to Flux》</a>，生动形象地描述了这几个角色。】<br>说完了Facebook Flux，让我们静静思考一下，存在的不足：<br>倘若，有一个单页面应用，程序中就可能存在N个store，每个store都会监听1~N个action，代码就会像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// storeA.js</div><div class="line">Dispatcher.register(function (action) &#123;</div><div class="line">	switch(action.actionType) &#123;</div><div class="line">		case &apos;actionA&apos;: break;</div><div class="line">		case &apos;actionB&apos;: break;</div><div class="line"></div><div class="line">		/* ... 1~N个action */</div><div class="line">		</div><div class="line">		case &apos;actionN&apos;: break;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// storeB.js</div><div class="line">Dispatcher.register(function () &#123;</div><div class="line">	// 同上</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/* ... */</div><div class="line">/* ... 1~N个store */</div><div class="line">/* ... */</div><div class="line"></div><div class="line">// storeN.js</div><div class="line">Dispatcher.register(function () &#123;</div><div class="line">	// 同上</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>假使此时，触发了一个actionX，那么storeA~storeB的通过Dispatcher.register()注册的回调函数会按注册顺序依次被触发(无一例外)，也就是说每个store都会得到actionX通知，唯一不同的可能就是：每个store模块，会通过各自的switch语句进行判断，有的对actionX做处理，有的则不处理（忽略），那么问题来了：</p>
<p>『既然有些store对actionX不需要处理，那么它们注册的回调执行是否有必要？毕竟是函数执行是有开销的，如果有1000个store对actionX不”感冒”的的话，会不会很浪费资源？』<br>分析下这个问题：Facebook Flux是以Dispatcher（发布者）作为消息中枢，所有的Action消息都会统一从这里分发出去，广播给所有的Store（订阅者），也就是说：发布者（Dispatcher）和订阅者（Stores）之间存在着一对多的关系，而事实上Actions（消息）和Stores（订阅者）之间却存在着一个多对多的关系，如下图：<br><img src="/images/page/reflux/4.png" alt=""></p>
<p>这样的矛盾，就使得，每一个Store不得不在自己的回调函数里通过Switch语句，来判断当前Action的类型，来决定要不要进行处理，那么暂且抛开性能不说，显然，这样写法，却显得繁重且不够优雅。<br>于是，接下来，看看Reflux在Facebook Flux的基础之上，做了那些优化？</p>
<h2 id="Reflux"><a href="#Reflux" class="headerlink" title="Reflux"></a>Reflux</h2><p><a href="https://github.com/reflux/refluxjs" target="_blank" rel="external">Reflux</a>，是另一个实现Flux模式的库，旨在使整个应用架构变得更加简单。<br>准确地说，Reflux是由Facebook Flux演变而来（inspired by Facebook Flux），可以说是它的一个进化版本，自然而言就会拿两者进行比较：<a href="https://github.com/reflux/refluxjs#comparing-refluxjs-with-facebook-flux" target="_blank" rel="external">详见这里</a>。<br>简要概括一下重点，就是：</p>
<p>1.Reflux保留了Facebook Flux中原有的三个概念：Actions、Stores、Views（Controller-Views），去除了Dispatcher，如果要用一张图表示的话，就是这样：<br><img src="/images/page/reflux/5.png" alt=""></p>
<p>此时会有人问：没有了消息中枢（Dispatcher），消息Actions如何发布出去，并传递到Stores呢？<br>答：在Reflux中，每一个Action本身就是一个Publisher（消息发布者），即自带了消息发布功能；而每一个Store除了作为数据存储之外，它还是一个Subscriber，或者叫做Listener（消息订阅者），自然就可以通过监听Action，来获取到变化的数据。</p>
<p>2.Store之间可以互相监听</p>
<h2 id="这样的场景还是有的，比如：在单页面应用中，如果不同Page拥有不同的Store，那么就可能会出现：子页面Store数据变化后，需要通知到父页面Store进行相应修改的情况。"><a href="#这样的场景还是有的，比如：在单页面应用中，如果不同Page拥有不同的Store，那么就可能会出现：子页面Store数据变化后，需要通知到父页面Store进行相应修改的情况。" class="headerlink" title="这样的场景还是有的，比如：在单页面应用中，如果不同Page拥有不同的Store，那么就可能会出现：子页面Store数据变化后，需要通知到父页面Store进行相应修改的情况。"></a>这样的场景还是有的，比如：在单页面应用中，如果不同Page拥有不同的Store，那么就可能会出现：<strong>子页面Store数据变化后，需要通知到父页面Store进行相应修改</strong>的情况。</h2><p>回顾上一节中，对于Facebook Flux的思考，所遗留的问题点，在Reflux中是否解决了呢？<br>答案是：肯定的。<br>这里先简单说明下：<br>前面讲到Actions和Stores（消息订阅者）间本身就存在着多对多的关系，而作为Publisher（消息发布者），<br>在Facebook Flux中只有一个，即Dispatcher，所以，不得不在消息发布时，通过在payload中添加actionType字段来区分消息类型，且Store也因此不得不在回调函数中用Switch语句进行判断actionType处理。<br>而在Reflux中，由于每一个Action都是一个Publisher，且具有特定的含义（actionType），即多个Publisher对应于多个Subscriber（或叫做Listener），Store便可以有目的性地选择订阅想监听的Action，而不是监听所有的Action，再通过Switch语句进行筛选；另外，Action（消息）的发布，也只会通知给之前有订阅过的Store，而不是所有Store，所以并不会造成任何资源浪费。<br>归结一点，就是Reflux将Dispatcher的功能合并到Action中去，使得每一个Action都具有了消息发布的功能，可以直接被Store所监听（即listenable）。</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>无论是从具体的用法，还是从源码的架构来看，<strong>Reflux本质上可以理解为一个PubSub库</strong>。<br>可以用一张具体的图来表现这一说法，如下：<br><img src="/images/page/reflux/6.png" alt=""></p>
<p>从图中可以看出，Actions、Stores和Views在Reflux中分别承担着消息发布订阅模式中的一个或多个角色，即：发布者（Publisher）或者 订阅者（Subscriber/Listener），也正是基于这样的角色扮演，才使得它能够实现作为Flux所应该具有的单向数据流特性（图中红线部分）。<br>总结一下：</p>
<h4 id="Reflux单向数据流的实现，是完全基于PubSub设计模式的。"><a href="#Reflux单向数据流的实现，是完全基于PubSub设计模式的。" class="headerlink" title="Reflux单向数据流的实现，是完全基于PubSub设计模式的。"></a>Reflux单向数据流的实现，是完全基于PubSub设计模式的。</h4><p>Action，Store和View三者的角色分配以及分工合作，如下：</p>
<ul>
<li>Action 是一个Publisher，负责消息的分发，一般是由用户行为（User Interaction），或是Web API触发。</li>
<li>Store 不仅是一个Publisher，还是一个Subscriber（或者叫做Listener），作为Subscriber，负责监听Action的触发；作为Publisher，则负责通知View更新UI。</li>
<li>View 是一个Subscriber，负责监听Store的数据变化，做到及时更新UI。</li>
</ul>
<p>既然Reflux中的对象不是Publisher就是Subscriber/Listener，那么代码是如何组织的呢？<br>答：Reflux抽取出两个模块：PublisherMethods 和 ListenerMethods，顾名思义，这两个集合分别存储着一个对象作为Publisher和Listener所应该具有的方法。</p>
<p>比如：<br>PublisherMethods中包括：trigger、triggerAsync等消息发布方法。<br>ListenerMethods中就包括listenTo、listenToMany等消息订阅方法。<br>具体的细节，感兴趣的同学可以看一下源码，以及这篇文章《<a href="http://blog.krawaller.se/posts/the-reflux-data-flow-model/" target="_blank" rel="external">The Reflux data flow model</a>》详细介绍了Reflux与PubSub的关系。</p>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>这一节的主要目的是：通过代码示例和应用场景，尽可能地讲解Reflux每个API的全貌，以及将代码如何写得更简洁优雅？</p>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>在Reflux中，因为没有了Action Creator的概念，所以，Action的创建都是通过统一的API：Reflux.createAction()或者Reflux.createActions()来实现。</p>
<p>1.通过Reflux.createAction()创建单个Action，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 拥有配置</div><div class="line">var action = Reflux.createAction(&#123;</div><div class="line">    actionName: &apos;addItem&apos;,  // 其实这个actionName并没有什么用，可不传</div><div class="line">    asyncResult: true,</div><div class="line">    sync: false,</div><div class="line">    children: [&apos;success&apos;]</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 简化</div><div class="line">var action = Reflux.createAction(&apos;addItem&apos;)</div><div class="line"></div><div class="line">// 或者匿名</div><div class="line">var addItemAction = Reflux.createAction();</div></pre></td></tr></table></figure></p>
<p>注意：Reflux.createAction()的返回值是一个特殊的对象 — 函数（functor），这样的设计其实是为了方便Action的触发，显得更加函数化编程(FRP) ，就像下面这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">addItemAction(&#123;a: 1&#125;);</div><div class="line">action(&apos;hello world&apos;, &apos;Lovesueee&apos;);</div></pre></td></tr></table></figure></p>
<p>action创建的时候，可以进行参数的配置，具体的参数意义如下：<br>sync： 设置为true，指定action的默认触发方式为同步<br>children： 用于创建子Action（主要是用在异步操作的时候，后面会讲到）</p>
<h2 id="asyncResult：设置为true时，自动创建两个名为’completed’和’failed’的子Action（可以认为是设置子Action的一个快捷方式）"><a href="#asyncResult：设置为true时，自动创建两个名为’completed’和’failed’的子Action（可以认为是设置子Action的一个快捷方式）" class="headerlink" title="asyncResult：设置为true时，自动创建两个名为’completed’和’failed’的子Action（可以认为是设置子Action的一个快捷方式）"></a>asyncResult：设置为true时，自动创建两个名为’completed’和’failed’的子Action（可以认为是设置子Action的一个快捷方式）</h2><p>2.通过Reflux.createActions()创建多个Action，即Actions集合，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &apos;deleteItem&apos;]);</div><div class="line"></div><div class="line">// 个别action配置</div><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &#123;</div><div class="line">	deleteItem: &#123;</div><div class="line">		asyncResult: true,</div><div class="line">		children: [&apos;success&apos;],</div><div class="line">	&#125;,</div><div class="line">	updateItem: &#123;...&#125;</div><div class="line">&#125;]);</div><div class="line"></div><div class="line">// 也可以这样</div><div class="line">var actions = Reflux.createActions(&#123;</div><div class="line">	addItem: &#123;&#125;,</div><div class="line">	deleteItem: &#123;</div><div class="line">		asyncResult: true,</div><div class="line">		children: [&apos;success&apos;]</div><div class="line">	&#125;,</div><div class="line">	updateItem: &#123;...&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>注意：Reflux.createActions()返回的是一个普通的对象，即Actions集合，所以Action触发时，需要指定actionName，就像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">actions.addItem(&#123;...&#125;);</div><div class="line">actions.deleteItem();</div></pre></td></tr></table></figure></p>
<h2 id="一般说来，在实际项目代码中，由于涉及到的Action较多，所以一般都是调用Reflux-createActions-一次性创建Actions集合，比较方便。另外，之后Store通过listenables字段与Action进行关联时，需要的也是一个Actions集合。"><a href="#一般说来，在实际项目代码中，由于涉及到的Action较多，所以一般都是调用Reflux-createActions-一次性创建Actions集合，比较方便。另外，之后Store通过listenables字段与Action进行关联时，需要的也是一个Actions集合。" class="headerlink" title="一般说来，在实际项目代码中，由于涉及到的Action较多，所以一般都是调用Reflux.createActions()一次性创建Actions集合，比较方便。另外，之后Store通过listenables字段与Action进行关联时，需要的也是一个Actions集合。"></a>一般说来，在实际项目代码中，由于涉及到的Action较多，所以一般都是调用Reflux.createActions()一次性创建Actions集合，比较方便。另外，之后Store通过listenables字段与Action进行关联时，需要的也是一个Actions集合。</h2><p>之前就提到，Action作为一个Publisher，会拥有PublisherMethods集合里提供的一系列方法，这里统一举例说明：<br>listen：Action消息订阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction();</div><div class="line"></div><div class="line">addAction.listen(function (url) &#123;</div><div class="line">	// 默认上下文this是addAction</div><div class="line">	$.ajax(url).done(function () &#123;</div><div class="line">		// todo: save to store</div><div class="line">	&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction(&apos;/xxx/add&apos;);</div></pre></td></tr></table></figure></p>
<hr>
<p>trigger 同步触发Action消息，在触发具体的消息之前，首先会先执行preEmit和shouldEmit回调。<br>preEmit返回值(非undefined)将作为shouldEmit函数的入参，用于修改payload<br>shouldEmit的返回值(true or false)，将作为是否真正触发消息的标志<br>举几个例子说明下，preEmit和shouldEmit的使用，如下：<br>preEmit用于异步请求，下面两种方法是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions(&#123;</div><div class="line">	add: &#123;</div><div class="line">		asyncResult: true,</div><div class="line">		preEmit: function (url) &#123;</div><div class="line">			$.ajax(url)</div><div class="line">				.done(this.completed)</div><div class="line">				.fail(this.failed);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">// 等价于</div><div class="line">var actions = Reflux.createActions(&#123;</div><div class="line">	add: &#123;</div><div class="line">		asyncResult: true</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">actions.add.listen(function(url) &#123;</div><div class="line">	$.ajax(url)</div><div class="line">		.done(this.completed)</div><div class="line">		.fail(this.failed)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>preEmit用于修改payload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;takePhoto&apos;]);</div><div class="line"></div><div class="line">// 映射</div><div class="line">var maps = &#123;</div><div class="line">	&apos;photo&apos;: &#123;</div><div class="line">		maxSize: 1000     // 从相册获取</div><div class="line">	&#125;,</div><div class="line">	&apos;camera&apos;: &#123;           // 拍照</div><div class="line">		maxSize: 2000,</div><div class="line">		maxSelect: 10</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">actions.takePhoto.preEmit = function (type) &#123;</div><div class="line">	return maps[type] || maps[&apos;photo&apos;];</div><div class="line">&#125;;</div><div class="line"></div><div class="line">actions.takePhoto.listen(function (options) &#123;</div><div class="line">	// do ajax</div><div class="line">	console.log(options);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">actions.takePhoto(&apos;photo&apos;);</div><div class="line">// 或者</div><div class="line">// actions.takePhoto(&apos;camera&apos;);</div></pre></td></tr></table></figure></p>
<p>shouldEmit的使用（防止action的频繁触发）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var requesting = false;</div><div class="line">var actions = Reflux.createActions([&apos;submit&apos;]);</div><div class="line"></div><div class="line">actions.submit.shouldEmit = function () &#123;</div><div class="line">	return !requesting;</div><div class="line">&#125;</div><div class="line"></div><div class="line">actions.submit.listen(function (url) &#123;</div><div class="line"></div><div class="line">	requesting = true;</div><div class="line">	</div><div class="line">	$.ajax(url).done(function () &#123;</div><div class="line">		// success</div><div class="line">	&#125;).fail(function () &#123;</div><div class="line">		// error</div><div class="line">	&#125;).always(function () &#123;</div><div class="line">		requesting = false;</div><div class="line">	&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 点击按钮</div><div class="line">$(&apos;#btn&apos;).click(function () &#123;</div><div class="line">	actions.submit(&apos;url/submit&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<hr>
<p>promise: 语法糖，用于简写异步Action，下面两种方法是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	children: [&apos;completed&apos;, &apos;failed&apos;] // 等价于 asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction.listen(function (url) &#123;</div><div class="line">	var me = this;</div><div class="line">	$.ajax(url).done(function (data) &#123;</div><div class="line">		me.completed(data);</div><div class="line">	&#125;).fail(function () &#123;</div><div class="line">		me.failed();</div><div class="line">	&#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 等价于</div><div class="line">addAction.listen(function (url) &#123;</div><div class="line">	this.promise($.ajax(url));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction(&apos;/url/add&apos;);</div></pre></td></tr></table></figure></p>
<p>listenAndPromise: 是上述两个方法listen和promise方法的结合，做了两件事情：消息订阅和异步回调。<br>比如上面的例子，就可以这样简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">addAction.listenAndPromise(function(url) &#123;</div><div class="line">    return $.ajax(url);    // 注意：返回promise对象</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="triggerAsync-异步触发Action消息（而trigger同步触发消息），类似于setTimeout-function-action-0-。"><a href="#triggerAsync-异步触发Action消息（而trigger同步触发消息），类似于setTimeout-function-action-0-。" class="headerlink" title="triggerAsync: 异步触发Action消息（而trigger同步触发消息），类似于setTimeout(function () {action();}, 0)。"></a>triggerAsync: 异步触发Action消息（而trigger同步触发消息），类似于setTimeout(function () {action();}, 0)。</h2><p>triggerPromise 触发Action消息，可以通过返回的promise将异步请求的数据直接带回，而不需要经过Store。<br>改写上面的例子，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction.listenAndPromise(function(url) &#123;</div><div class="line">    return $.ajax(url);    // 注意：返回promise对象</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 触发消息，监听异步子action的成功与失败</div><div class="line">// action这里可以获取到数据，</div><div class="line">addAction.triggerPromise(&apos;/url/add&apos;).then(function (data) &#123;</div><div class="line">	console.log(data);</div><div class="line">&#125;, function () &#123;</div><div class="line">	console.log(&apos;failed&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<hr>
<p>最后再说说，子Action的概念，其实之前都用到了，主要是用于异步请求，成功和失败回调的执行，这里简单说明一下：<br>在利用Reflux.createAction创建Action之初，可以通过下面的两种方式创建子Action:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 等价于</div><div class="line"></div><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	children: [&apos;completed&apos;, &apos;failed&apos;]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="在创建之后这两个子Action在数据存储结构中，便可以直接通过addAction-completed和addAction-failed访问。"><a href="#在创建之后这两个子Action在数据存储结构中，便可以直接通过addAction-completed和addAction-failed访问。" class="headerlink" title="在创建之后这两个子Action在数据存储结构中，便可以直接通过addAction.completed和addAction.failed访问。"></a>在创建之后这两个子Action在数据存储结构中，便可以直接通过addAction.completed和addAction.failed访问。</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>Store作为数据存储中心，且因为介于Actions和Views之间，所以同时承担着Publisher（消息发布者）和Subscriber（消息订阅者）两种角色。<br>Reflux中，Store的创建同样是通过提供的API：Reflux.createStore()，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var action = Reflux.createAction();</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		// 存储数据</div><div class="line">		this.data = &#123;&#125;;</div><div class="line">			</div><div class="line">		// Action监听</div><div class="line">		this.listenTo(action, this._onAction);</div><div class="line">		// 或者</div><div class="line">		// this.listenTo(action, &apos;_onAction&apos;);</div><div class="line">		// 或者</div><div class="line">		// action.listen(this._onAction);</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	_onAction: function (msg) &#123;</div><div class="line">		console.log(msg);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">action(&apos;hello world&apos;);	// 触发动作</div></pre></td></tr></table></figure></p>
<h2 id="不同于Action，Store返回的是一个普通的对象，通常我们会在init方法中进行数据的存储-和Action的监听。"><a href="#不同于Action，Store返回的是一个普通的对象，通常我们会在init方法中进行数据的存储-和Action的监听。" class="headerlink" title="不同于Action，Store返回的是一个普通的对象，通常我们会在init方法中进行数据的存储 和Action的监听。"></a>不同于Action，Store返回的是一个普通的对象，通常我们会在init方法中进行数据的存储 和Action的监听。</h2><p>在创建Store时，我们可以通过传递一个特殊的字段mixins，它的功能就有点类似于React Component中的mixins。<br>在mixin中，对于几个特殊方法：init, preEmit, shouldEmit会进行特殊处理（组合），保证mixins里面的方法都会被执行而，对于其他自定义方法，有一定的覆盖规则，比如，下面的例子中myMethod方法的覆盖优先级就是：store &gt; mixin3 &gt; mixin2 &gt; mixin。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">var mixin = &#123;</div><div class="line">	init: function () &#123;</div><div class="line">		console.log(&apos;mixin:init&apos;)</div><div class="line">	&#125;,</div><div class="line">	myMethod: function () &#123;</div><div class="line">		console.log(&apos;mixin.myMethod&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var mixin2 = &#123;</div><div class="line">	init: function () &#123;</div><div class="line">		console.log(&apos;mixin2:init&apos;)</div><div class="line">	&#125;,</div><div class="line">	myMethod: function () &#123;</div><div class="line">		console.log(&apos;mixin2.myMethod&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var mixin3 = &#123;</div><div class="line">	mixins: [mixin2],</div><div class="line">	init: function () &#123;</div><div class="line">		console.log(&apos;mixin3:init&apos;)</div><div class="line">	&#125;,</div><div class="line">	myMethod: function () &#123;</div><div class="line">		console.log(&apos;mixin3.myMethod&apos;);</div><div class="line">	&#125;,</div><div class="line">	otherMethod: function () &#123;</div><div class="line">		console.log(&apos;mixin3.otherMethod&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	mixins: [mixin, mixin3],</div><div class="line">	init: function () &#123;</div><div class="line">		console.log(&apos;store:init&apos;);</div><div class="line">	&#125;,</div><div class="line">	myMethod: function () &#123;</div><div class="line">		console.log(&apos;store:myMethod&apos;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">store.myMethod();</div><div class="line"></div><div class="line">// mixin:init</div><div class="line">// mixin2:init</div><div class="line">// mixin3:init</div><div class="line">// store:init</div><div class="line">// store:myMethod</div></pre></td></tr></table></figure></p>
<hr>
<p>再从PubSub的角度说说Store：<br>作为消息的发布者，拥有着和Action一样的能力，即拥有PublisherMethods集合的所有方法；同时作为消息的订阅者，用来监听Action的触发（或其他Store的改变），从而改变自身数据，Store还拥有ListenerMehthods集合提供的方法。<br>这里重点说一下，Store作为消息订阅者这个角色，拥有的几个比较重要的方法：</p>
<p>listenTo: 监听指定的listenable的变化，从而执行回调（这里的listenable可以是Action，也可以是Store）<br>(注意：reflux中，Store之间是可以监听的，但是不可以互相监听哦，避免死循环（circular loop）)<br>举例几个例子，说明：<br>Store监听Action<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&apos;add&apos;);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.data = &#123;</div><div class="line">			flag: false</div><div class="line">		&#125;;</div><div class="line">	&#125;,</div><div class="line">	getInitialState: function () &#123;</div><div class="line">		return this.data;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">store.listenTo(addAction, function (flag) &#123;</div><div class="line">	this.data.flag = flag;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">addAction(true);</div></pre></td></tr></table></figure></p>
<p>Store监听其他Store（设置listenTo第三个回调，通过调用被监听Store的getInitialState方法获取其初始值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var storeA = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.data = &#123;</div><div class="line">			a: 1</div><div class="line">		&#125;;</div><div class="line">	&#125;,</div><div class="line">	getInitialState: function () &#123;</div><div class="line">		return this.data;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var storeB = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.data = &#123;</div><div class="line">			b: 2</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">storeB.listenTo(storeA, function (a) &#123;</div><div class="line">	this.data.a = a;</div><div class="line">&#125;, function (data) &#123;</div><div class="line">	// storeB获取storeA的初始值</div><div class="line">	this.data.a = data.a;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">console.log(storeB); // storeB.data =&gt; &#123;a: 1, b: 2&#125;</div><div class="line"></div><div class="line">storeA.trigger(3);</div><div class="line"></div><div class="line">console.log(storeB); // storeB.data =&gt; &#123;a: 3, b: 2&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>listenToMany: 监听指定的listenables（对象集合）变化，从而执行对应的回调（这里的listenables是一个对象，它的每一个值可以是action，也可以是store）<br>通常会这样使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &apos;deleteItem&apos;]);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.items = [];</div><div class="line">		this.listenToMany(actions);</div><div class="line">	&#125;,</div><div class="line">	onAddItem: function (item) &#123;</div><div class="line">		this.items.push(item);</div><div class="line">	&#125;,</div><div class="line">	onDeleteItem: function (item) &#123;</div><div class="line">		var items = this.items;</div><div class="line">		</div><div class="line">		items.forEach(function (val, index) &#123;</div><div class="line">			if (val === item) &#123;</div><div class="line">				items.splice(index, 1);</div><div class="line">				// todo: break</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">actions.addItem(1);</div><div class="line">actions.addItem(2);</div><div class="line"></div><div class="line">console.log(store); // store.items =&gt; [1, 2]</div><div class="line"></div><div class="line">actions.deleteItem(1);</div><div class="line"></div><div class="line">console.log(store); // store.items =&gt; [2]</div></pre></td></tr></table></figure></p>
<p>当一个store监听listenables对象集合（即多个监听对象，比如：多个action）时，实际上做的事情也还是单个消息订阅store.listenTo(actionName, onActionName)，但是这里有一个约定（或者叫做映射关系），以上面的两个action为例:</p>
<p><strong>actionName    onActionName</strong><br>addItem        onAddItem<br>deleteItem    onDeleteItem</p>
<p>actionName 对应的回调就是 on + actionName(驼峰写法)<br>然后Reflux还做了一些容错处理，如果你不按照这个约定（即命名不规范）的话，它会这样获取需要注册的回调：<br>以名为addItemaction为例，它的callback依次会取：<br>this.onAddItem -&gt; this.addItem -&gt; undefined（不注册回调）<br>自然而然，涉及到listenTo方法就会想起上面说的它的第三个参数defaultCallback用来初始化，那么在listenToMany方法对此就有这样的约定（或者叫做映射关系）：<br>以名为addItemaction为例（一般是store之间才会使用，且很少使用），它的defaultCallback依次会取：</p>
<h2 id="this-onAddItemDefault-gt-this-addItemDefault-gt-undefined（没有初始化回调）"><a href="#this-onAddItemDefault-gt-this-addItemDefault-gt-undefined（没有初始化回调）" class="headerlink" title="this.onAddItemDefault -&gt; this.addItemDefault -&gt; undefined（没有初始化回调）"></a>this.onAddItemDefault -&gt; this.addItemDefault -&gt; undefined（没有初始化回调）</h2><p>这里还需要再提起一次，子Action的概念，对于下面这段代码：<br>之前会这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.listenTo(addAction.completed, &apos;onAddCompleted&apos;);</div><div class="line">		this.listenTo(addAction.failed, &apos;onAddFailed&apos;);</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	onAddCompleted: function (data) &#123;</div><div class="line">		console.log(&apos;completed: &apos;, data);</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	onAddFailed: function () &#123;</div><div class="line">		console.log(&apos;failed&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果用listenToMany方法来做的话，就可以这样简化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var addAction = Reflux.createAction(&#123;</div><div class="line">	asyncResult: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.listenToMany(&#123;add: addAction&#125;); // 注意：参数是一个对象</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	onAddCompleted: function (data) &#123;</div><div class="line">		console.log(&apos;completed: &apos;, data);</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	onAddFailed: function () &#123;</div><div class="line">		console.log(&apos;failed&apos;)</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>也就是说，listenToMany方法，不但关联了action，还会关联它的子action，即addAction.completed和addAction.failed，这里就又有一个约定（或者叫做映射关系）：</p>
<p><strong>actionName    onActionName    childActionName    onChildActionName</strong><br>add    onAdd    addCompleted / addFailed    onAddCompleted / onAddFailed</p>
<h2 id="即：on-主action名-子action名（驼峰）"><a href="#即：on-主action名-子action名（驼峰）" class="headerlink" title="即：on + 主action名 + 子action名（驼峰）"></a>即：on + 主action名 + 子action名（驼峰）</h2><p>然而，在利用Reflux.createStore()创建之初，我们可以利用更简洁的一种方式，对Store和Actions进行关联。<br>之前是这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &apos;deleteItem&apos;]);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		this.listenToMany(actions); // 关联actions</div><div class="line">	&#125;,</div><div class="line">	onAddItem: function () &#123;</div><div class="line">		// todo: add</div><div class="line">	&#125;,</div><div class="line">	onDeleteItem: function () &#123;</div><div class="line">		// todo: delete</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>现在可以通过listenables字段来关联：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var actions = Reflux.createActions([&apos;addItem&apos;, &apos;deleteItem&apos;]);</div><div class="line"></div><div class="line">var store = Reflux.createStore(&#123;</div><div class="line">	listenables: actions  // 关联actions</div><div class="line">	init: function () &#123;</div><div class="line">		// init</div><div class="line">	&#125;,</div><div class="line">	onAddItem: function () &#123;</div><div class="line">		// todo: add</div><div class="line">	&#125;,</div><div class="line">	onDeleteItem: function () &#123;</div><div class="line">		// todo: delete</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这是一种快捷方式，其实内部原理就是store在创建的时候，调用了listenToMany方法。<br>注意：listenables这里可以是actions组成的数组，如：[actions1, actions2]，就相当于多调用几次listenToMany方法，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">this.listenToMany(actions1); </div><div class="line">this.listenToMany(actions2);</div></pre></td></tr></table></figure></p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>对于View，只需在React Component里的生命周期函数里，负责监听Store的变化，并及时通过调用setState（）方法更新UI即可，就像下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var myStore = Reflux.createStore(&#123;</div><div class="line">	init: function () &#123;</div><div class="line">		// init</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">class MyComponent extends React.Component &#123;</div><div class="line">	</div><div class="line">	componentDidMount() &#123;</div><div class="line">		this.unsubscribe = myStore.listen(this.onChange);</div><div class="line">	&#125;</div><div class="line">    componentWillUnmount: function() &#123;</div><div class="line">        this.unsubscribe(); // 注意：在组件销毁时，一定要解除监听</div><div class="line">    &#125;</div><div class="line">	onChange(data) &#123;</div><div class="line">		this.setState(data); // re-render</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述方式，是通过myStore.listen()来进行消息订阅的，而实际上，View本身并没有消息订阅的能力，所以Reflux提供了一个mixin，叫做Reflux.ListenerMixin。<br>它的实现是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports = _.extend(&#123;</div><div class="line">    componentWillUnmount: ListenerMethods.stopListeningToAll</div><div class="line">&#125;, ListenerMethods);</div></pre></td></tr></table></figure></p>
<p>作为React Component的一个mixin，它其实做了两件事情：<br>给View添加ListenerMethods集合里的方法，使View具备了消息订阅的能力。<br>在组件销毁componentWillUnmount生命周期方法里，对之前监听的Action自动解绑。<br>所以，上述代码可以简化为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import Reflux from &apos;reflux&apos;;</div><div class="line">import ReactMixin from &apos;react-mixin&apos;;</div><div class="line"></div><div class="line">class MyComponent extends React.Component &#123;</div><div class="line">	</div><div class="line">	componentDidMount() &#123;</div><div class="line">		this.listenTo(myStore, this.onChange); // View本身具备了订阅的能力</div><div class="line">	&#125;</div><div class="line">    componentWillUnmount: function() &#123;</div><div class="line">       // nothing 无需手动解除监听</div><div class="line">    &#125;</div><div class="line">	onChange(data) &#123;</div><div class="line">		this.setState(data); // re-render</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ES6 mixin写法</div><div class="line">ReactMixin.onClass(MyComponent, Reflux.ListenerMixin);</div></pre></td></tr></table></figure></p>
<p>然而还有更简单的写法，就是通过Reflux.connect()来写，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import Reflux from &apos;reflux&apos;;</div><div class="line">import ReactMixin from &apos;react-mixin&apos;;</div><div class="line"></div><div class="line">class MyComponent extends React.Component &#123;</div><div class="line">	</div><div class="line">	componentDidMount() &#123;</div><div class="line">		// nothing 无需手动监听</div><div class="line">	&#125;</div><div class="line">    componentWillUnmount: function() &#123;</div><div class="line">       // nothing 无需手动解除监听</div><div class="line">    &#125;</div><div class="line">	onChange(data) &#123;</div><div class="line">	   // noting 无需手动setState</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ES6 mixin写法</div><div class="line">ReactMixin.onClass(MyComponent, Reflux.connect(myStore));</div></pre></td></tr></table></figure></p>
<p>原理是这样的，React.connect(myStore)返回的一个mixin，这个mixin内部在做了类似下面的事情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">this.listenTo(myStore, (data) =&gt; &#123;</div><div class="line">	this.setState(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>所以，这才帮我们省去了手动监听，手动删除监听，还有手动触发UI更新这三步。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ps内容较多，请细心看完&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Flux作为一种应用架构（application architecture）或是设计模式（pattern），阐述的是单向数据流（a unidirectional data flow）的思想，并不是一个框架（framework）或者库（library）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
      <category term="reflux" scheme="http://html-js.site/tags/reflux/"/>
    
  </entry>
  
  <entry>
    <title>React组件生命周期过程说明</title>
    <link href="http://html-js.site/2017/03/10/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BF%87%E7%A8%8B%E8%AF%B4%E6%98%8E/"/>
    <id>http://html-js.site/2017/03/10/React组件生命周期过程说明/</id>
    <published>2017-03-10T05:44:13.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><h3 id="首次实例化"><a href="#首次实例化" class="headerlink" title="首次实例化"></a>首次实例化</h3><ul>
<li>getDefaultProps</li>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<a id="more"></a>
<h3 id="实例化完成后的更新"><a href="#实例化完成后的更新" class="headerlink" title="实例化完成后的更新"></a>实例化完成后的更新</h3><ul>
<li>getInitialState</li>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<h2 id="存在期"><a href="#存在期" class="headerlink" title="存在期"></a>存在期</h2><h3 id="组件已存在时的状态改变"><a href="#组件已存在时的状态改变" class="headerlink" title="组件已存在时的状态改变"></a>组件已存在时的状态改变</h3><ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<h2 id="销毁-amp-清理期"><a href="#销毁-amp-清理期" class="headerlink" title="销毁&amp;清理期"></a>销毁&amp;清理期</h2><ul>
<li>componentWillUnmount</li>
</ul>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>生命周期共提供了10个不同的API。</p>
<h3 id="1-getDefaultProps"><a href="#1-getDefaultProps" class="headerlink" title="1.getDefaultProps"></a>1.getDefaultProps</h3><p>作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。</p>
<h3 id="2-getInitialState"><a href="#2-getInitialState" class="headerlink" title="2.getInitialState"></a>2.getInitialState</h3><p>作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。</p>
<h3 id="3-componentWillMount"><a href="#3-componentWillMount" class="headerlink" title="3.componentWillMount"></a>3.componentWillMount</h3><p>在完成首次渲染之前调用，此时仍可以修改组件的state。</p>
<h3 id="4-render"><a href="#4-render" class="headerlink" title="4.render"></a>4.render</h3><p>必选的方法，创建虚拟DOM，该方法具有特殊的规则：</p>
<ul>
<li>只能通过this.props和this.state访问数据</li>
<li>可以返回null、false或任何React组件</li>
<li>只能出现一个顶级组件（不能返回数组）</li>
<li>不能改变组件的状态</li>
<li>不能修改DOM的输出</li>
</ul>
<h3 id="5-componentDidMount"><a href="#5-componentDidMount" class="headerlink" title="5.componentDidMount"></a>5.componentDidMount</h3><p>真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。</p>
<p><em>在服务端中，该方法不会被调用。</em></p>
<h3 id="6-componentWillReceiveProps"><a href="#6-componentWillReceiveProps" class="headerlink" title="6.componentWillReceiveProps"></a>6.componentWillReceiveProps</h3><p>组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps: function(nextProps) &#123;</div><div class="line">       if (nextProps.bool) &#123;</div><div class="line">           this.setState(&#123;</div><div class="line">               bool: true</div><div class="line">           &#125;);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h3 id="7-shouldComponentUpdate"><a href="#7-shouldComponentUpdate" class="headerlink" title="7.shouldComponentUpdate"></a>7.shouldComponentUpdate</h3><p>组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。<br><em>在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用</em></p>
<h3 id="8-componentWillUpdate"><a href="#8-componentWillUpdate" class="headerlink" title="8.componentWillUpdate"></a>8.componentWillUpdate</h3><p>接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</p>
<h3 id="9-componentDidUpdate"><a href="#9-componentDidUpdate" class="headerlink" title="9.componentDidUpdate"></a>9.componentDidUpdate</h3><p>完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。</p>
<h3 id="10-componentWillUnmount"><a href="#10-componentWillUnmount" class="headerlink" title="10.componentWillUnmount"></a>10.componentWillUnmount</h3><p>组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;实例化&quot;&gt;&lt;a href=&quot;#实例化&quot; class=&quot;headerlink&quot; title=&quot;实例化&quot;&gt;&lt;/a&gt;实例化&lt;/h2&gt;&lt;h3 id=&quot;首次实例化&quot;&gt;&lt;a href=&quot;#首次实例化&quot; class=&quot;headerlink&quot; title=&quot;首次实例化&quot;&gt;&lt;/a&gt;首次实例化&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;getDefaultProps&lt;/li&gt;
&lt;li&gt;getInitialState&lt;/li&gt;
&lt;li&gt;componentWillMount&lt;/li&gt;
&lt;li&gt;render&lt;/li&gt;
&lt;li&gt;componentDidMount&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端跨域整理</title>
    <link href="http://html-js.site/2017/02/14/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/"/>
    <id>http://html-js.site/2017/02/14/前端跨域整理/</id>
    <published>2017-02-14T08:18:34.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨域整理"><a href="#跨域整理" class="headerlink" title="跨域整理"></a>跨域整理</h2><h2 id="跨域资源共享-CORS"><a href="#跨域资源共享-CORS" class="headerlink" title="跨域资源共享 CORS"></a>跨域资源共享 CORS</h2><p>对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。<br><img src="/images/page/cors/1.png" alt=""><br>使用 CORS 跨域的时候其实和普通的 ajax 过程是一样的，只是浏览器在发现这是一个跨域请求的时候会自动帮我们处理一些事，比如验证等等，所以说只要服务端提供支持，前端是不需要做额外的事情的。</p>
<a id="more"></a>
<h2 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h2><p>CORS 的请求分两种，这也是浏览器为了安全做的一些处理，不同情况下浏览器执行的操作也是不一样的，主要分为两种请求，当然这一切我们是不需要做额外处理的，浏览器会自动处理的。</p>
<h2 id="简单请求（simple-request）"><a href="#简单请求（simple-request）" class="headerlink" title="简单请求（simple request）"></a>简单请求（simple request）</h2><p>只要同时满足以下两大条件，就属于简单请求。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1) 请求方法是以下三种方法中的一个：</div><div class="line">HEAD</div><div class="line">GET</div><div class="line">POST</div><div class="line">2）HTTP的头信息不超出以下几种字段：</div><div class="line">Accept</div><div class="line">Accept-Language</div><div class="line">Content-Language</div><div class="line">Last-Event-ID</div><div class="line">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</div></pre></td></tr></table></figure>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>对于简单的跨域请求，浏览器会自动在请求的头信息加上 Origin 字段，表示本次请求来自哪个源（协议 + 域名 + 端口），服务端会获取到这个值，然后判断是否同意这次请求并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 请求</div><div class="line">GET /cors HTTP/1.1</div><div class="line">Origin: https://api.qiutc.me</div><div class="line">Host: api.alice.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure></p>
<h3 id="1-服务端允许"><a href="#1-服务端允许" class="headerlink" title="1.服务端允许"></a>1.服务端允许</h3><p>如果服务端许可本次请求，就会在返回的头信息多出几个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 返回</div><div class="line">Access-Control-Allow-Origin: https://api.qiutc.me</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: Info</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure></p>
<p>这三个带有 <code>Access-Control</code> 开头的字段分别表示：</p>
<ul>
<li>Access-Control-Allow-Origin<br>必须。它的值是请求时Origin字段的值或者 <code>*</code>，表示接受任意域名的请求。</li>
<li>Access-Control-Allow-Credentials；<br>可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。<br>再需要发送cookie的时候还需要注意要在AJAX请求中打开withCredentials属性：<code>var xhr = new XMLHttpRequest(); xhr.withCredentials = true;</code><br><strong>需要注意的是</strong>，如果要发送Cookie，Access-Control-Allow-Origin就不能设为<code>*</code>，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</li>
<li>Access-Control-Expose-Headers<br>可选。CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，<code>getResponseHeader(&#39;Info&#39;)</code>可以返回Info字段的值。</li>
</ul>
<h3 id="2-服务端拒绝"><a href="#2-服务端拒绝" class="headerlink" title="2.服务端拒绝"></a>2.服务端拒绝</h3><p>当然我们为了防止接口被乱调用，需要限制源，对于不允许的源，服务端还是会返回一个正常的HTTP回应，但是不会带上 <code>Access-Control-Allow-Origin</code> 字段，浏览器发现这个跨域请求的返回头信息没有该字段，就会抛出一个错误，会被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调捕获到。<br><strong>这种错误无法通过 HTTP 状态码判断，因为回应的状态码有可能是200</strong></p>
<h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>除了简单请求以外的CORS请求。<br>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><h3 id="1）预检请求"><a href="#1）预检请求" class="headerlink" title="1）预检请求"></a>1）预检请求</h3><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>预检请求的发送请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OPTIONS /cors HTTP/1.1</div><div class="line">Origin: https://api.qiutc.me</div><div class="line">Access-Control-Request-Method: PUT</div><div class="line">Access-Control-Request-Headers: X-Custom-Header</div><div class="line">Host: api.qiutc.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure></p>
<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。<br>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>
<ul>
<li>Access-Control-Request-Method<br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li><p>Access-Control-Request-Headers<br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。<br>预检请求的返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</div><div class="line">Server: Apache/2.0.61 (Unix)</div><div class="line">Access-Control-Allow-Origin: https://api.qiutc.me</div><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Length: 0</div><div class="line">Keep-Alive: timeout=2, max=100</div><div class="line">Connection: Keep-Alive</div><div class="line">Content-Type: text/plain</div></pre></td></tr></table></figure>
</li>
<li><p>Access-Control-Allow-Methods<br>必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
</li>
<li>Access-Control-Allow-Headers<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li>
<li>Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</li>
</ul>
<h3 id="2）浏览器的正常请求和回应"><a href="#2）浏览器的正常请求和回应" class="headerlink" title="2）浏览器的正常请求和回应"></a>2）浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p>参考: <a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">《跨域资源共享 CORS 详解》:https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>sonp = json + padding<br>其实对于常用性来说，jsonp应该是使用最经常的一种跨域方式了，他不受浏览器兼容性的限制。但是他也有他的局限性，只能发送 GET 请求，需要服务端和前端规定好，写法丑陋。<br>它的原理在于浏览器请求 script 资源不受同源策略限制，并且请求到 script 资源后立即执行。<br>主要做法是这样的：</p>
<ul>
<li><p>在浏览器端：<br>首先全局注册一个callback回调函数，记住这个函数名字（比如：resolveJson），这个函数接受一个参数，参数是期望的到的服务端返回数据，函数的具体内容是处理这个数据。<br>然后动态生成一个 script 标签，src 为：请求资源的地址＋获取函数的字段名＋回调函数名称，这里的获取函数的字段名是要和服务端约定好的，是为了让服务端拿到回调函数名称。（如：<code>www.qiute.com?callbackName=resolveJson</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function resolveJosn(result) &#123;</div><div class="line">	console.log(result.name);</div><div class="line">&#125;</div><div class="line">var jsonpScript= document.createElement(&quot;script&quot;);</div><div class="line">jsonpScript.type = &quot;text/javascript&quot;;</div><div class="line">jsonpScript.src = &quot;https://www.qiute.com?callbackName=resolveJson&quot;;</div><div class="line">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(jsonpScript);</div></pre></td></tr></table></figure>
</li>
<li><p>服务端<br>在接受到浏览器端 script 的请求之后，从url的query的callbackName获取到回调函数的名字，例子中是<code>resolveJson</code>。<br>然后动态生成一段javascript片段去给这个函数传入参数执行这个函数。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resolveJson(&#123;name: &apos;qiutc&apos;&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>执行<br>服务端返回这个 script 之后，浏览器端获取到 script 资源，然后会立即执行这个 javascript，也就是上面那个片段。这样就能根据之前写好的回调函数处理这些数据了。</p>
</li>
</ul>
<p>在一些第三方库往往都会封装jsonp的操作，比如 jQuery 的<code>$.getJSON</code>。</p>
<h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><p>一个页面框架（iframe／frame）之间（父子或同辈），是能够获取到彼此的window对象的，但是这个 window 不能拿到方法和属性（尼玛这有什么用，甩脸）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 当前页面域名 https://blog.qiutc.me/a.html</div><div class="line">&lt;script&gt;</div><div class="line">function onLoad() &#123;</div><div class="line">	var iframe =document.getElementById(&apos;iframe&apos;);</div><div class="line">	var iframeWindow = iframe.contentWindow; // 这里可以获取 iframe 里面 window 对象，但是几乎没用</div><div class="line">	var doc = iframeWindow.document; // 获取不到</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe src=&quot;https://www.qiutc.me/b.html&quot; onload=&quot;onLoad()&quot;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p>
<p>这个时候，<code>document.domain</code>就可以派上用场了，我们只要把 <code>https://blog.qiutc.me/a.html</code> 和 <code>https://www.qiutc.me/b.html</code> 这两个页面的 <code>document.domain</code> 都设成相同的域名就可以了。<br>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致。<br>但要注意的是，<code>document.domain</code> 的设置是有限制的，我们只能把 <code>document.domain</code> 设置成自身或更高一级的父域，且主域必须相同。例如：<code>a.b.example.com</code> 中某个文档的 <code>document.domain</code> 可以设成<code>a.b.example.com</code>、<code>b.example.com、example.com</code>中的任意一个，但是不可以设成 <code>c.a.b.example.com</code>,因为这是当前域的子域，也不可以设成<code>baidu.com</code>,因为主域已经不相同了。<br>这样我们就可以通过js访问到iframe中的各种属性和对象了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 主页面：https://blog.qiutc.me/a.html</div><div class="line">&lt;script&gt;</div><div class="line">document.domain = &apos;qiutc.me&apos;;</div><div class="line">function onLoad() &#123;</div><div class="line">	var iframe =document.getElementById(&apos;iframe&apos;);</div><div class="line">	var iframeWindow = iframe.contentWindow; // 这里可以获取 iframe 里面 window 对象并且能得到方法和属性</div><div class="line">	var doc = iframeWindow.document; // 获取到</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe src=&quot;https://www.qiutc.me/b.html&quot; onload=&quot;onLoad()&quot;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// iframe 里面的页面</div><div class="line">&lt;script&gt;</div><div class="line">document.domain = &apos;qiutc.me&apos;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 <code>window.name</code> 的，每个页面对 <code>window.name</code> 都有读写的权限，<code>window.name</code> 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<br>比如有一个<code>www.qiutc.me/a.html</code>页面，需要通过a.html页面里的js来获取另一个位于不同域上的页面<code>www.qiutc.com/data.html</code>里的数据。<br><code>data.html</code>页面里的代码很简单，就是给当前的<code>window.name</code>设置一个<code>a.html</code>页面想要得到的数据值。<code>data.html</code>里的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">window.name = &apos;我是被期望得到的数据&apos;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>那么在 <code>a.html</code> 页面中，我们怎么把 <code>data.html</code> 页面载入进来呢？显然我们不能直接在 <code>a.html</code> 页面中通过改变 <code>window.location</code> 来载入<code>data.html</code>页面（这简直扯蛋）因为我们想要即使 <code>a.html</code>页面不跳转也能得到 <code>data.html</code> 里的数据。<br>答案就是在 <code>a.html</code> 页面中使用一个隐藏的 <code>iframe</code> 来充当一个中间人角色，由 <code>iframe</code> 去获取 <code>data.html</code> 的数据，然后 <code>a.html</code> 再去得到 <code>iframe</code> 获取到的数据。<br>充当中间人的 <code>iframe</code> 想要获取到<code>data.html</code>的通过<code>window.name</code>设置的数据，只需要把这个<code>iframe</code>的<code>src</code>设为<code>www.qiutc.com/data.html</code>就行了。然后<code>a.html</code>想要得到iframe所获取到的数据，也就是想要得到<code>iframe</code>的<code>window.name</code>的值，还必须把这个<code>iframe</code>的<code>src</code>设成跟<code>a.html</code>页面同一个域才行，不然根据前面讲的同源策略，<code>a.html</code>是不能访问到<code>iframe</code>里的<code>window.name</code>属性的。这就是整个跨域过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// a.html</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;title&gt;Document&lt;/title&gt;</div><div class="line">  &lt;script&gt;</div><div class="line">	function getData() &#123;</div><div class="line">		var iframe =document.getElementById(&apos;iframe&apos;);</div><div class="line">		iframe.onload = function() &#123;</div><div class="line">			var data = iframe.contentWindow.name; // 得到</div><div class="line">		&#125;</div><div class="line">		iframe.src = &apos;b.html&apos;;  // 这里b和a同源</div><div class="line">	&#125;</div><div class="line">  &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;iframe src=&quot;https://www.qiutc.com/data.html&quot; style=&quot;display:none&quot; onload=&quot;getData()&quot;&lt;/iframe&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h2 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h2><p><code>window.postMessage(message, targetOrigin)</code> 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。兼容性：<br><img src="/images/page/cors/2.png" alt=""><br>调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。<br>需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。<br>上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。在讨论第种方法的时候，我们说过，不同域的框架间是可以获取到对方的window对象的，虽然没什么用，但是有一个方法是可用的－<code>window.postMessage</code>。下面看一个简单的示例，有两个页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 主页面  blog.qiutc.com</div><div class="line">&lt;script&gt;</div><div class="line">function onLoad() &#123;</div><div class="line">	var iframe =document.getElementById(&apos;iframe&apos;);</div><div class="line">	var iframeWindow = iframe.contentWindow;</div><div class="line">	iframeWindow.postMessage(&quot;I&apos;m message from main page.&quot;);</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe src=&quot;https://www.qiutc.me/b.html&quot; onload=&quot;onLoad()&quot;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// b 页面</div><div class="line">&lt;script&gt;</div><div class="line">window.onmessage = function(e) &#123;</div><div class="line">	e = e || event;</div><div class="line">	console.log(e.data);</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="CSST-CSS-Text-Transformation"><a href="#CSST-CSS-Text-Transformation" class="headerlink" title="CSST (CSS Text Transformation)"></a>CSST (CSS Text Transformation)</h2><p>一种用 CSS 跨域传输文本的方案。<br>优点：相比 JSONP 更为安全，不需要执行跨站脚本。<br>缺点：没有 JSONP 适配广，CSST 依赖支持 CSS3 的浏览器。<br>原理：通过读取 CSS3 content 属性获取传送内容。<br>具体可以参考：<a href="https://github.com/zswang/csst" target="_blank" rel="external">CSST (CSS Text Transformation)</a></p>
<p>转载自： <a href="https://qiutc.me/post/cross-domain-collections.html" target="_blank" rel="external">https://qiutc.me/post/cross-domain-collections.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;跨域整理&quot;&gt;&lt;a href=&quot;#跨域整理&quot; class=&quot;headerlink&quot; title=&quot;跨域整理&quot;&gt;&lt;/a&gt;跨域整理&lt;/h2&gt;&lt;h2 id=&quot;跨域资源共享-CORS&quot;&gt;&lt;a href=&quot;#跨域资源共享-CORS&quot; class=&quot;headerlink&quot; title=&quot;跨域资源共享 CORS&quot;&gt;&lt;/a&gt;跨域资源共享 CORS&lt;/h2&gt;&lt;p&gt;对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。&lt;br&gt;它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。&lt;br&gt;首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。&lt;br&gt;&lt;img src=&quot;/images/page/cors/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;使用 CORS 跨域的时候其实和普通的 ajax 过程是一样的，只是浏览器在发现这是一个跨域请求的时候会自动帮我们处理一些事，比如验证等等，所以说只要服务端提供支持，前端是不需要做额外的事情的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android WebView调试</title>
    <link href="http://html-js.site/2017/02/08/Android-WebView%E8%B0%83%E8%AF%95/"/>
    <id>http://html-js.site/2017/02/08/Android-WebView调试/</id>
    <published>2017-02-08T08:59:21.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>Google DevTools支持在PC Chrome上检查、分析、调试Android设备或者模拟器上的WebView页面。</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1、PC"><a href="#1、PC" class="headerlink" title="1、PC"></a>1、PC</h3><p>a) 安装Chrome32以上版本。<br>b) 开启Chrome的USB检索功能：<br><br>   在Chrome中打开”chrome://inspect/#devices“，勾选”Discover USB devices“。<br><img src="/images/page/android-webview/1.png" alt=""></p>
<h3 id="2、Android手机（4-4及以上版本）-Android4-4模拟器"><a href="#2、Android手机（4-4及以上版本）-Android4-4模拟器" class="headerlink" title="2、Android手机（4.4及以上版本）/ Android4.4模拟器"></a>2、Android手机（4.4及以上版本）/ Android4.4模拟器</h3><p>a） 开启Debug:<br><br>    打开 “设置”à“开发选项”à“USB调试”。<br><img src="/images/page/android-webview/2.png" alt=""><br>注：一些手机默认隐藏了”开发选项“，需要进入”设置“à”关于手机“，然后连续点击”Android版本号“栏（大于等于7次），之后“设置“中将会出现”开发选项“。</p>
<h3 id="3、需要调试的目标Android-APP"><a href="#3、需要调试的目标Android-APP" class="headerlink" title="3、需要调试的目标Android APP"></a>3、需要调试的目标Android APP</h3><p>需要App中的WebView开启debug功能：<br><img src="/images/page/android-webview/3.png" alt=""><br>千牛Android App可以在运行时开启WebView的Debug功能：<br></p>
<p>进入“设置”à“关于千牛”,在如下界面点击千牛图标大于等于10次开启debug模式，开启后会有提示如下图：<br><img src="/images/page/android-webview/4.png" alt=""></p>
<h2 id="调试WebView页面"><a href="#调试WebView页面" class="headerlink" title="调试WebView页面"></a>调试WebView页面</h2><h3 id="1、通过USB线连接Android手机与PC。"><a href="#1、通过USB线连接Android手机与PC。" class="headerlink" title="1、通过USB线连接Android手机与PC。"></a>1、通过USB线连接Android手机与PC。</h3><p>如果出现”是否允许调试“的条框中，选择”确定“。<br><img src="/images/page/android-webview/5.png" alt=""></p>
<h3 id="2、调试Android-App中WebView页面："><a href="#2、调试Android-App中WebView页面：" class="headerlink" title="2、调试Android App中WebView页面："></a>2、调试Android App中WebView页面：</h3><p>在Android App中打开某个需要调试的WebView页面。然后在PC Chrome中打开”chrome://inspect“页面：<br><img src="/images/page/android-webview/6.png" alt=""><br>如图中列出的WebView实例，及其打开的页面信息。点击”inspect”打开页面调试窗口（注意：这步需要翻墙后才能打开,翻墙参考<a href="https://github.com/goagent/goagent）：" target="_blank" rel="external">https://github.com/goagent/goagent）：</a><br><img src="/images/page/android-webview/7.png" alt=""></p>
<p>FAQ:</p>
<ol>
<li>在PC Chrome”chrome://inspect“页面中看不到Android设备或者模拟器信息：</li>
<li>首先检查Android手机或者模拟器是否开起“Debug调试”，如果开启了还是不能展示，则需要检查驱动是否安装成功。</li>
<li>在PC Chrome”chrome://inspect“页面中看不到WebView页面信息：需要跟Android App人员确定获得的App是否开启WebView可调试。</li>
<li>在PC Chrome”chrome://inspect“页面中选择一个页面，点击“inspect”后打开的调试页面始终是空白：<strong>需要翻墙后再次打开</strong>。</li>
<li>更多详细资料可以参考：<a href="https://developer.chrome.com/devtools/docs/remote-debugging#install-adbplugin" target="_blank" rel="external">https://developer.chrome.com/devtools/docs/remote-debugging#install-adbplugin</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google DevTools支持在PC Chrome上检查、分析、调试Android设备或者模拟器上的WebView页面。&lt;/p&gt;
    
    </summary>
    
    
      <category term="手机调试" scheme="http://html-js.site/tags/%E6%89%8B%E6%9C%BA%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记1-Create React App</title>
    <link href="http://html-js.site/2017/01/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://html-js.site/2017/01/17/React学习笔记1/</id>
    <published>2017-01-17T06:37:57.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>React学习捷径：</p>
<blockquote>
<p>深入模式: React+ES6+WebPack+React Redux+Fetch+React Router+Immutable+React Native+NodeJs<br>正常模式: React+ES6+WebPack+React Redux<br>简易模式: React+ES6+WebPack+React Flux(React官方Flux库)</p>
</blockquote>
<p>在看了一些react的文档以及以下新手入门文档之后，就想动手写个项目练练手，虽然知道要用react、react-router等，但是项目的脚手架如果自己写的话对于新手来说基本不可能，所以网上找了一款脚手架：<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">Create React App</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm install -g create-react-app</div><div class="line"></div><div class="line">create-react-app my-app</div><div class="line">cd my-app/</div><div class="line">npm start</div></pre></td></tr></table></figure>
<p>然后访问 <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> 就可以看到初始页面了哦</p>
<p><img src="/images/page/react/1.png" alt=""></p>
<p>当然这个只是包含了react基础的npm包，以及静态服务，热插拔，其他如果要用的话可以自己install相关的插件。<br><a id="more"></a></p>
<ul><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases" target="_blank" rel="external">Updating to New Releases</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#folder-structure" target="_blank" rel="external">Folder Structure</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#available-scripts" target="_blank" rel="external">Available Scripts</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#syntax-highlighting-in-the-editor" target="_blank" rel="external">Syntax Highlighting in the Editor</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#displaying-lint-output-in-the-editor" target="_blank" rel="external">Displaying Lint Output in the Editor</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#changing-the-page-title" target="_blank" rel="external">Changing the Page <code>&lt;title&gt;</code></a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#installing-a-dependency" target="_blank" rel="external">Installing a Dependency</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#importing-a-component" target="_blank" rel="external">Importing a Component</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-a-stylesheet" target="_blank" rel="external">Adding a Stylesheet</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#post-processing-css" target="_blank" rel="external">Post-Processing CSS</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-images-and-fonts" target="_blank" rel="external">Adding Images and Fonts</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#using-the-public-folder" target="_blank" rel="external">Using the <code>public</code> Folder</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#using-global-variables" target="_blank" rel="external">Using Global Variables</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-bootstrap" target="_blank" rel="external">Adding Bootstrap</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-flow" target="_blank" rel="external">Adding Flow</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables" target="_blank" rel="external">Adding Custom Environment Variables</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#can-i-use-decorators" target="_blank" rel="external">Can I Use Decorators?</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#integrating-with-a-node-backend" target="_blank" rel="external">Integrating with a Node Backend</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#proxying-api-requests-in-development" target="_blank" rel="external">Proxying API Requests in Development</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#using-https-in-development" target="_blank" rel="external">Using HTTPS in Development</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#generating-dynamic-meta-tags-on-the-server" target="_blank" rel="external">Generating Dynamic <code>&lt;meta&gt;</code> Tags on the Server</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#running-tests" target="_blank" rel="external">Running Tests</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#developing-components-in-isolation" target="_blank" rel="external">Developing Components in Isolation</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#making-a-progressive-web-app" target="_blank" rel="external">Making a Progressive Web App</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#deployment" target="_blank" rel="external">Deployment</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#troubleshooting" target="_blank" rel="external">Troubleshooting</a></li><br></ul>

<blockquote>
<p>好了，赶紧开启我们的react之旅吧~</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React学习捷径：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深入模式: React+ES6+WebPack+React Redux+Fetch+React Router+Immutable+React Native+NodeJs&lt;br&gt;正常模式: React+ES6+WebPack+React Redux&lt;br&gt;简易模式: React+ES6+WebPack+React Flux(React官方Flux库)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在看了一些react的文档以及以下新手入门文档之后，就想动手写个项目练练手，虽然知道要用react、react-router等，但是项目的脚手架如果自己写的话对于新手来说基本不可能，所以网上找了一款脚手架：&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Create React App&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install -g create-react-app&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;create-react-app my-app&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cd my-app/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm start&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后访问 &lt;a href=&quot;http://localhost:3000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://localhost:3000&lt;/a&gt; 就可以看到初始页面了哦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/page/react/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然这个只是包含了react基础的npm包，以及静态服务，热插拔，其他如果要用的话可以自己install相关的插件。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>package.json</title>
    <link href="http://html-js.site/2016/11/14/package-json/"/>
    <id>http://html-js.site/2016/11/14/package-json/</id>
    <published>2016-11-14T07:05:26.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直没好好看过（看过忘了）package.json，然后各种项目本地运行的命令又很多，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">node index</div><div class="line">node server index</div><div class="line">npm run dev</div><div class="line">webpack --progress --colors</div><div class="line">webpack-dev-server --progress --colors</div></pre></td></tr></table></figure></p>
<p>这些命令很多，所以就研究了下package.json</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每个项目的根目录下面，一般都有一个<code>package.json</code>文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。<code>npm install</code>命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p>
<p>下面是一个最简单的<code>package.json</code>文件，只定义两项元数据：项目名称和项目版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot; : &quot;xxx&quot;,</div><div class="line">  &quot;version&quot; : &quot;0.0.0&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码说明，<code>package.json</code>文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如<code>name</code>就是项目名称，<code>version</code>是版本（遵守“大版本.次要版本.小版本”的格式）。</p>
<a id="more"></a>
<p>下面是一个更完整的package.json文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&quot;name&quot;: &quot;Hello World&quot;,</div><div class="line">	&quot;version&quot;: &quot;0.0.1&quot;,</div><div class="line">	&quot;author&quot;: &quot;张三&quot;,</div><div class="line">	&quot;description&quot;: &quot;第一个node.js程序&quot;,</div><div class="line">	&quot;keywords&quot;:[&quot;node.js&quot;,&quot;javascript&quot;],</div><div class="line">	&quot;repository&quot;: &#123;</div><div class="line">		&quot;type&quot;: &quot;git&quot;,</div><div class="line">		&quot;url&quot;: &quot;https://path/to/url&quot;</div><div class="line">	&#125;,</div><div class="line">	&quot;license&quot;:&quot;MIT&quot;,</div><div class="line">	&quot;engines&quot;: &#123;&quot;node&quot;: &quot;0.10.x&quot;&#125;,</div><div class="line">	&quot;bugs&quot;:&#123;&quot;url&quot;:&quot;http://path/to/bug&quot;,&quot;email&quot;:&quot;bug@example.com&quot;&#125;,</div><div class="line">	&quot;contributors&quot;:[&#123;&quot;name&quot;:&quot;李四&quot;,&quot;email&quot;:&quot;lisi@example.com&quot;&#125;],</div><div class="line">	&quot;scripts&quot;: &#123;</div><div class="line">		&quot;start&quot;: &quot;node index.js&quot;</div><div class="line">	&#125;,</div><div class="line">	&quot;dependencies&quot;: &#123;</div><div class="line">		&quot;express&quot;: &quot;latest&quot;,</div><div class="line">		&quot;mongoose&quot;: &quot;~3.8.3&quot;,</div><div class="line">		&quot;handlebars-runtime&quot;: &quot;~1.0.12&quot;,</div><div class="line">		&quot;express3-handlebars&quot;: &quot;~0.5.0&quot;,</div><div class="line">		&quot;MD5&quot;: &quot;~1.2.0&quot;</div><div class="line">	&#125;,</div><div class="line">	&quot;devDependencies&quot;: &#123;</div><div class="line">		&quot;bower&quot;: &quot;~1.2.8&quot;,</div><div class="line">		&quot;grunt&quot;: &quot;~0.4.1&quot;,</div><div class="line">		&quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,</div><div class="line">		&quot;grunt-contrib-jshint&quot;: &quot;~0.7.2&quot;,</div><div class="line">		&quot;grunt-contrib-uglify&quot;: &quot;~0.2.7&quot;,</div><div class="line">		&quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;,</div><div class="line">		&quot;browserify&quot;: &quot;2.36.1&quot;,</div><div class="line">		&quot;grunt-browserify&quot;: &quot;~1.3.0&quot;,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面详细解释<code>package.json</code>文件的各个字段。</p>
<h2 id="scripts字段"><a href="#scripts字段" class="headerlink" title="scripts字段"></a>scripts字段</h2><p><code>scripts</code>指定了运行脚本命令的npm命令行缩写，比如start指定了运行<code>npm run start</code>时，所要执行的命令。</p>
<p>下面的设置指定了<code>npm run preinstall</code>、<code>npm run postinstall</code>、<code>npm run start</code>、<code>npm run test</code>时，所要执行的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;preinstall&quot;: &quot;echo here it comes!&quot;,</div><div class="line">    &quot;postinstall&quot;: &quot;echo there it goes!&quot;,</div><div class="line">    &quot;start&quot;: &quot;node index.js&quot;,</div><div class="line">    &quot;test&quot;: &quot;tap test/*.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dependencies字段，devDependencies字段"><a href="#dependencies字段，devDependencies字段" class="headerlink" title="dependencies字段，devDependencies字段"></a>dependencies字段，devDependencies字段</h2><p><code>dependencies</code>字段指定了项目运行所依赖的模块，<code>devDependencies</code>指定项目开发所需要的模块。</p>
<p>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;browserify&quot;: &quot;~13.0.0&quot;,</div><div class="line">    &quot;karma-browserify&quot;: &quot;~5.0.1&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的版本可以加上各种限定，主要有以下几种：</p>
<blockquote>
<ul>
<li><strong>指定版本</strong>：比如<strong>1.2.2</strong>，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。</li>
<li><strong>波浪号（tilde）+指定版本</strong>：比如<strong>~1.2.2</strong>，表示安装<strong>1.2.x</strong>的最新版本（不低于<strong>1.2.2</strong>），但是不安装<strong>1.3.x</strong>，也就是说安装时不改变大版本号和次要版本号。</li>
<li><strong>插入号（caret）+指定版本</strong>：比如<strong>ˆ1.2.2</strong>，表示安装<strong>1.x.x</strong>的最新版本（不低于<strong>1.2.2</strong>），但是不安装<strong>2.x.x</strong>，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为<strong>0</strong>，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。</li>
<li><strong>latest</strong>：安装最新版本。</li>
</ul>
</blockquote>
<p><code>package.json</code>文件可以手工编写，也可以使用<code>npm init</code>命令自动生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm init</div></pre></td></tr></table></figure></p>
<p>这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的<code>package.json</code>文件。所有问题之中，只有项目名称（<strong>name</strong>）和项目版本（<strong>version</strong>）是必填的，其他都是选填的。</p>
<p>有了<code>package.json</code>文件，直接使用<code>npm install</code>命令，就会在当前目录中安装所需要的模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install</div></pre></td></tr></table></figure></p>
<p>如果一个模块不在<code>package.json</code>文件之中，可以单独安装这个模块，并使用相应的参数，将其写入<code>package.json</code>文件之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install express --save</div><div class="line">$ npm install express --save-dev</div></pre></td></tr></table></figure></p>
<p>上面代码表示单独安装<code>express</code>模块，<code>--save</code>参数表示将该模块写入<code>dependencies</code>属性，<code>--save-dev</code>表示将该模块写入<code>devDependencies</code>属性。</p>
<h2 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h2><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。</p>
<p>大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>
<p>最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。</p>
<p><code>peerDependencies</code>字段，就是用来供插件指定其所需要的主工具的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;chai-as-promised&quot;,</div><div class="line">  &quot;peerDependencies&quot;: &#123;</div><div class="line">    &quot;chai&quot;: &quot;1.x&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码指定，安装<code>chai-as-promised</code>模块时，主程序<code>chai</code>必须一起安装，而且<code>chai</code>的版本必须是<code>1.x</code>。如果你的项目指定的依赖是<code>chai</code>的<strong>2.0</strong>版本，就会报错。</p>
<p>注意，从<strong>npm 3.0</strong>版开始，<code>peerDependencies</code>不再会默认安装了。</p>
<h2 id="bin字段"><a href="#bin字段" class="headerlink" title="bin字段"></a>bin字段</h2><p>bin项用来指定各个内部命令对应的可执行文件的位置.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;bin&quot;: &#123;</div><div class="line">  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码指定，<strong>someTool</strong> 命令对应的可执行文件为 <strong>bin</strong> 子目录下的 <strong>someTool.js</strong>。<strong>Npm</strong>会寻找这个文件，在<code>node_modules/.bin/</code>目录下建立符号链接。在上面的例子中，<code>someTool.js</code>会建立符号链接<code>npm_modules/.bin/someTool</code>。由于<code>node_modules/.bin/</code>目录会在运行时加入系统的<strong>PATH</strong>变量，因此在运行<strong>npm</strong>时，就可以不带路径，直接通过命令来调用这些脚本。</p>
<p>因此，像下面这样的写法可以采用简写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scripts: &#123;  </div><div class="line">  start: &apos;./node_modules/someTool/someTool.js build&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 简写为</div><div class="line"></div><div class="line">scripts: &#123;  </div><div class="line">  start: &apos;someTool build&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所有<code>node_modules/.bin/</code>目录下的命令，都可以用<code>npm run [命令]</code>的格式运行。在命令行下，键入<code>npm run</code>，然后按tab键，就会显示所有可以使用的命令。</p>
<h2 id="main字段"><a href="#main字段" class="headerlink" title="main字段"></a>main字段</h2><p><code>main</code>字段指定了加载的入口文件，<code>require(&#39;moduleName&#39;)</code>就会加载这个文件。这个字段的默认值是模块根目录下面的<code>index.js</code>。</p>
<h2 id="config字段"><a href="#config字段" class="headerlink" title="config字段."></a>config字段.</h2><p><strong>config</strong>字段用于向环境变量输出值。</p>
<p>下面是一个<strong>package.json</strong>文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot; : &quot;foo&quot;,</div><div class="line">  &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;,</div><div class="line">  &quot;scripts&quot; : &#123; &quot;start&quot; : &quot;node server.js&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，在<code>server.js</code>脚本就可以引用<strong>config</strong>字段的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.createServer(...).listen(process.env.npm_package_config_port)</div></pre></td></tr></table></figure></p>
<p>用户可以改变这个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm config set foo:port 80</div></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="browser字段"><a href="#browser字段" class="headerlink" title="browser字段"></a>browser字段</h3><p><strong>browser</strong>指定该模板供浏览器使用的版本。<strong>Browserify</strong>这样的浏览器打包工具，通过它就知道该打包那个文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;browser&quot;: &#123;</div><div class="line">  &quot;tipso&quot;: &quot;./node_modules/tipso/src/tipso.js&quot;</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="engines字段"><a href="#engines字段" class="headerlink" title="engines字段"></a>engines字段</h3><p><strong>engines</strong>指明了该项目所需要的<strong>node.js</strong>版本。</p>
<h3 id="man字段"><a href="#man字段" class="headerlink" title="man字段"></a>man字段</h3><p><strong>man</strong>用来指定当前模块的<strong>man</strong>文档的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;man&quot; :[ &quot;./doc/calc.1&quot; ]</div></pre></td></tr></table></figure></p>
<h3 id="preferGlobal字段"><a href="#preferGlobal字段" class="headerlink" title="preferGlobal字段"></a>preferGlobal字段</h3><p><strong>preferGlobal</strong>的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用<strong>–global</strong>参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>
<h3 id="style字段"><a href="#style字段" class="headerlink" title="style字段"></a>style字段</h3><p><strong>style</strong>指定供浏览器使用时，样式文件所在的位置。样式文件打包工具<strong>parcelify</strong>，通过它知道样式文件的打包位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;style&quot;: [</div><div class="line">  &quot;./node_modules/tipso/src/tipso.css&quot;</div><div class="line">]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直没好好看过（看过忘了）package.json，然后各种项目本地运行的命令又很多，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;node index&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node server index&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm run dev&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webpack --progress --colors&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webpack-dev-server --progress --colors&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这些命令很多，所以就研究了下package.json&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;每个项目的根目录下面，一般都有一个&lt;code&gt;package.json&lt;/code&gt;文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。&lt;code&gt;npm install&lt;/code&gt;命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。&lt;/p&gt;
&lt;p&gt;下面是一个最简单的&lt;code&gt;package.json&lt;/code&gt;文件，只定义两项元数据：项目名称和项目版本。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;quot;name&amp;quot; : &amp;quot;xxx&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;quot;version&amp;quot; : &amp;quot;0.0.0&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面代码说明，&lt;code&gt;package.json&lt;/code&gt;文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如&lt;code&gt;name&lt;/code&gt;就是项目名称，&lt;code&gt;version&lt;/code&gt;是版本（遵守“大版本.次要版本.小版本”的格式）。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式六大原则之单一职责原则</title>
    <link href="http://html-js.site/2016/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://html-js.site/2016/11/11/设计模式六大原则之单一职责原则/</id>
    <published>2016-11-11T06:01:47.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>此原则的核心就是解耦和增强内聚性。</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个方法只负责一项职责</p>
<p>其实很好理解，每个方法只有单一的功能，这样就不会相互影响，修改这个方法也就不会影响到其他的方法</p>
<p>说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。</p>
<h2 id="遵循单一职责原的优点"><a href="#遵循单一职责原的优点" class="headerlink" title="遵循单一职责原的优点"></a>遵循单一职责原的优点</h2><ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<blockquote>
<p>tips：请尽量遵循这一原则，不要为了偷懒而把一些简单的功能写到一个方法里面。因为未来可能会有一些需求或者什么，加点功能或修改一点功能，最终这个很简单的方法就会变得臃肿并且很难着手修改，修改也可能会影响到其他地方。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此原则的核心就是解耦和增强内聚性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;一个方法只负责一项职责&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
</feed>

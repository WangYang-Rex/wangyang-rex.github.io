<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端-洋仔</title>
  <subtitle>专注于前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://html-js.site/"/>
  <updated>2017-11-14T05:54:22.000Z</updated>
  <id>http://html-js.site/</id>
  
  <author>
    <name>wangyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Router 使用教程</title>
    <link href="http://html-js.site/2017/11/14/React-Router-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://html-js.site/2017/11/14/React-Router-使用教程/</id>
    <published>2017-11-14T03:38:16.000Z</published>
    <updated>2017-11-14T05:54:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>真正学会 <a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a> 是一个漫长的过程。<br><img src="/images/page/reactRouter/03.jpg" alt=""><br>你会发现，它不是一个库，也不是一个框架，而是一个庞大的体系。想要发挥它的威力，整个技术栈都要配合它改造。你要学习一整套解决方案，从后端到前端，都是全新的做法。<br><img src="/images/page/reactRouter/04.png" alt=""><br>举例来说，React 不使用 HTML，而使用 JSX 。它打算抛弃 DOM，要求开发者不要使用任何 DOM 方法。它甚至还抛弃了 SQL ，自己发明了一套查询语言 GraphQL 。当然，这些你都可以不用，React 照样运行，但是就发挥不出它的最大威力。<br>这样说吧，你只要用了 React，就会发现合理的选择就是，采用它的整个技术栈。<br>本文介绍 React 体系的一个重要部分：路由库<code>[React-Router](https://github.com/reactjs/react-router)</code>。它是官方维护的，事实上也是唯一可选的路由库。它通过管理 URL，实现组件的切换和状态的变化，开发复杂的应用几乎肯定会用到。<br><img src="/images/page/reactRouter/05.png" alt=""><br>（[说明] 本文写作时，React-router 是 2.x 版，本文的内容只适合这个版本，与最新的 4.x 版不兼容。目前，官方同时维护 2.x 和 4.x 两个版本，所以前者依然可以用在项目中。2017年3月）</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>React Router 安装命令如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -S react-router</div></pre></td></tr></table></figure></p>
<p>使用时，路由器<code>Router</code>就是React的一个组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line">render(&lt;Router/&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>));</div></pre></td></tr></table></figure></p>
<p><code>Router</code>组件本身只是一个容器，真正的路由要通过<code>Route</code>组件定义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Router, Route, hashHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line"></div><div class="line">render((</div><div class="line">  &lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;/&gt;</div><div class="line">  &lt;/Router&gt;</div><div class="line">), document.getElementById('app'));</div></pre></td></tr></table></figure></p>
<p>上面代码中，用户访问根路由<code>/</code>（比如<code>http://www.example.com/</code>），组件<code>APP</code>就会加载到<code>document.getElementById(&#39;app&#39;)</code>。<br>你可能还注意到，<code>Router</code>组件有一个参数<code>history</code>，它的值<code>hashHistory</code>表示，路由的切换由URL的<code>hash</code>变化决定，即<code>URL</code>的<code>#</code>部分发生变化。举例来说，用户访问<code>http://www.example.com/</code>，实际会看到的是<code>http://www.example.com/#/</code>。</p>
<p><code>Route</code>组件定义了URL路径与组件的对应关系。你可以同时使用多个<code>Route</code>组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">  &lt;Route path="/" component=&#123;App&#125;/&gt;</div><div class="line">  &lt;Route path="/repos" component=&#123;Repos&#125;/&gt;</div><div class="line">  &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，用户访问<code>/repos</code>（比如<code>http://localhost:8080/#/repos</code>）时，加载<code>Repos</code>组件；访问<code>/about</code>（<code>http://localhost:8080/#/about</code>）时，加载<code>About</code>组件。<br><a id="more"></a></p>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p><code>Route</code>组件还可以嵌套。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;hashHistory&#125;&gt;</div><div class="line">  &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">    &lt;Route path="/repos" component=&#123;Repos&#125;/&gt;</div><div class="line">    &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">  &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，用户访问<code>/repos</code>时，会先加载<code>App</code>组件，然后在它的内部再加载<code>Repos</code>组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;App&gt;</div><div class="line">  &lt;Repos/&gt;</div><div class="line">&lt;<span class="regexp">/App&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>App</code>组件要写成下面的样子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;div&gt;</div><div class="line">      &#123;this.props.children&#125;</div><div class="line">    &lt;/div&gt;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>App</code>组件的<code>this.props.children</code>属性就是子组件。<br>子路由也可以不写在<code>Router</code>组件里面，单独传入<code>Router</code>组件的<code>routes</code>属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> routes = &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">  &lt;Route path="/repos" component=&#123;Repos&#125;/&gt;</div><div class="line">  &lt;Route path="/about" component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Route&gt;;</div><div class="line"></div><div class="line">&lt;Router routes=&#123;routes&#125; history=&#123;browserHistory&#125;/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="path-属性"><a href="#path-属性" class="headerlink" title="path 属性"></a>path 属性</h3><p><code>Route</code>组件的<code>path</code>属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件。<br>请看下面的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"inbox"</span> component=&#123;Inbox&#125;&gt;</div><div class="line">   &lt;Route path="messages/:id" component=&#123;Message&#125; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，当用户访问<code>/inbox/messages/:id</code>时，会加载下面的组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Inbox&gt;</div><div class="line">  &lt;Message/&gt;</div><div class="line">&lt;<span class="regexp">/Inbox&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果省略外层<code>Route</code>的<code>path</code>参数，写成下面的样子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Route component=&#123;Inbox&#125;&gt;</div><div class="line">  &lt;Route path="inbox/messages/:id" component=&#123;Message&#125; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p>现在用户访问<code>/inbox/messages/:id</code>时，组件加载还是原来的样子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Inbox&gt;</div><div class="line">  &lt;Message/&gt;</div><div class="line">&lt;<span class="regexp">/Inbox&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p><code>path</code>属性可以使用通配符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"/hello/:name"</span>&gt;</div><div class="line"><span class="comment">// 匹配 /hello/michael</span></div><div class="line"><span class="comment">// 匹配 /hello/ryan</span></div><div class="line"></div><div class="line">&lt;Route path=<span class="string">"/hello(/:name)"</span>&gt;</div><div class="line"><span class="comment">// 匹配 /hello</span></div><div class="line"><span class="comment">// 匹配 /hello/michael</span></div><div class="line"><span class="comment">// 匹配 /hello/ryan</span></div><div class="line"></div><div class="line">&lt;Route path=<span class="string">"/files/*.*"</span>&gt;</div><div class="line"><span class="comment">// 匹配 /files/hello.jpg</span></div><div class="line"><span class="comment">// 匹配 /files/hello.html</span></div><div class="line"></div><div class="line">&lt;Route path=<span class="string">"/files/*"</span>&gt;</div><div class="line"><span class="comment">// 匹配 /files/ </span></div><div class="line"><span class="comment">// 匹配 /files/a</span></div><div class="line"><span class="comment">// 匹配 /files/a/b</span></div><div class="line"></div><div class="line">&lt;Route path=<span class="string">"/**/*.jpg"</span>&gt;</div><div class="line"><span class="comment">// 匹配 /files/hello.jpg</span></div><div class="line"><span class="comment">// 匹配 /files/path/to/file.jpg</span></div></pre></td></tr></table></figure></p>
<p>通配符的规则如下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">（1）:paramName</div><div class="line">:paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出。</div><div class="line">（2）()</div><div class="line">()表示URL的这个部分是可选的。</div><div class="line">（3）*</div><div class="line">*匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</div><div class="line">（4） **</div><div class="line">** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式。</div></pre></td></tr></table></figure></p>
<p><code>path</code>属性也可以使用相对路径（不以<code>/</code>开头），匹配时就会相对于父组件的路径，可以参考上一节的例子。嵌套路由如果想摆脱这个规则，可以使用绝对路由。<br>路由匹配规则是从上到下执行，一旦发现匹配，就不再其余的规则了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"/comments"</span> ... /&gt;</div><div class="line">&lt;Route path="/comments" ... /&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，路径<code>/comments</code>同时匹配两个规则，第二个规则不会生效。<br>设置路径参数时，需要特别小心这一点。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Router&gt;</div><div class="line">  &lt;Route path="/:userName/:id" component=&#123;UserPage&#125;/&gt;</div><div class="line">  &lt;Route path="/about/me" component=&#123;About&#125;/&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，用户访问<code>/about/me</code>时，不会触发第二个路由规则，因为它会匹配<code>/:userName/:id</code>这个规则。因此，带参数的路径一般要写在路由规则的底部。</p>
<p>此外，<code>URL</code>的查询字符串<code>/foo?bar=baz</code>，可以用<code>this.props.location.query.bar</code>获取。</p>
<h3 id="IndexRoute组件"><a href="#IndexRoute组件" class="headerlink" title="IndexRoute组件"></a>IndexRoute组件</h3><p>下面的例子，你会不会觉得有一点问题？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Router&gt;</div><div class="line">  &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">    &lt;Route path="accounts" component=&#123;Accounts&#125;/&gt;</div><div class="line">    &lt;Route path="statements" component=&#123;Statements&#125;/&gt;</div><div class="line">  &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，访问根路径<code>/</code>，不会加载任何子组件。也就是说，<code>App</code>组件的<code>this.props.children</code>，这时是<code>undefined</code>。<br>因此，通常会采用<code>{this.props.children || &lt;Home/&gt;}</code>这样的写法。这时，<code>Home</code>明明是<code>Accounts</code>和<code>Statements</code>的同级组件，却没有写在<code>Route</code>中。<br><code>IndexRoute</code>就是解决这个问题，显式指定<code>Home</code>是根路由的子组件，即指定默认情况下加载的子组件。你可以把<code>IndexRoute</code>想象成某个路径的<code>index.html</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Router&gt;</div><div class="line">  &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</div><div class="line">    &lt;Route path="accounts" component=&#123;Accounts&#125;/&gt;</div><div class="line">    &lt;Route path="statements" component=&#123;Statements&#125;/&gt;</div><div class="line">  &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<p>现在，用户访问<code>/</code>的时候，加载的组件结构如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;App&gt;</div><div class="line">  &lt;Home/&gt;</div><div class="line">&lt;<span class="regexp">/App&gt;</span></div></pre></td></tr></table></figure></p>
<p>这种组件结构就很清晰了：<code>App</code>只包含下级组件的共有元素，本身的展示内容则由<code>Home</code>组件定义。这样有利于代码分离，也有利于使用<code>React Router</code>提供的各种<code>API</code>。<br>注意，<code>IndexRoute</code>组件没有路径参数<code>path</code>。</p>
<h3 id="Redirect-组件"><a href="#Redirect-组件" class="headerlink" title="Redirect 组件"></a>Redirect 组件</h3><p><code>&lt;Redirect&gt;</code>组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"inbox"</span> component=&#123;Inbox&#125;&gt;</div><div class="line">  &#123;<span class="comment">/* 从 /inbox/messages/:id 跳转到 /messages/:id */</span>&#125;</div><div class="line">  ＜Redirect <span class="keyword">from</span>=<span class="string">"messages/:id"</span> to=<span class="string">"/messages/:id"</span> /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p>现在访问<code>/inbox/messages/5</code>，会自动跳转到<code>/messages/5</code>。</p>
<h3 id="IndexRedirect-组件"><a href="#IndexRedirect-组件" class="headerlink" title="IndexRedirect 组件"></a>IndexRedirect 组件</h3><p><code>IndexRedirect</code>组件用于访问根路由的时候，将用户重定向到某个子组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</div><div class="line">  ＜IndexRedirect to=<span class="string">"/welcome"</span> /&gt;</div><div class="line">  &lt;Route path="welcome" component=&#123;Welcome&#125; /&gt;</div><div class="line">  &lt;Route path="about" component=&#123;About&#125; /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，用户访问根路径时，将自动重定向到子组件<code>welcome</code>。</p>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p><code>Link</code>组件用于取代<code>&lt;a&gt;</code>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<code>&lt;a&gt;</code>元素的<code>React</code> 版本，可以接收<code>Router</code>的状态。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">  <span class="keyword">return</span> &lt;div&gt;</div><div class="line">    &lt;ul role="nav"&gt;</div><div class="line">      &lt;li&gt;&lt;Link to="/about"&gt;About&lt;/Link&gt;&lt;/li&gt;</div><div class="line">      &lt;li&gt;&lt;Link to="/repos"&gt;Repos&lt;/Link&gt;&lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果希望当前的路由与其他路由有不同样式，这时可以使用<code>Link</code>组件的<code>activeStyle</code>属性。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Link to="/about" activeStyle=&#123;&#123;color: 'red'&#125;&#125;&gt;About&lt;/Link&gt;</div><div class="line">&lt;Link to="/repos" activeStyle=&#123;&#123;color: 'red'&#125;&#125;&gt;Repos&lt;/Link&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，当前页面的链接会红色显示。<br>另一种做法是，使用<code>activeClassName</code>指定当前路由的<code>Class</code>。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Link to="/about" activeClassName="active"&gt;About&lt;/Link&gt;</div><div class="line">&lt;Link to="/repos" activeClassName="active"&gt;Repos&lt;/Link&gt;</div></pre></td></tr></table></figure></p>
<p>上面代码中，当前页面的链接的<code>class</code>会包含<code>active</code>。<br>在<code>Router</code>组件之外，导航到路由页面，可以使用浏览器的<code>History API</code>，像下面这样写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div><div class="line">browserHistory.push(<span class="string">'/some/path'</span>);</div></pre></td></tr></table></figure></p>
<h3 id="IndexLink"><a href="#IndexLink" class="headerlink" title="IndexLink"></a>IndexLink</h3><p>如果链接到根路由<code>/</code>，不要使用<code>Link</code>组件，而要使用<code>IndexLink</code>组件。<br>这是因为对于根路由来说，<code>activeStyle</code>和<code>activeClassName</code>会失效，或者说总是生效，因为/会匹配任何子路由。而<code>IndexLink</code>组件会使用路径的精确匹配。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;IndexLink to=<span class="string">"/"</span> activeClassName=<span class="string">"active"</span>&gt;</div><div class="line">  Home</div><div class="line">&lt;<span class="regexp">/IndexLink&gt;</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，根路由只会在精确匹配时，才具有<code>activeClassName</code>。<br>另一种方法是使用<code>Link</code>组件的<code>onlyActiveOnIndex</code>属性，也能达到同样效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Link to=<span class="string">"/"</span> activeClassName=<span class="string">"active"</span> onlyActiveOnIndex=&#123;<span class="literal">true</span>&#125;&gt;</div><div class="line">  Home</div><div class="line">&lt;<span class="regexp">/Link&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="histroy-属性"><a href="#histroy-属性" class="headerlink" title="histroy 属性"></a>histroy 属性</h3><p><code>Router</code>组件的<code>history</code>属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供<code>React Router</code> 匹配。<br><code>history</code>属性，一共可以设置三种值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">browserHistory</div><div class="line">hashHistory</div><div class="line">createMemoryHistory</div></pre></td></tr></table></figure></p>
<p>如果设为<code>hashHistory</code>，路由将通过<code>URL</code>的<code>hash</code>部分（<code>#</code>）切换，<code>URL</code>的形式类似<code>example.com/#/some/path</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; hashHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></div><div class="line"></div><div class="line">render(</div><div class="line">  &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt;,</div><div class="line">  document.getElementById('app')</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>如果设为<code>browserHistory</code>，浏览器的路由就不再通过<code>Hash</code>完成了，而显示正常的路径<code>example.com/some/path</code>，背后调用的是浏览器的<code>History API</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></div><div class="line"></div><div class="line">render(</div><div class="line">  &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;,</div><div class="line">  document.getElementById('app')</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>但是，这种情况需要对<code>服务器改造</code>。否则用户直接向服务器请求某个子路由，会显示网页找不到的404错误。<br>如果开发服务器使用的是<code>webpack-dev-server</code>，加上<code>--history-api-fallback</code>参数就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ webpack-dev-server --inline --content-base . --history-api-fallback</div></pre></td></tr></table></figure></p>
<p><code>createMemoryHistory</code>主要用于服务器渲染。它创建一个内存中的<code>history</code>对象，不与浏览器<code>URL</code>互动。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> history = createMemoryHistory(location)</div></pre></td></tr></table></figure></p>
<h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><p><code>Link</code>组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟<code>React Router</code>对接呢？<br>下面是一个表单。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</div><div class="line">  &lt;input type="text" placeholder="userName"/&gt;</div><div class="line">  &lt;input type="text" placeholder="repo"/&gt;</div><div class="line">  &lt;button type="submit"&gt;Go&lt;/button&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<p>第一种方法是使用<code>browserHistory.push</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line">  handleSubmit(event) &#123;</div><div class="line">    event.preventDefault()</div><div class="line">    <span class="keyword">const</span> userName = event.target.elements[<span class="number">0</span>].value</div><div class="line">    <span class="keyword">const</span> repo = event.target.elements[<span class="number">1</span>].value</div><div class="line">    <span class="keyword">const</span> path = <span class="string">`/repos/<span class="subst">$&#123;userName&#125;</span>/<span class="subst">$&#123;repo&#125;</span>`</span></div><div class="line">    browserHistory.push(path)</div><div class="line">  &#125;,</div></pre></td></tr></table></figure></p>
<p>第二种方法是使用<code>context</code>对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</div><div class="line"></div><div class="line">  <span class="comment">// ask for `router` from context</span></div><div class="line">  contextTypes: &#123;</div><div class="line">    <span class="attr">router</span>: React.PropTypes.object</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  handleSubmit(event) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="keyword">this</span>.context.router.push(path)</div><div class="line">  &#125;,</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="路由的钩子"><a href="#路由的钩子" class="headerlink" title="路由的钩子"></a>路由的钩子</h3><p>每个路由都有<code>Enter</code>和<code>Leave</code>钩子，用户进入或离开该路由时触发。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"about"</span> component=&#123;About&#125; /&gt;</div><div class="line">＜Route path=<span class="string">"inbox"</span> component=&#123;Inbox&#125;&gt;</div><div class="line">  ＜Redirect <span class="keyword">from</span>=<span class="string">"messages/:id"</span> to=<span class="string">"/messages/:id"</span> /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p>上面的代码中，如果用户离开<code>/messages/:id</code>，进入<code>/about</code>时，会依次触发以下的钩子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/messages/:id的onLeave</div><div class="line">/inbox的onLeave</div><div class="line">/about的onEnter</div></pre></td></tr></table></figure></p>
<p>下面是一个例子，使用<code>onEnter</code>钩子替代<code>&lt;Redirect&gt;</code>组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Route path=<span class="string">"inbox"</span> component=&#123;Inbox&#125;&gt;</div><div class="line">  &lt;Route</div><div class="line">    path="messages/:id"</div><div class="line">    onEnter=&#123;</div><div class="line">      (&#123;params&#125;, replace) =&gt; replace(`/messages/$&#123;params.id&#125;`)</div><div class="line">    &#125; </div><div class="line">  /&gt;</div><div class="line">&lt;/Route&gt;</div></pre></td></tr></table></figure></p>
<p><code>onEnter</code>钩子还可以用来做认证。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> requireAuth = <span class="function">(<span class="params">nextState, replace</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (!auth.isAdmin()) &#123;</div><div class="line">        <span class="comment">// Redirect to Home page if not an Admin</span></div><div class="line">        replace(&#123; <span class="attr">pathname</span>: <span class="string">'/'</span> &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> AdminRoutes = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">     &lt;Route path="/admin" component=&#123;Admin&#125; onEnter=&#123;requireAuth&#125; /&gt;</div><div class="line">  )</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是一个高级应用，当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Home = withRouter(</div><div class="line">  React.createClass(&#123;</div><div class="line">    componentDidMount() &#123;</div><div class="line">      <span class="keyword">this</span>.props.router.setRouteLeaveHook(</div><div class="line">        <span class="keyword">this</span>.props.route, </div><div class="line">        <span class="keyword">this</span>.routerWillLeave</div><div class="line">      )</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    routerWillLeave(nextLocation) &#123;</div><div class="line">      <span class="comment">// 返回 false 会继续停留当前页面，</span></div><div class="line">      <span class="comment">// 否则，返回一个字符串，会显示给用户，让其自己决定</span></div><div class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.state.isSaved)</div><div class="line">        <span class="keyword">return</span> <span class="string">'确认要离开？'</span>;</div><div class="line">    &#125;,</div><div class="line">  &#125;)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>setRouteLeaveHook</code>方法为<code>Leave</code>钩子指定<code>routerWillLeave</code>函数。该方法如果返回<code>false</code>，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真正学会 &lt;a href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;React&lt;/a&gt; 是一个漫长的过程。&lt;br&gt;&lt;img src=&quot;/images/page/reactRouter/03.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;你会发现，它不是一个库，也不是一个框架，而是一个庞大的体系。想要发挥它的威力，整个技术栈都要配合它改造。你要学习一整套解决方案，从后端到前端，都是全新的做法。&lt;br&gt;&lt;img src=&quot;/images/page/reactRouter/04.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;举例来说，React 不使用 HTML，而使用 JSX 。它打算抛弃 DOM，要求开发者不要使用任何 DOM 方法。它甚至还抛弃了 SQL ，自己发明了一套查询语言 GraphQL 。当然，这些你都可以不用，React 照样运行，但是就发挥不出它的最大威力。&lt;br&gt;这样说吧，你只要用了 React，就会发现合理的选择就是，采用它的整个技术栈。&lt;br&gt;本文介绍 React 体系的一个重要部分：路由库&lt;code&gt;[React-Router](https://github.com/reactjs/react-router)&lt;/code&gt;。它是官方维护的，事实上也是唯一可选的路由库。它通过管理 URL，实现组件的切换和状态的变化，开发复杂的应用几乎肯定会用到。&lt;br&gt;&lt;img src=&quot;/images/page/reactRouter/05.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;（[说明] 本文写作时，React-router 是 2.x 版，本文的内容只适合这个版本，与最新的 4.x 版不兼容。目前，官方同时维护 2.x 和 4.x 两个版本，所以前者依然可以用在项目中。2017年3月）&lt;/p&gt;
&lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;&lt;p&gt;React Router 安装命令如下。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ npm install -S react-router&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用时，路由器&lt;code&gt;Router&lt;/code&gt;就是React的一个组件。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; Router &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react-router&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;render(&amp;lt;Router/&amp;gt;, &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&#39;app&#39;&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Router&lt;/code&gt;组件本身只是一个容器，真正的路由要通过&lt;code&gt;Route&lt;/code&gt;组件定义。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123; Router, Route, hashHistory &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react-router&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;render((&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;Router history=&amp;#123;hashHistory&amp;#125;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;Route path=&quot;/&quot; component=&amp;#123;App&amp;#125;/&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;/Router&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;), document.getElementById(&#39;app&#39;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面代码中，用户访问根路由&lt;code&gt;/&lt;/code&gt;（比如&lt;code&gt;http://www.example.com/&lt;/code&gt;），组件&lt;code&gt;APP&lt;/code&gt;就会加载到&lt;code&gt;document.getElementById(&amp;#39;app&amp;#39;)&lt;/code&gt;。&lt;br&gt;你可能还注意到，&lt;code&gt;Router&lt;/code&gt;组件有一个参数&lt;code&gt;history&lt;/code&gt;，它的值&lt;code&gt;hashHistory&lt;/code&gt;表示，路由的切换由URL的&lt;code&gt;hash&lt;/code&gt;变化决定，即&lt;code&gt;URL&lt;/code&gt;的&lt;code&gt;#&lt;/code&gt;部分发生变化。举例来说，用户访问&lt;code&gt;http://www.example.com/&lt;/code&gt;，实际会看到的是&lt;code&gt;http://www.example.com/#/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Route&lt;/code&gt;组件定义了URL路径与组件的对应关系。你可以同时使用多个&lt;code&gt;Route&lt;/code&gt;组件。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;Router history=&amp;#123;hashHistory&amp;#125;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;Route path=&quot;/&quot; component=&amp;#123;App&amp;#125;/&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;Route path=&quot;/repos&quot; component=&amp;#123;Repos&amp;#125;/&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;lt;Route path=&quot;/about&quot; component=&amp;#123;About&amp;#125;/&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/Router&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面代码中，用户访问&lt;code&gt;/repos&lt;/code&gt;（比如&lt;code&gt;http://localhost:8080/#/repos&lt;/code&gt;）时，加载&lt;code&gt;Repos&lt;/code&gt;组件；访问&lt;code&gt;/about&lt;/code&gt;（&lt;code&gt;http://localhost:8080/#/about&lt;/code&gt;）时，加载&lt;code&gt;About&lt;/code&gt;组件。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>npm scripts 使用指南</title>
    <link href="http://html-js.site/2017/11/13/npm-scripts-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://html-js.site/2017/11/13/npm-scripts-使用指南/</id>
    <published>2017-11-13T12:38:42.000Z</published>
    <updated>2017-11-13T13:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。<br>本文介绍如何使用 npm 脚本（npm scripts）。</p>
<h3 id="什么是-npm-脚本？"><a href="#什么是-npm-脚本？" class="headerlink" title="什么是 npm 脚本？"></a>什么是 npm 脚本？</h3><p>npm 允许在<code>package.json</code>文件里面，使用<code>scripts</code>字段定义脚本命令。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"build"</span>: <span class="string">"node build.js"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码是<code>package.json</code>文件的一个片段，里面的<code>scripts</code>字段是一个对象。它的每一个属性，对应一段脚本。比如，<code>build</code>命令对应的脚本是<code>node build.js</code>。<br>命令行下使用<code>npm run</code>命令，就可以执行这段脚本。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm run build</div><div class="line"># 等同于执行</div><div class="line">$ node build.js</div></pre></td></tr></table></figure></p>
<p>这些定义在<code>package.json</code>里面的脚本，就称为 npm 脚本。它的优点很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">项目的相关脚本，可以集中在一个地方。</div><div class="line">不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。</div><div class="line">可以利用 npm 提供的很多辅助功能。</div></pre></td></tr></table></figure></p>
<p>查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的<code>npm run</code>命令。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run</div></pre></td></tr></table></figure></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>npm 脚本的原理非常简单。每当执行<code>npm run</code>，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。<br>比较特别的是，<code>npm run</code>新建的这个 Shell，会将当前目录的<code>node_modules/.bin</code>子目录加入<code>PATH</code>变量，执行结束后，再将<code>PATH</code>变量恢复原样。<br>这意味着，当前目录的<code>node_modules/.bin</code>子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 <code>Mocha</code>，只要直接写<code>mocha test</code>就可以了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"test"</span>: <span class="string">"mocha test"</span></div></pre></td></tr></table></figure></p>
<p>而不用写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"test"</span>: <span class="string">"./node_modules/.bin/mocha test"</span></div></pre></td></tr></table></figure></p>
<p>由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。<br>npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是<code>0</code>，npm 就认为这个脚本执行失败。</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"lint"</span>: <span class="string">"jshint *.js"</span></div><div class="line"><span class="string">"lint"</span>: <span class="string">"jshint **/*.js"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>*</code>表示任意文件名，<code>**</code>表示任意一层子目录。<br>如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"test"</span>: <span class="string">"tap test/\*.js"</span></div></pre></td></tr></table></figure></p>
<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>向 npm 脚本传入参数，要使用–标明。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"lint"</span>: <span class="string">"jshint **.js"</span></div></pre></td></tr></table></figure></p>
<p>向上面的<code>npm run lint</code>命令传入参数，必须写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run lint --  --reporter checkstyle &gt; checkstyle.xml</div></pre></td></tr></table></figure></p>
<p>也可以在<code>package.json</code>里面再封装一个命令。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"lint"</span>: <span class="string">"jshint **.js"</span>,</div><div class="line"><span class="string">"lint:checkstyle"</span>: <span class="string">"npm run lint -- --reporter checkstyle &gt; checkstyle.xml"</span></div></pre></td></tr></table></figure></p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。<br>如果是并行执行（即同时的平行执行），可以使用<code>&amp;</code>符号。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run script1.js &amp; npm run script2.js</div></pre></td></tr></table></figure></p>
<p>如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用<code>&amp;&amp;</code>符号。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run script1.js &amp;&amp; npm run script2.js</div></pre></td></tr></table></figure></p>
<p>这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：<a href="https://github.com/paulpflug/script-runner" target="_blank" rel="external">script-runner</a>、<a href="https://github.com/mysticatea/npm-run-all" target="_blank" rel="external">npm-run-all</a>、<a href="https://github.com/coderaiser/redrun" target="_blank" rel="external">redrun</a>。</p>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">"start"</span>: <span class="string">"node server.js"</span>，</div><div class="line"><span class="string">"install"</span>: <span class="string">"node-gyp rebuild"</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>npm run start</code>的默认值是<code>node server.js</code>，前提是项目根目录下有<code>server.js</code>这个脚本；<code>npm run install</code>的默认值是<code>node-gyp rebuild</code>，前提是项目根目录下有<code>binding.gyp</code>文件。</p>
<h3 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h3><p>npm 脚本有<code>pre</code>和<code>post</code>两个钩子。举例来说，<code>build</code>脚本命令的钩子就是<code>prebuild</code>和<code>postbuild</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"prebuild"</span>: <span class="string">"echo I run before the build script"</span>,</div><div class="line"><span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack"</span>,</div><div class="line"><span class="string">"postbuild"</span>: <span class="string">"echo I run after the build script"</span></div></pre></td></tr></table></figure></p>
<p>用户执行<code>npm run build</code>的时候，会自动按照下面的顺序执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild</div></pre></td></tr></table></figure></p>
<p>因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"clean"</span>: <span class="string">"rimraf ./dist &amp;&amp; mkdir dist"</span>,</div><div class="line"><span class="string">"prebuild"</span>: <span class="string">"npm run clean"</span>,</div><div class="line"><span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack"</span></div></pre></td></tr></table></figure></p>
<p>npm 默认提供下面这些钩子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">prepublish，postpublish</div><div class="line">preinstall，postinstall</div><div class="line">preuninstall，postuninstall</div><div class="line">preversion，postversion</div><div class="line">pretest，posttest</div><div class="line">prestop，poststop</div><div class="line">prestart，poststart</div><div class="line">prerestart，postrestart</div></pre></td></tr></table></figure></p>
<p>自定义的脚本命令也可以加上<code>pre</code>和<code>post</code>钩子。比如，<code>myscript</code>这个脚本命令，也有<code>premyscript</code>和<code>postmyscript</code>钩子。不过，双重的<code>pre</code>和<code>post</code>无效，比如<code>prepretest</code>和<code>postposttest</code>是无效的。<br>npm 提供一个<code>npm_lifecycle_event</code>变量，返回当前正在运行的脚本名称，比如<code>pretest</code>、<code>test</code>、<code>posttest等</code>等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的<code>npm scripts</code>命令编写代码。请看下面的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> TARGET = process.env.npm_lifecycle_event;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (TARGET === <span class="string">'test'</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`Running the test task!`</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (TARGET === <span class="string">'pretest'</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`Running the pretest task!`</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (TARGET === <span class="string">'posttest'</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`Running the posttest task!`</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，<code>prepublish</code>这个钩子不仅会在<code>npm publish</code>命令之前运行，还会在<code>npm install</code>（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 <code>npm 4</code>引入了一个新的钩子<code>prepare</code>，行为等同于<code>prepublish</code>，而从 <code>npm 5</code>开始，<code>prepublish</code>将只在<code>npm publish</code>命令之前运行。</p>
<h3 id="简写形式"><a href="#简写形式" class="headerlink" title="简写形式"></a>简写形式</h3><p>四个常用的 npm 脚本有简写形式。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">npm start是npm run start</div><div class="line">npm stop是npm run stop的简写</div><div class="line">npm test是npm run test的简写</div><div class="line">npm restart是npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写</div></pre></td></tr></table></figure></p>
<p><code>npm start</code>、<code>npm stop</code>和<code>npm restart</code>都比较好理解，而<code>npm restart</code>是一个复合命令，实际上会执行三个脚本命令：<code>stop</code>、<code>restart</code>、<code>start</code>。具体的执行顺序如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">prerestart</div><div class="line">prestop</div><div class="line">stop</div><div class="line">poststop</div><div class="line">restart</div><div class="line">prestart</div><div class="line">start</div><div class="line">poststart</div><div class="line">postrestart</div></pre></td></tr></table></figure></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。<br>首先，通过<code>npm_package_</code>前缀，npm 脚本可以拿到<code>package.json</code>里面的字段。比如，下面是一个<code>package.json</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"foo"</span>, </div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.2.5"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"view"</span>: <span class="string">"node view.js"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么，变量<code>npm_package_name</code>返回<code>foo</code>，变量<code>npm_package_version</code>返回<code>1.2.5</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// view.js</span></div><div class="line"><span class="built_in">console</span>.log(process.env.npm_package_name); <span class="comment">// foo</span></div><div class="line"><span class="built_in">console</span>.log(process.env.npm_package_version); <span class="comment">// 1.2.5</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，我们通过环境变量<code>process.env</code>对象，拿到<code>package.json</code>的字段值。如果是 Bash 脚本，可以用<code>$npm_package_name</code>和<code>$npm_package_version</code>取到这两个值。<br><code>npm_package_</code>前缀也支持嵌套的<code>package.json</code>字段。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="string">"repository"</span>: &#123;</div><div class="line">   <span class="string">"type"</span>: <span class="string">"git"</span>,</div><div class="line">   <span class="string">"url"</span>: <span class="string">"xxx"</span></div><div class="line"> &#125;,</div><div class="line"> <span class="attr">scripts</span>: &#123;</div><div class="line">   <span class="string">"view"</span>: <span class="string">"echo $npm_package_repository_type"</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>repository</code>字段的<code>type</code>属性，可以通过<code>npm_package_repository_type</code>取到。<br>下面是另外一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;</div><div class="line">  <span class="string">"install"</span>: <span class="string">"foo.js"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>npm_package_scripts_install</code>变量的值等于<code>foo.js</code>。<br>然后，npm 脚本还可以通过<code>npm_config_</code>前缀，拿到 npm 的配置变量，即<code>npm config get xxx</code>命令返回的值。比如，当前模块的发行标签，可以通过<code>npm_config_tag</code>取到。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"view"</span>: <span class="string">"echo $npm_config_tag"</span>,</div></pre></td></tr></table></figure></p>
<p>注意，<code>package.json</code>里面的<code>config</code>对象，可以被环境变量覆盖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">  <span class="string">"name"</span> : <span class="string">"foo"</span>,</div><div class="line">  <span class="string">"config"</span> : &#123; <span class="string">"port"</span> : <span class="string">"8080"</span> &#125;,</div><div class="line">  <span class="string">"scripts"</span> : &#123; <span class="string">"start"</span> : <span class="string">"node server.js"</span> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>npm_package_config_port</code>变量返回的是8080。这个值可以用下面的方法覆盖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm config set foo:port <span class="number">80</span></div></pre></td></tr></table></figure></p>
<p>最后，<code>env</code>命令可以列出所有环境变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"env"</span>: <span class="string">"env"</span></div></pre></td></tr></table></figure></p>
<h3 id="常用脚本示例"><a href="#常用脚本示例" class="headerlink" title="常用脚本示例"></a>常用脚本示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 删除目录</span></div><div class="line"><span class="string">"clean"</span>: <span class="string">"rimraf dist/*"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 本地搭建一个 HTTP 服务</span></div><div class="line"><span class="string">"serve"</span>: <span class="string">"http-server -p 9090 dist/"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 打开浏览器</span></div><div class="line"><span class="string">"open:dev"</span>: <span class="string">"opener http://localhost:9090"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 实时刷新</span></div><div class="line"> <span class="string">"livereload"</span>: <span class="string">"live-reload --port 9091 dist/"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 构建 HTML 文件</span></div><div class="line"><span class="string">"build:html"</span>: <span class="string">"jade index.jade &gt; dist/index.html"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 只要 CSS 文件有变动，就重新执行构建</span></div><div class="line"><span class="string">"watch:css"</span>: <span class="string">"watch 'npm run build:css' assets/styles/"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 只要 HTML 文件有变动，就重新执行构建</span></div><div class="line"><span class="string">"watch:html"</span>: <span class="string">"watch 'npm run build:html' assets/html"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 部署到 Amazon S3</span></div><div class="line"><span class="string">"deploy:prod"</span>: <span class="string">"s3-cli sync ./dist/ s3://example-com/prod-site/"</span>,</div><div class="line"></div><div class="line"><span class="comment">// 构建 favicon</span></div><div class="line"><span class="string">"build:favicon"</span>: <span class="string">"node scripts/favicon.js"</span>,</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。&lt;br&gt;本文介绍如何使用 npm 脚本（npm scripts）。&lt;/p&gt;
&lt;h3 id=&quot;什么是-npm-脚本？&quot;&gt;&lt;a href=&quot;#什么是-npm-脚本？&quot; class=&quot;headerlin
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="npm" scheme="http://html-js.site/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数字精度丢失问题总结及解决方案</title>
    <link href="http://html-js.site/2017/10/25/JavaScript%E6%95%B0%E5%AD%97%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://html-js.site/2017/10/25/JavaScript数字精度丢失问题总结及解决方案/</id>
    <published>2017-10-25T09:33:02.000Z</published>
    <updated>2017-10-25T09:48:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>js精度问题一般是对浮点数的加减乘除引起的，主要的解决方案大都是将浮点数<code>*10^n</code>转为整数，计算完再<code>/10^n</code>转为浮点数</p>
<h3 id="JS数字精度丢失的一些典型问题"><a href="#JS数字精度丢失的一些典型问题" class="headerlink" title="JS数字精度丢失的一些典型问题"></a>JS数字精度丢失的一些典型问题</h3><ul>
<li><ol>
<li>两个简单的浮点数相加</li>
</ol>
</li>
<li><ol>
<li>大整数运算</li>
</ol>
</li>
<li><ol>
<li>toFixed 不会四舍五入（Chrome）</li>
</ol>
</li>
</ul>
<p><img src="/images/page/number/1.png" alt=""></p>
<a id="more"></a>
<h3 id="JS-数字丢失精度的原因"><a href="#JS-数字丢失精度的原因" class="headerlink" title="JS 数字丢失精度的原因"></a>JS 数字丢失精度的原因</h3><p>计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="external">IEEE 754</a> 规范，采用双精度存储（double precision），占用 64 bit。如图<br><img src="/images/page/number/2.png" alt=""><br>意义:</p>
<ul>
<li>1位用来表示符号位</li>
<li>11位用来表示指数</li>
<li>52位表示尾数</li>
</ul>
<p>浮点数，比如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0.1</span> &gt;&gt; <span class="number">0.0001</span> <span class="number">1001</span> <span class="number">1001</span> <span class="number">1001</span>…（<span class="number">1001</span>无限循环）</div><div class="line"><span class="number">0.2</span> &gt;&gt; <span class="number">0.0011</span> <span class="number">0011</span> <span class="number">0011</span> <span class="number">0011</span>…（<span class="number">0011</span>无限循环）</div></pre></td></tr></table></figure></p>
<p>此时只能模仿十进制进行四舍五入了，但是二进制只有 0 和 1 两个，于是变为 0 舍 1 入。这即是计算机中部分浮点数运算时出现误差，丢失精度的根本原因。</p>
<p>大整数的精度丢失和浮点数本质上是一样的，尾数位最大是 52 位，因此 JS 中能精准表示的最大整数是 Math.pow(2, 53)，十进制即 9007199254740992。</p>
<p>大于 9007199254740992 的可能会丢失精度<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">9007199254740992</span>     &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.000</span> <span class="comment">// 共计 53 个 0</span></div><div class="line"><span class="number">9007199254740992</span> + <span class="number">1</span> &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.001</span> <span class="comment">// 中间 52 个 0</span></div><div class="line"><span class="number">9007199254740992</span> + <span class="number">2</span> &gt;&gt; <span class="number">10000000000000.</span>.<span class="number">.010</span> <span class="comment">// 中间 51 个 0</span></div></pre></td></tr></table></figure></p>
<p>实际上<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">9007199254740992</span> + <span class="number">1</span> <span class="comment">// 丢失</span></div><div class="line"><span class="number">9007199254740992</span> + <span class="number">2</span> <span class="comment">// 未丢失</span></div><div class="line"><span class="number">9007199254740992</span> + <span class="number">3</span> <span class="comment">// 丢失</span></div><div class="line"><span class="number">9007199254740992</span> + <span class="number">4</span> <span class="comment">// 未丢失</span></div></pre></td></tr></table></figure></p>
<p>结果如图<br><img src="/images/page/number/3.png" alt=""></p>
<p>以上，可以知道看似有穷的数字, 在计算机的二进制表示里却是无穷的，由于存储位数限制因此存在“舍去”，精度丢失就发生了。</p>
<p>想了解更深入的分析可以看这篇论文（又长又臭）：<a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html" target="_blank" rel="external">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。</p>
<p>对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 0.1 + 0.2</span></div><div class="line">(<span class="number">0.1</span>*<span class="number">10</span> + <span class="number">0.2</span>*<span class="number">10</span>) / <span class="number">10</span> == <span class="number">0.3</span> <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>以下是我写了一个对象，对小数的加减乘除运算丢失精度做了屏蔽。当然转换后的整数依然不能超过 9007199254740992。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * floatObj 包含加减乘除四个方法，能确保浮点数运算不丢失精度</div><div class="line"> *</div><div class="line"> * 我们知道计算机编程语言里浮点数计算会存在精度丢失问题（或称舍入误差），其根本原因是二进制和实现位数限制有些数无法有限表示</div><div class="line"> * 以下是十进制小数对应的二进制表示</div><div class="line"> *      0.1 &gt;&gt; 0.0001 1001 1001 1001…（1001无限循环）</div><div class="line"> *      0.2 &gt;&gt; 0.0011 0011 0011 0011…（0011无限循环）</div><div class="line"> * 计算机里每种数据类型的存储是一个有限宽度，比如 JavaScript 使用 64 位存储数字类型，因此超出的会舍去。舍去的部分就是精度丢失的部分。</div><div class="line"> *</div><div class="line"> * ** method **</div><div class="line"> *  add / subtract / multiply /divide</div><div class="line"> *</div><div class="line"> * ** explame **</div><div class="line"> *  0.1 + 0.2 == 0.30000000000000004 （多了 0.00000000000004）</div><div class="line"> *  0.2 + 0.4 == 0.6000000000000001  （多了 0.0000000000001）</div><div class="line"> *  19.9 * 100 == 1989.9999999999998 （少了 0.0000000000002）</div><div class="line"> *</div><div class="line"> * floatObj.add(0.1, 0.2) &gt;&gt; 0.3</div><div class="line"> * floatObj.multiply(19.9, 100) &gt;&gt; 1990</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">var</span> floatObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 判断obj是否为一个整数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isInteger</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(obj) === obj</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 将一个浮点数转成整数，返回整数和倍数。如 3.14 &gt;&gt; 314，倍数是 100</div><div class="line">     * @param floatNum &#123;number&#125; 小数</div><div class="line">     * @return &#123;object&#125;</div><div class="line">     *   &#123;times:100, num: 314&#125;</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">toInteger</span>(<span class="params">floatNum</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> ret = &#123;<span class="attr">times</span>: <span class="number">1</span>, <span class="attr">num</span>: <span class="number">0</span>&#125;</div><div class="line">        <span class="keyword">var</span> isNegative = floatNum &lt; <span class="number">0</span></div><div class="line">        <span class="keyword">if</span> (isInteger(floatNum)) &#123;</div><div class="line">            ret.num = floatNum</div><div class="line">            <span class="keyword">return</span> ret</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">var</span> strfi  = floatNum + <span class="string">''</span></div><div class="line">        <span class="keyword">var</span> dotPos = strfi.indexOf(<span class="string">'.'</span>)</div><div class="line">        <span class="keyword">var</span> len    = strfi.substr(dotPos+<span class="number">1</span>).length</div><div class="line">        <span class="keyword">var</span> times  = <span class="built_in">Math</span>.pow(<span class="number">10</span>, len)</div><div class="line">        <span class="keyword">var</span> intNum = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.abs(floatNum) * times + <span class="number">0.5</span>, <span class="number">10</span>)</div><div class="line">        ret.times  = times</div><div class="line">        <span class="keyword">if</span> (isNegative) &#123;</div><div class="line">            intNum = -intNum</div><div class="line">        &#125;</div><div class="line">        ret.num = intNum</div><div class="line">        <span class="keyword">return</span> ret</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">     * 核心方法，实现加减乘除运算，确保不丢失精度</div><div class="line">     * 思路：把小数放大为整数（乘），进行算术运算，再缩小为小数（除）</div><div class="line">     *</div><div class="line">     * @param a &#123;number&#125; 运算数1</div><div class="line">     * @param b &#123;number&#125; 运算数2</div><div class="line">     * @param digits &#123;number&#125; 精度，保留的小数点数，比如 2, 即保留为两位小数</div><div class="line">     * @param op &#123;string&#125; 运算类型，有加减乘除（add/subtract/multiply/divide）</div><div class="line">     *</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">operation</span>(<span class="params">a, b, digits, op</span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> o1 = toInteger(a)</div><div class="line">        <span class="keyword">var</span> o2 = toInteger(b)</div><div class="line">        <span class="keyword">var</span> n1 = o1.num</div><div class="line">        <span class="keyword">var</span> n2 = o2.num</div><div class="line">        <span class="keyword">var</span> t1 = o1.times</div><div class="line">        <span class="keyword">var</span> t2 = o2.times</div><div class="line">        <span class="keyword">var</span> max = t1 &gt; t2 ? t1 : t2</div><div class="line">        <span class="keyword">var</span> result = <span class="literal">null</span></div><div class="line">        <span class="keyword">switch</span> (op) &#123;</div><div class="line">            <span class="keyword">case</span> <span class="string">'add'</span>:</div><div class="line">                <span class="keyword">if</span> (t1 === t2) &#123; <span class="comment">// 两个小数位数相同</span></div><div class="line">                    result = n1 + n2</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123; <span class="comment">// o1 小数位 大于 o2</span></div><div class="line">                    result = n1 + n2 * (t1 / t2)</div><div class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// o1 小数位 小于 o2</span></div><div class="line">                    result = n1 * (t2 / t1) + n2</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> result / max</div><div class="line">            <span class="keyword">case</span> <span class="string">'subtract'</span>:</div><div class="line">                <span class="keyword">if</span> (t1 === t2) &#123;</div><div class="line">                    result = n1 - n2</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2) &#123;</div><div class="line">                    result = n1 - n2 * (t1 / t2)</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    result = n1 * (t2 / t1) - n2</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> result / max</div><div class="line">            <span class="keyword">case</span> <span class="string">'multiply'</span>:</div><div class="line">                result = (n1 * n2) / (t1 * t2)</div><div class="line">                <span class="keyword">return</span> result</div><div class="line">            <span class="keyword">case</span> <span class="string">'divide'</span>:</div><div class="line">                result = (n1 / n2) * (t2 / t1)</div><div class="line">                <span class="keyword">return</span> result</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 加减乘除的四个接口</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, digits</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> operation(a, b, digits, <span class="string">'add'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b, digits</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> operation(a, b, digits, <span class="string">'subtract'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a, b, digits</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> operation(a, b, digits, <span class="string">'multiply'</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, digits</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> operation(a, b, digits, <span class="string">'divide'</span>)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// exports</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">add</span>: add,</div><div class="line">        <span class="attr">subtract</span>: subtract,</div><div class="line">        <span class="attr">multiply</span>: multiply,</div><div class="line">        <span class="attr">divide</span>: divide</div><div class="line">    &#125;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>toFixed的修复如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// toFixed 修复</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFixed</span>(<span class="params">num, s</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> times = <span class="built_in">Math</span>.pow(<span class="number">10</span>, s)</div><div class="line">    <span class="keyword">var</span> des = num * times + <span class="number">0.5</span></div><div class="line">    des = <span class="built_in">parseInt</span>(des, <span class="number">10</span>) / times</div><div class="line">    <span class="keyword">return</span> des + <span class="string">''</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js精度问题一般是对浮点数的加减乘除引起的，主要的解决方案大都是将浮点数&lt;code&gt;*10^n&lt;/code&gt;转为整数，计算完再&lt;code&gt;/10^n&lt;/code&gt;转为浮点数&lt;/p&gt;
&lt;h3 id=&quot;JS数字精度丢失的一些典型问题&quot;&gt;&lt;a href=&quot;#JS数字精度丢失的一些典型问题&quot; class=&quot;headerlink&quot; title=&quot;JS数字精度丢失的一些典型问题&quot;&gt;&lt;/a&gt;JS数字精度丢失的一些典型问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;两个简单的浮点数相加&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;大整数运算&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;toFixed 不会四舍五入（Chrome）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/images/page/number/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>使用 webpack 优化资源</title>
    <link href="http://html-js.site/2017/10/20/%E4%BD%BF%E7%94%A8-webpack-%E4%BC%98%E5%8C%96%E8%B5%84%E6%BA%90/"/>
    <id>http://html-js.site/2017/10/20/使用-webpack-优化资源/</id>
    <published>2017-10-20T07:23:36.000Z</published>
    <updated>2017-10-30T08:04:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端应用的优化中，对加载资源的大小控制极其的重要，大多数时候我们能做的是在打包编译的过程对资源进行大小控制、拆分与复用。</p>
<p>本片文章中主要是基于 webpack 打包，以 React、vue 等生态开发的单页面应用来举例说明如何从 webpack 打包的层面去处理资源以及缓存，其中主要我们需要做的是对 webpack 进行配置的优化，同时涉及少量的业务代码的更改。</p>
<p>同时对打包资源的分析可以使用 (<a href="http://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/webpack-bundle-analyzer" target="_blank" rel="external">webpack-contrib/webpack-bundle-analyzer</a>) 插件，当然可选的分析插件还是很多的，在本文中主要以该插件来举例分析。<br><a id="more"></a><br>TIP: webpack 版本 @3.6.0</p>
<h2 id="打包环境与代码压缩"><a href="#打包环境与代码压缩" class="headerlink" title="打包环境与代码压缩"></a>打包环境与代码压缩</h2><p>首先我们有一个最基本的 webpack 配置：<br><figure class="highlight ls"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">// webpack.config.js</span></div><div class="line">const path = require('path');</div><div class="line">const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;</div><div class="line"></div><div class="line">const PROJECT_ROOT = path.resolve(__dirname, './');</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &#123;</div><div class="line">    index: './src/index.js'</div><div class="line">  &#125;,</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, 'dist'),</div><div class="line">    filename: '[name].[chunkhash:4].js'</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    rules: [</div><div class="line">      &#123;</div><div class="line">        test: /\.js[x]?$/,</div><div class="line">        use: 'babel-loader',</div><div class="line">        include: PROJECT_ROOT,</div><div class="line">        exclude: /node_modules/</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new BundleAnalyzerPlugin()</div><div class="line">  ],</div><div class="line">  resolve: &#123;</div><div class="line">    extensions: ['.js', '.jsx']</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>执行打包可以看到一个项目的 js 有 1M 以上：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Hash: e51afc2635f08322670b</div><div class="line">Version: webpack <span class="number">3.6</span><span class="number">.0</span></div><div class="line">Time: <span class="number">2769</span>ms</div><div class="line">        Asset    Size  Chunks                    Chunk Names</div><div class="line">index.caa7.js  <span class="number">1.3</span> MB       <span class="number">0</span>  [emitted]  [big]  index</div></pre></td></tr></table></figure></p>
<p>这时候只需要增加插件 <code>DefinePlugin</code> 与 <code>UglifyJSPlugin</code> 即可减少不少的体积，在 plugins 中添加：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line">...</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  plugins: [</div><div class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'production'</span>)</div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> UglifyJSPlugin(&#123;</div><div class="line">      <span class="attr">uglifyOptions</span>: &#123;</div><div class="line">        <span class="attr">ie8</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">output</span>: &#123;</div><div class="line">          <span class="attr">comments</span>: <span class="literal">false</span>,</div><div class="line">          <span class="attr">beautify</span>: <span class="literal">false</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">mangle</span>: &#123;</div><div class="line">          <span class="attr">keep_fnames</span>: <span class="literal">true</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">compress</span>: &#123;</div><div class="line">          <span class="attr">warnings</span>: <span class="literal">false</span>,</div><div class="line">          <span class="attr">drop_console</span>: <span class="literal">true</span></div><div class="line">        &#125;,</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  ]</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到这时候的打包输出：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Hash: <span class="number">84338998472</span>a6d3c5c25</div><div class="line">Version: webpack <span class="number">3.6</span><span class="number">.0</span></div><div class="line">Time: <span class="number">9940</span>ms</div><div class="line">        Asset    Size  Chunks                    Chunk Names</div><div class="line">index<span class="number">.89</span>c2.js  <span class="number">346</span> kB       <span class="number">0</span>  [emitted]  [big]  index</div></pre></td></tr></table></figure></p>
<p>代码的大小从 1.3M 降到了 346K。</p>
<h3 id="（1）DefinePlugin"><a href="#（1）DefinePlugin" class="headerlink" title="（1）DefinePlugin"></a>（1）DefinePlugin</h3><blockquote>
<p>DefinePlugin 允许创建一个在编译时可以配置的全局常量。这可能会对开发模式和发布模式的构建允许不同的行为非常有用。如果在开发构建中，而不在发布构建中执行日志记录，则可以使用全局常量来决定是否记录日志。这就是 DefinePlugin 的用处，设置它，就可以忘记开发和发布构建的规则。</p>
</blockquote>
<p>在我们的业务代码和第三方包的代码中很多时候需要判断 <code>process.env.NODE_ENV</code> 来做不同处理，而在生产环境中我们显然不需要非 <code>production</code> 的处理部分。</p>
<p>在这里我们设置 <code>process.env.NODE_ENV</code> 为 <code>JSON.stringify(&#39;production&#39;)</code>，也就是表示讲打包环境设置为生产环境。之后配合 <code>UglifyJSPlugin</code> 插件就可以在给生产环境打包的时候去除部分的冗余代码。</p>
<h3 id="（2）UglifyJSPlugin"><a href="#（2）UglifyJSPlugin" class="headerlink" title="（2）UglifyJSPlugin"></a>（2）UglifyJSPlugin</h3><p>UglifyJSPlugin 主要是用于解析、压缩 js 代码，它基于 <code>uglify-es</code> 来对 js 代码进行处理，它有多种配置选项：<a href="http://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/uglifyjs-webpack-plugin" target="_blank" rel="external">https://github.com/webpack-contrib/uglifyjs-webpack-plugin</a></p>
<p>通过对代码的压缩处理以及去除冗余，大大减小了打包资源的体积大小。</p>
<h2 id="代码拆分-按需加载"><a href="#代码拆分-按需加载" class="headerlink" title="代码拆分/按需加载"></a>代码拆分/按需加载</h2><p>在如 React 或者 vue 构建的单页面应用中，对页面路由与视图的控制是由前端来实现的，其对应的业务逻辑都在 js 代码中。</p>
<p>当一个应用设计的页面和逻辑很多的时候，最终生成的 js 文件资源也会相当大。</p>
<p>然而当我们打开一个 url 对应的页面时，实际上需要的并非全部的 js 代码，所需要的仅是一个主的运行时代码与该视图对应的业务逻辑的代码，在加载下一个视图的时候再去加载那部分的代码。</p>
<p>因此，对这方面可做的优化就是对 js 代码进行按需加载。</p>
<blockquote>
<p>懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。</p>
</blockquote>
<p>在 webpack 中提供了动态导入的技术来实现代码拆分，首先在 webpack 的配置中需要去配置拆分出来的每个子模块的配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</div><div class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</div><div class="line"></div><div class="line"><span class="keyword">const</span> PROJECT_ROOT = path.resolve(__dirname, <span class="string">'./'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: &#123;</div><div class="line">    <span class="attr">index</span>: <span class="string">'./src/index.js'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].[chunkhash:4].js'</span>,</div><div class="line">    <span class="attr">chunkFilename</span>: <span class="string">'[name].[chunkhash:4].child.js'</span>,</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">rules</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.js[x]?$/</span>,</div><div class="line">        <span class="attr">use</span>: <span class="string">'babel-loader'</span>,</div><div class="line">        <span class="attr">include</span>: PROJECT_ROOT,</div><div class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'production'</span>)</div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> UglifyJSPlugin(&#123;</div><div class="line">      <span class="attr">uglifyOptions</span>: &#123;</div><div class="line">        <span class="attr">ie8</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">output</span>: &#123;</div><div class="line">          <span class="attr">comments</span>: <span class="literal">false</span>,</div><div class="line">          <span class="attr">beautify</span>: <span class="literal">false</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">mangle</span>: &#123;</div><div class="line">          <span class="attr">keep_fnames</span>: <span class="literal">true</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">compress</span>: &#123;</div><div class="line">          <span class="attr">warnings</span>: <span class="literal">false</span>,</div><div class="line">          <span class="attr">drop_console</span>: <span class="literal">true</span></div><div class="line">        &#125;,</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">  <span class="attr">resolve</span>: &#123;</div><div class="line">    <span class="attr">extensions</span>: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>其中主要需要定义的则是 <code>output</code> 中的 <code>chunkFilename</code>，它是导出的拆分代码的文件名，这里给它设置为 <code>[name].[chunkhash:4].child.js</code>，其中的 <code>name</code> 对应模块名称或者 id，<code>chunkhash</code> 是模块内容的 hash。</p>
<p>之后在业务代码中 webpack 提供了两种方式来动态导入：</p>
<ul>
<li><code>import(&#39;path/to/module&#39;) -&gt; Promise</code>，</li>
<li><code>require.ensure(dependencies: String[], callback: function(require), errorCallback: function(error), chunkName: String)</code></li>
</ul>
<p>对于最新版本的 webpack 主要推荐使用 <code>import()</code> 的方式<b>（注意：import 使用到了 Promise，因此需要确保代码中支持了 Promise 的 polyfill）</b>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src/index.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(</div><div class="line">    <span class="comment">/* webpackChunkName: "lodash" */</span></div><div class="line">    <span class="string">'lodash'</span></div><div class="line">  ).then(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line"></div><div class="line">    element.innerHTML = _.join([<span class="string">'Hello'</span>, <span class="string">'webpack'</span>], <span class="string">' '</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> element;</div><div class="line"></div><div class="line">  &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="string">'An error occurred while loading the component'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">getComponent().then(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(component);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以看到打包的信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Hash: d6ba79fe5995bcf9fa4d</div><div class="line">Version: webpack <span class="number">3.6</span><span class="number">.0</span></div><div class="line">Time: <span class="number">7022</span>ms</div><div class="line">               Asset     Size  Chunks             Chunk Names</div><div class="line">lodash<span class="number">.89</span>f0.child.js  <span class="number">85.4</span> kB       <span class="number">0</span>  [emitted]  lodash</div><div class="line">       index<span class="number">.316</span>e.js  <span class="number">1.96</span> kB       <span class="number">1</span>  [emitted]  index</div><div class="line">   [<span class="number">0</span>] ./src/index.js <span class="number">441</span> bytes &#123;<span class="number">1</span>&#125; [built]</div><div class="line">   [<span class="number">2</span>] (webpack)/buildin/global.js <span class="number">509</span> bytes &#123;<span class="number">0</span>&#125; [built]</div><div class="line">   [<span class="number">3</span>] (webpack)/buildin/<span class="built_in">module</span>.js <span class="number">517</span> bytes &#123;<span class="number">0</span>&#125; [built]</div><div class="line">    + <span class="number">1</span> hidden <span class="built_in">module</span></div></pre></td></tr></table></figure></p>
<p>可以看到打包出来的代码生成了 <code>index.316e.js</code> 和 <code>lodash.89f0.child.js</code> 两个文件，后者则是通过 <code>import</code> 来实现拆分的。</p>
<p><code>import</code> 它接收一个 <code>path</code> 参数，指的是该子模块对于的路径，同时还注意到其中可以添加一行注释 <code>/* webpackChunkName: &quot;lodash&quot; */</code>，该注释并非是无用的，它定义了该子模块的 name，其对应与 <code>output.chunkFilename</code> 中的 <code>[name]</code>。</p>
<p><code>import</code> 函数返回一个 Promise，当异步加载到子模块代码是会执行后续操作，比如更新视图等。</p>
<h3 id="（1）React-中的按需加载"><a href="#（1）React-中的按需加载" class="headerlink" title="（1）React 中的按需加载"></a>（1）React 中的按需加载</h3><p>在 React 配合 React-Router 开发中，往往就需要代码根据路由按需加载的能力，下面是一个基于 webpack 代码动态导入技术实现的 React 动态载入的组件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">lazyLoader</span> (<span class="params">importComponent</span>) </span>&#123;</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">AsyncComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    state = &#123; <span class="attr">Component</span>: <span class="literal">null</span> &#125;</div><div class="line"></div><div class="line">    <span class="keyword">async</span> componentDidMount () &#123;</div><div class="line">      <span class="keyword">const</span> &#123; <span class="attr">default</span>: Component &#125; = <span class="keyword">await</span> importComponent();</div><div class="line"></div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        <span class="attr">Component</span>: Component</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render () &#123;</div><div class="line">      <span class="keyword">const</span> Component = <span class="keyword">this</span>.state.Component;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> Component</div><div class="line">        ? &lt;Component &#123;...this.props&#125; /&gt;</div><div class="line">        : null;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return AsyncComponent;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在 <code>Route</code> 中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;Switch&gt;</div><div class="line">  &lt;Route exact path="/"</div><div class="line">    component=&#123;lazyLoader(() =&gt; import('./Home'))&#125;</div><div class="line">  /&gt;</div><div class="line">  &lt;Route path="/about"</div><div class="line">    component=&#123;lazyLoader(() =&gt; import('./About'))&#125;</div><div class="line">  /&gt;</div><div class="line">  &lt;Route</div><div class="line">    component=&#123;lazyLoader(() =&gt; import('./NotFound'))&#125;</div><div class="line">  /&gt;</div><div class="line">&lt;/Switch&gt;</div></pre></td></tr></table></figure></p>
<p>在 <code>Route</code> 中渲染的是 <code>lazyLoader</code> 函数返回的组件，该组件在 mount 之后会去执行 <code>importComponent</code> 函数（既：<code>() =&gt; import(&#39;./About&#39;)</code>）动态加载其对于的组件模块（被拆分出来的代码），待加载成功之后渲染该组件。</p>
<p>使用该方式打包出来的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Hash: <span class="number">02</span>a053d135a5653de985</div><div class="line">Version: webpack <span class="number">3.6</span><span class="number">.0</span></div><div class="line">Time: <span class="number">9399</span>ms</div><div class="line">          Asset     Size  Chunks                    Chunk Names</div><div class="line"><span class="number">0.</span>db22.child.js  <span class="number">5.82</span> kB       <span class="number">0</span>  [emitted]</div><div class="line"><span class="number">1.</span>fcf5.child.js   <span class="number">4.4</span> kB       <span class="number">1</span>  [emitted]</div><div class="line"><span class="number">2.442</span>d.child.js     <span class="number">3</span> kB       <span class="number">2</span>  [emitted]</div><div class="line">  index<span class="number">.1</span>bbc.js   <span class="number">339</span> kB       <span class="number">3</span>  [emitted]  [big]  index</div></pre></td></tr></table></figure></p>
<h2 id="抽离-Common-资源"><a href="#抽离-Common-资源" class="headerlink" title="抽离 Common 资源"></a>抽离 Common 资源</h2><h3 id="（1）第三方库的长缓存"><a href="#（1）第三方库的长缓存" class="headerlink" title="（1）第三方库的长缓存"></a>（1）第三方库的长缓存</h3><p>首先对于一些比较大的第三方库，比如在 React 中用到的 react、react-dom、react-router 等等，我们不希望它们被重复打包，并且在每次版本更新的时候也不希望去改变这部分的资源导致在用户端重新加载。</p>
<p>在这里可以使用 webpack 的 CommonsChunkPlugin 来抽离这些公共资源；</p>
<blockquote>
<p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p>
</blockquote>
<p>首先需要在 entry 中新增一个入口用来打包需要抽离出来的库，这里将 <code>&#39;react&#39;, &#39;react-dom&#39;, &#39;react-router-dom&#39;, &#39;immutable&#39;</code> 都给单独打包进 <code>vendor</code> 中；</p>
<p>之后在 plugins 中定义一个 <code>CommonsChunkPlugin</code> 插件，同时将其 <code>name</code> 设置为 <code>vendor</code> 是它们相关联，再将 <code>minChunks</code> 设置为 <code>Infinity</code> 防止其他代码被打包进来。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</div><div class="line"><span class="keyword">const</span> BundleAnalyzerPlugin = <span class="built_in">require</span>(<span class="string">'webpack-bundle-analyzer'</span>).BundleAnalyzerPlugin;</div><div class="line"></div><div class="line"><span class="keyword">const</span> PROJECT_ROOT = path.resolve(__dirname, <span class="string">'./'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: &#123;</div><div class="line">    <span class="attr">index</span>: <span class="string">'./src0/index.js'</span>,</div><div class="line">    <span class="attr">vendor</span>: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>, <span class="string">'react-router-dom'</span>, <span class="string">'immutable'</span>]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'dist'</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].[chunkhash:4].js'</span>,</div><div class="line">    <span class="attr">chunkFilename</span>: <span class="string">'[name].[chunkhash:4].child.js'</span>,</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">rules</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.js[x]?$/</span>,</div><div class="line">        <span class="attr">use</span>: <span class="string">'babel-loader'</span>,</div><div class="line">        <span class="attr">include</span>: PROJECT_ROOT,</div><div class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</div><div class="line">    <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">      <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'production'</span>)</div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> UglifyJSPlugin(&#123;</div><div class="line">      <span class="attr">uglifyOptions</span>: &#123;</div><div class="line">        <span class="attr">ie8</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">output</span>: &#123;</div><div class="line">          <span class="attr">comments</span>: <span class="literal">false</span>,</div><div class="line">          <span class="attr">beautify</span>: <span class="literal">false</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">mangle</span>: &#123;</div><div class="line">          <span class="attr">keep_fnames</span>: <span class="literal">true</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">compress</span>: &#123;</div><div class="line">          <span class="attr">warnings</span>: <span class="literal">false</span>,</div><div class="line">          <span class="attr">drop_console</span>: <span class="literal">true</span></div><div class="line">        &#125;,</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">      <span class="attr">name</span>: <span class="string">'vendor'</span>,</div><div class="line">      <span class="attr">minChunks</span>: <span class="literal">Infinity</span>,</div><div class="line">    &#125;),</div><div class="line">  ],</div><div class="line">  <span class="attr">resolve</span>: &#123;</div><div class="line">    <span class="attr">extensions</span>: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>]</div><div class="line">  &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>运行打包可以看到：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Hash: <span class="number">34</span>a71fcfd9a24e810c21</div><div class="line">Version: webpack <span class="number">3.6</span><span class="number">.0</span></div><div class="line">Time: <span class="number">9618</span>ms</div><div class="line">          Asset     Size  Chunks                    Chunk Names</div><div class="line"><span class="number">0.2</span>c65.child.js  <span class="number">5.82</span> kB       <span class="number">0</span>  [emitted]</div><div class="line"><span class="number">1.6e26</span>.child.js   <span class="number">4.4</span> kB       <span class="number">1</span>  [emitted]</div><div class="line"><span class="number">2.e4</span>bc.child.js     <span class="number">3</span> kB       <span class="number">2</span>  [emitted]</div><div class="line">  index<span class="number">.4e2</span>f.js  <span class="number">64.2</span> kB       <span class="number">3</span>  [emitted]         index</div><div class="line"> vendor<span class="number">.5</span>fd1.js   <span class="number">276</span> kB       <span class="number">4</span>  [emitted]  [big]  vendor</div></pre></td></tr></table></figure></p>
<p>可以看到 <code>vendor</code> 被单独打包出来了。</p>
<p>当我们改变业务代码时再次打包：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Hash: cd3f1bc16b28ac97e20a</div><div class="line">Version: webpack <span class="number">3.6</span><span class="number">.0</span></div><div class="line">Time: <span class="number">9750</span>ms</div><div class="line">          Asset     Size  Chunks                    Chunk Names</div><div class="line"><span class="number">0.2</span>c65.child.js  <span class="number">5.82</span> kB       <span class="number">0</span>  [emitted]</div><div class="line"><span class="number">1.6e26</span>.child.js   <span class="number">4.4</span> kB       <span class="number">1</span>  [emitted]</div><div class="line"><span class="number">2.e4</span>bc.child.js     <span class="number">3</span> kB       <span class="number">2</span>  [emitted]</div><div class="line">  index<span class="number">.4</span>d45.js  <span class="number">64.2</span> kB       <span class="number">3</span>  [emitted]         index</div><div class="line"> vendor.bc85.js   <span class="number">276</span> kB       <span class="number">4</span>  [emitted]  [big]  vendor</div></pre></td></tr></table></figure></p>
<p>vendor 包同样被打包出来的，然而它的文件 hash 却发生了变化，这显然不符合我们长缓存的需求。</p>
<p>这是因为 webpack 在使用 CommoChunkPlugin 的时候会生成一段 runtime 代码（它主要用来处理代码模块的映射关系），而哪怕没有改变 vendor 里的代码，这个 runtime 仍然是会跟随着打包变化的并且打入 verdor 中，所以 hash 就会开始变化了。解决方案则是把这部分的 runtime 代码也单独抽离出来，修改之前的 <code>CommonsChunkPlugin</code> 为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line">...</div><div class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">  <span class="attr">name</span>: [<span class="string">'vendor'</span>, <span class="string">'runtime'</span>],</div><div class="line">  <span class="attr">minChunks</span>: <span class="literal">Infinity</span>,</div><div class="line">&#125;),</div><div class="line">...</div></pre></td></tr></table></figure>
<p>执行打包可以看到生成的代码中多了 <code>runtime</code> 文件，同时即使改变业务代码，vendor 的 hash 值也保持不变了。</p>
<p>当然这段 <code>runtime</code> 实际上非常短，我们可以直接 inline 在 html 中，如果使用的是 <code>html-webpack-plugin</code> 插件处理 html，则可以结合 <a href="http://link.zhihu.com/?target=https%3A//github.com/DustinJackson/html-webpack-inline-source-plugin" target="_blank" rel="external"><code>html-webpack-inline-source-plugin</code></a> 插件自动处理其 inline。</p>
<h3 id="（2）公共资源抽离"><a href="#（2）公共资源抽离" class="headerlink" title="（2）公共资源抽离"></a>（2）公共资源抽离</h3><p>在我们打包出来的 js 资源包括不同入口以及子模块的 js 资源包，然而它们之间也会重复载入相同的依赖模块或者代码，因此可以通过 CommonsChunkPlugin 插件将它们共同依赖的一些资源打包成一个公共的 js 资源。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line">plugins: [</div><div class="line">  <span class="keyword">new</span> BundleAnalyzerPlugin(),</div><div class="line">  <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">    <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'production'</span>)</div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> UglifyJSPlugin(&#123;</div><div class="line">    <span class="attr">uglifyOptions</span>: &#123;</div><div class="line">      <span class="attr">ie8</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">comments</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">beautify</span>: <span class="literal">false</span>,</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">mangle</span>: &#123;</div><div class="line">        <span class="attr">keep_fnames</span>: <span class="literal">true</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">compress</span>: &#123;</div><div class="line">        <span class="attr">warnings</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">drop_console</span>: <span class="literal">true</span></div><div class="line">      &#125;,</div><div class="line">    &#125;</div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    <span class="attr">name</span>: [<span class="string">'vendor'</span>, <span class="string">'runtime'</span>],</div><div class="line">    <span class="attr">minChunks</span>: <span class="literal">Infinity</span>,</div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    <span class="comment">// ( 公共chunk(commnons chunk) 的名称)</span></div><div class="line">    name: <span class="string">"commons"</span>,</div><div class="line">    <span class="comment">// ( 公共chunk 的文件名)</span></div><div class="line">    filename: <span class="string">"commons.[chunkhash:4].js"</span>,</div><div class="line">    <span class="comment">// (模块必须被 3个 入口chunk 共享)</span></div><div class="line">    minChunks: <span class="number">3</span></div><div class="line">  &#125;)</div><div class="line">],</div></pre></td></tr></table></figure>
<p>可以看到这里增加了 <code>commons</code> 的一个打包，当一个资源被三个以及以上 chunk 依赖时，这些资源会被单独抽离打包到 <code>commons.[chunkhash:4].js</code> 文件。</p>
<p>执行打包，看到结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Hash: <span class="number">2577e42</span>dc5d8b94114c8</div><div class="line">Version: webpack <span class="number">3.6</span><span class="number">.0</span></div><div class="line">Time: <span class="number">24009</span>ms</div><div class="line">          Asset     Size  Chunks                    Chunk Names</div><div class="line"><span class="number">0.2</span>eee.child.js  <span class="number">90.8</span> kB       <span class="number">0</span>  [emitted]</div><div class="line"><span class="number">1.</span>cfbc.child.js  <span class="number">89.4</span> kB       <span class="number">1</span>  [emitted]</div><div class="line"><span class="number">2.557</span>a.child.js    <span class="number">88</span> kB       <span class="number">2</span>  [emitted]</div><div class="line"> vendor<span class="number">.66</span>fd.js   <span class="number">275</span> kB       <span class="number">3</span>  [emitted]  [big]  vendor</div><div class="line">  index<span class="number">.688</span>b.js  <span class="number">64.2</span> kB       <span class="number">4</span>  [emitted]         index</div><div class="line">commons.a61e.js  <span class="number">1.78</span> kB       <span class="number">5</span>  [emitted]         commons</div></pre></td></tr></table></figure></p>
<p>却发现这里的 <code>commons.[chunkhash].js</code> 基本没有实际内容，然而明明在每个子模块中也都依赖了一些相同的依赖。</p>
<p>借助 webpack-bundle-analyzer 来分析一波：<br><img src="/images/page/webpack/2.jpg" alt=""></p>
<p>可以看到三个模块都依赖了 <code>lodash</code>，然而它并没有被抽离出来。</p>
<p>这是因为 CommonsChunkPlugin 中的 chunk 指的是 entry 中的每个入口，因此对于一个入口拆分出来的子模块（children chunk）是不生效的。</p>
<p>可以通过在 CommonsChunkPlugin 插件中配置 <code>children</code> 参数将拆分出来的子模块的公共依赖也打包进 <code>commons</code> 中：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line">plugins: [</div><div class="line">  <span class="keyword">new</span> BundleAnalyzerPlugin(),</div><div class="line">  <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">    <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'production'</span>)</div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> UglifyJSPlugin(&#123;</div><div class="line">    <span class="attr">uglifyOptions</span>: &#123;</div><div class="line">      <span class="attr">ie8</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">comments</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">beautify</span>: <span class="literal">false</span>,</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">mangle</span>: &#123;</div><div class="line">        <span class="attr">keep_fnames</span>: <span class="literal">true</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">compress</span>: &#123;</div><div class="line">        <span class="attr">warnings</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">drop_console</span>: <span class="literal">true</span></div><div class="line">      &#125;,</div><div class="line">    &#125;</div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    <span class="attr">name</span>: [<span class="string">'vendor'</span>, <span class="string">'runtime'</span>],</div><div class="line">    <span class="attr">minChunks</span>: <span class="literal">Infinity</span>,</div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    <span class="comment">// ( 公共chunk(commnons chunk) 的名称)</span></div><div class="line">    name: <span class="string">"commons"</span>,</div><div class="line">    <span class="comment">// ( 公共chunk 的文件名)</span></div><div class="line">    filename: <span class="string">"commons.[chunkhash:4].js"</span>,</div><div class="line">    <span class="comment">// (模块必须被 3个 入口chunk 共享)</span></div><div class="line">    minChunks: <span class="number">3</span></div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    <span class="comment">// (选择所有被选 chunks 的子 chunks)</span></div><div class="line">    children: <span class="literal">true</span>,</div><div class="line">    <span class="comment">// (在提取之前需要至少三个子 chunk 共享这个模块)</span></div><div class="line">    minChunks: <span class="number">3</span>,</div><div class="line">  &#125;)</div><div class="line">],</div></pre></td></tr></table></figure></p>
<p>查看打包效果:<br><img src="/images/page/webpack/3.jpg" alt=""></p>
<p>其子模块的公共资源都被打包到 <code>index</code> 之中了，并没有理想地打包进 <code>commons</code> 之中，还是因为 <code>commons</code> 对于的是 entry 中的入口模块，而这里并未有 3 个 entry 模块共用资源；</p>
<p>在单入口的应用中可以选择去除 <code>commons</code>，而在子模块的 <code>CommonsChunkPlugin</code> 的配置中配置 <code>async</code> 为 <code>true</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// webpack.config.js</span></div><div class="line">plugins: [</div><div class="line">  <span class="keyword">new</span> BundleAnalyzerPlugin(),</div><div class="line">  <span class="keyword">new</span> webpack.DefinePlugin(&#123;</div><div class="line">    <span class="string">'process.env.NODE_ENV'</span>: <span class="built_in">JSON</span>.stringify(process.env.NODE_ENV || <span class="string">'production'</span>)</div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> UglifyJSPlugin(&#123;</div><div class="line">    <span class="attr">uglifyOptions</span>: &#123;</div><div class="line">      <span class="attr">ie8</span>: <span class="literal">false</span>,</div><div class="line">      <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">comments</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">beautify</span>: <span class="literal">false</span>,</div><div class="line">      &#125;,</div><div class="line">      <span class="attr">mangle</span>: &#123;</div><div class="line">        <span class="attr">keep_fnames</span>: <span class="literal">true</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">compress</span>: &#123;</div><div class="line">        <span class="attr">warnings</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">drop_console</span>: <span class="literal">true</span></div><div class="line">      &#125;,</div><div class="line">    &#125;</div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    <span class="attr">name</span>: [<span class="string">'vendor'</span>, <span class="string">'runtime'</span>],</div><div class="line">    <span class="attr">minChunks</span>: <span class="literal">Infinity</span>,</div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class="line">    <span class="comment">// (选择所有被选 chunks 的子 chunks)</span></div><div class="line">    children: <span class="literal">true</span>,</div><div class="line">    <span class="comment">// (异步加载)</span></div><div class="line">    <span class="keyword">async</span>: <span class="literal">true</span>,</div><div class="line">    <span class="comment">// (在提取之前需要至少三个子 chunk 共享这个模块)</span></div><div class="line">    minChunks: <span class="number">3</span>,</div><div class="line">  &#125;)</div><div class="line">],</div></pre></td></tr></table></figure>
<p>查看效果：<br><img src="/images/page/webpack/4.jpg" alt=""><br>子模块的公共资源都被打包到 <code>0.9c90.child.js</code> 中了，该模块则是子模块的 commons。</p>
<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><blockquote>
<p>tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。</p>
</blockquote>
<p>在我们引入一个依赖的某个输出的时候，我们可能需要的仅仅是该依赖的某一部分代码，而另一部分代码则是 <code>unused</code> 的，如果能够去除这部分代码，那么最终打包出来的资源体积也是可以有可观的减小。</p>
<p>首先，webpack 中实现 tree shaking 是基于 webpack 内部支持的 es2015 的模块机制，在大部分时候我们使用 babel 来编译 js 代码，而 babel 会通过自己的模块加载机制处理一遍，这导致 webpack 中的 tree shaking 处理将会失效。因此在 babel 的配置中需要关闭对模块加载的处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// .babelrc</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [</div><div class="line">    [</div><div class="line">      <span class="string">"env"</span>, &#123;</div><div class="line">        <span class="string">"modules"</span>: <span class="literal">false</span>,</div><div class="line">      &#125;</div><div class="line">    ],</div><div class="line">    <span class="string">"stage-0"</span></div><div class="line">  ],</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们来看下 webpack 是如何处理打包的代码，举例有一个入口文件 <code>index.js</code> 和一个 <code>utils.js</code> 文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// utils.js</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="keyword">import</span> &#123; cube &#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(cube(<span class="number">10</span>));</div></pre></td></tr></table></figure>
<p>打包出来的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.bundle.js</span></div><div class="line"><span class="comment">/* 1 */</span></div><div class="line"><span class="comment">/***/</span> (<span class="function"><span class="keyword">function</span>(<span class="params">module, __webpack_exports__, __webpack_require__</span>) </span>&#123;</div><div class="line"><span class="meta"></span></div><div class="line">"use strict";</div><div class="line"><span class="comment">/* unused harmony export square */</span></div><div class="line"><span class="comment">/* harmony export (immutable) */</span> __webpack_exports__[<span class="string">"a"</span>] = cube;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">cube</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> x * x * x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到仅有 <code>cube</code> 函数被 <code>__webpack_exports__</code> 导出来，而 <code>square</code> 函数被标记为 <code>unused harmony export square</code>，然而在打包代码中既是 <code>square</code> 没有被导出但是它仍然存在与代码中，而如何去除其代码则可以通过添加 <code>UglifyjsWebpackPlugin</code> 插件来处理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在前端应用的优化中，对加载资源的大小控制极其的重要，大多数时候我们能做的是在打包编译的过程对资源进行大小控制、拆分与复用。&lt;/p&gt;
&lt;p&gt;本片文章中主要是基于 webpack 打包，以 React、vue 等生态开发的单页面应用来举例说明如何从 webpack 打包的层面去处理资源以及缓存，其中主要我们需要做的是对 webpack 进行配置的优化，同时涉及少量的业务代码的更改。&lt;/p&gt;
&lt;p&gt;同时对打包资源的分析可以使用 (&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/webpack-bundle-analyzer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;webpack-contrib/webpack-bundle-analyzer&lt;/a&gt;) 插件，当然可选的分析插件还是很多的，在本文中主要以该插件来举例分析。&lt;br&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack postcss配置</title>
    <link href="http://html-js.site/2017/10/18/webpack-postcss%E9%85%8D%E7%BD%AE/"/>
    <id>http://html-js.site/2017/10/18/webpack-postcss配置/</id>
    <published>2017-10-18T06:30:28.000Z</published>
    <updated>2017-10-18T06:44:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>折腾记：最近一直在写react项目，遇到了不少坑，比如客户端开发使用了antd-mobile库，也使用了推荐的<a href="https://github.com/ant-design/ant-design-mobile/wiki/HD" target="_blank" rel="external">高清方案</a>，但是组件都是使用px为单位的，所以需要集成postcss来进行转换rem</p>
</blockquote>
<h3 id="安装postcss相关npm包"><a href="#安装postcss相关npm包" class="headerlink" title="安装postcss相关npm包"></a>安装postcss相关npm包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install postcss-loader postcss-pxtorem --save-dev</div></pre></td></tr></table></figure>
<h3 id="webpack集成postcss"><a href="#webpack集成postcss" class="headerlink" title="webpack集成postcss"></a>webpack集成postcss</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webpack.config.js</span></div><div class="line"><span class="keyword">const</span> pxtorem = <span class="built_in">require</span>(<span class="string">'postcss-pxtorem'</span>);</div><div class="line"><span class="comment">// ....</span></div><div class="line">&#123;</div><div class="line">    <span class="attr">postcss</span>: [</div><div class="line">        pxtorem(&#123;</div><div class="line">            <span class="attr">rootValue</span>: <span class="number">100</span>,</div><div class="line">            <span class="attr">propWhiteList</span>: []</div><div class="line">        &#125;),</div><div class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="设定post-loader"><a href="#设定post-loader" class="headerlink" title="设定post-loader"></a>设定post-loader</h3><p>改写loaders，比如要对.css文件进行过滤:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">loaders: [</div><div class="line">    &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'style-loader!css-loader!postcss-loader'</span></div><div class="line">    &#125;,</div><div class="line">]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;折腾记：最近一直在写react项目，遇到了不少坑，比如客户端开发使用了antd-mobile库，也使用了推荐的&lt;a href=&quot;https://github.com/ant-design/ant-design-mobile/wiki/HD&quot; tar
    
    </summary>
    
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>lodash学习笔记</title>
    <link href="http://html-js.site/2017/10/11/lodash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://html-js.site/2017/10/11/lodash学习笔记/</id>
    <published>2017-10-11T15:10:16.000Z</published>
    <updated>2017-10-11T15:28:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lodash 是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前 ECMAScript 尚未制定的规范，但同时被业界所认可的辅助函数。目前每天使用 npm 安装 Lodash 的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。</p>
<h2 id="模块组成"><a href="#模块组成" class="headerlink" title="模块组成"></a>模块组成</h2><p>Lodash提供的辅助函数主要分为以下几类:</p>
<ul>
<li><code>Array</code>，适用于数组类型，比如填充数据，部分适用于字符串，比如分组、查找、过滤等操作。</li>
<li><code>Collection</code>，适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作。</li>
<li><code>Function</code>，适用于函数类型，比如节流、延迟、缓存、设置钩子等操作。</li>
<li><code>Lang</code>，普遍适用于各种类型，常用于执行类型判断和类型转换。</li>
<li><code>Math</code>，适用于数组类型，常用于执行数学运算。</li>
<li><code>Number</code>，适用于生成随机数，比较数值与数值区间的关系。</li>
<li><code>Object</code>，适用于对象类型，常用于对象的创建、扩展、类型转换、检索、集合等操作。</li>
<li><code>Seq</code>，常用于创建链式调用，提高执行性能（惰性计算）。</li>
<li><code>String</code>，适用于字符串类型。</li>
</ul>
<a id="more"></a>
<h2 id="若干方法"><a href="#若干方法" class="headerlink" title="若干方法"></a>若干方法</h2><p>受益于 Lodash 的普及程度，使用它可以提高多人开发时阅读代码的效率，减少彼此之间的误解。</p>
<h3 id="N次循环"><a href="#N次循环" class="headerlink" title="N次循环"></a>N次循环</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//1.基础循环</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//2.使用Array.apply模拟循环</span></div><div class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="built_in">Array</span>(<span class="number">5</span>)).forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// ... </span></div><div class="line">&#125;)</div><div class="line"><span class="comment">//3.Lodash</span></div><div class="line">_.times(<span class="number">5</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>for是循环的首选，但是_.times()的解决方式更加简洁和易于理解。</p>
<h3 id="深层查找属性值"><a href="#深层查找属性值" class="headerlink" title="深层查找属性值"></a>深层查找属性值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回pets[0].name</span></div><div class="line"><span class="keyword">var</span> ownerArr=[&#123;</div><div class="line">  <span class="string">"owner"</span>:<span class="string">"wl"</span>,</div><div class="line">  <span class="string">"pets"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"dog1"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"dog2"</span>&#125;]</div><div class="line">&#125;,&#123;</div><div class="line">  <span class="string">"owner"</span>:<span class="string">"qw"</span>,</div><div class="line">  <span class="string">"pets"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"dog3"</span>&#125;,&#123;<span class="string">"name"</span>:<span class="string">"dog4"</span>&#125;]</div><div class="line">&#125;];</div><div class="line"><span class="comment">//Array的map方法</span></div><div class="line">ownerArr.map(<span class="function"><span class="keyword">function</span>(<span class="params">owner</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> owner.pets[<span class="number">0</span>].name</div><div class="line">&#125;)</div><div class="line"><span class="comment">//Lodash</span></div><div class="line">_.map(ownerArr,<span class="string">'pets[0].name'</span>);</div></pre></td></tr></table></figure>
<p>_.map方法是对原生map方法的改进，其中使用pets[0].name字符串对嵌套数据取值的方式简化了很多冗余的代码。</p>
<h3 id="个性化数组"><a href="#个性化数组" class="headerlink" title="个性化数组"></a>个性化数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Array的map方法</span></div><div class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>,<span class="built_in">Array</span>(<span class="number">6</span>)).map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">"ball_"</span>+index;</div><div class="line">&#125;)</div><div class="line"><span class="comment">//Lodash</span></div><div class="line">_.times(<span class="number">6</span>,_.uniqueId.bind(<span class="literal">null</span>,<span class="string">'ball_'</span>))</div><div class="line"><span class="comment">//Lodash</span></div><div class="line">_.times(<span class="number">6</span>,_.partial(_.uniqueId,<span class="string">'ball_'</span>))</div></pre></td></tr></table></figure>
<p>在上面的代码中，我们要创建一个初始值不同，长度为6的数组，其中_.uniqueId方法用于生成独一无二的标识符（递增的数字，在程序运行期间保持独一无二），_partial方法是对bind的封装。</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> objA=&#123;</div><div class="line">  <span class="string">"name"</span>:<span class="string">"wl"</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//Lodash</span></div><div class="line"><span class="keyword">var</span> objB=_.cloneDeep(objA);</div><div class="line"><span class="built_in">console</span>.log(objA===objB)<span class="comment">//false</span></div></pre></td></tr></table></figure>
<p>JavaScript没有直接提供深拷贝的函数，但我们可以用其他函数来模拟，比如JSON.parse(JSON.stringify(objectToClone)),但这种方法要求对象中的属性值不能是函数。Lodash中的_.cloneDeep函数封装了深拷贝的逻辑，用起来更简洁。</p>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//js方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomNumber</span>(<span class="params">min,max</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max-min+<span class="number">1</span>))+min;</div><div class="line">&#125;</div><div class="line">getRandomNumber(<span class="number">15</span>,<span class="number">20</span>);</div><div class="line"><span class="comment">//Lodash</span></div><div class="line">_.random(<span class="number">15</span>,<span class="number">20</span>)</div></pre></td></tr></table></figure>
<p>Lodash的随机数生成函数更贴近实际开发，ECMAScript的随机数生成函数是底层必备的接口，两者都不可或缺。此外，使用_.random(15,20,true)还可以在15到20之间生成随机的浮点数。</p>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.extend=<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</div><div class="line">    <span class="keyword">if</span>(obj.hasOwnProperty(i))&#123;</div><div class="line">      <span class="keyword">this</span>[i]=obj[i];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> objA=&#123;<span class="string">"name"</span>:<span class="string">"wl"</span>,<span class="string">"car"</span>:<span class="string">"benz"</span>&#125;;</div><div class="line"><span class="keyword">var</span> objB=&#123;<span class="string">"name"</span>:<span class="string">"jam"</span>,<span class="string">"age"</span>:<span class="number">17</span>&#125;;</div><div class="line">objA.extend(objB);</div><div class="line">objA;<span class="comment">//&#123;"name":"jam","age":17,"car":"benz"&#125;;</span></div><div class="line"><span class="comment">//Lodash</span></div><div class="line">_.assign(objA,objB)</div></pre></td></tr></table></figure>
<blockquote>
<p>_.assign分配来源对象的可枚举属性到目标对象上。 来源对象的应用规则是从左到右，随后的下一个对象的属性会覆盖上一个对象的属性。<br>注意：这方法会改变源对象，参考自Object.assign</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.c=<span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.e=<span class="number">5</span>;</div><div class="line">&#125;</div><div class="line">Foo.prototype.d=<span class="number">4</span>;</div><div class="line">Bar.prototype.f=<span class="number">6</span>;</div><div class="line">_.assign(&#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;,<span class="keyword">new</span> Foo,<span class="keyword">new</span> Bar);</div><div class="line"><span class="comment">//=&gt;&#123;'a':1,'c':3,'e':5&#125;</span></div></pre></td></tr></table></figure>
<h3 id="筛选属性"><a href="#筛选属性" class="headerlink" title="筛选属性"></a>筛选属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.remove=<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> that=<span class="keyword">this</span>;</div><div class="line">  arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">    <span class="keyword">delete</span>(that[key]);</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> objA=&#123;<span class="string">"name"</span>:<span class="string">"colin"</span>,<span class="string">"car"</span>:<span class="string">"suzuki"</span>,<span class="string">"age"</span>:<span class="number">17</span>&#125;;</div><div class="line">objA.remove([<span class="string">'car'</span>,<span class="string">'age'</span>]);</div><div class="line">objA;<span class="comment">//&#123;"name":"colin"&#125;</span></div><div class="line"><span class="comment">//Lodash</span></div><div class="line">objA=_.omit(objA,[<span class="string">'car'</span>,<span class="string">'age'</span>]);</div><div class="line"><span class="comment">//=&gt;&#123;"name":"colin"&#125;</span></div><div class="line">objA=_.omit(objA,<span class="string">'car'</span>);</div><div class="line"><span class="comment">//=&gt;&#123;"name":"colin","age":17&#125;;</span></div></pre></td></tr></table></figure>
<p>大多数情况下，Lodash所提供的辅助函数都会比原生的函数更贴近开发需求。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.pick=<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> that=<span class="keyword">this</span>;</div><div class="line">  <span class="keyword">var</span> obj=&#123;&#125;;</div><div class="line">  arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">    obj[key]=that[key];</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> objA=&#123;<span class="string">"name"</span>: <span class="string">"colin"</span>, <span class="string">"car"</span>: <span class="string">"suzuki"</span>, <span class="string">"age"</span>: <span class="number">17</span>&#125;;</div><div class="line"><span class="keyword">var</span> objB=objA.pick([<span class="string">'car'</span>,<span class="string">'age'</span>]);</div><div class="line"><span class="comment">//&#123;"car":"suzuki","age":17&#125;</span></div><div class="line"><span class="comment">//Lodash</span></div><div class="line"><span class="keyword">var</span> objB=_.pick(objA,[<span class="string">'car'</span>,<span class="string">'age'</span>]);</div><div class="line"><span class="comment">//&#123;"car":"suzuki","age":17&#125;</span></div></pre></td></tr></table></figure></p>
<p><em>.pick是</em>.omit的相反操作，用于从其他对象中挑选属性生成新的对象。</p>
<h3 id="随机元素"><a href="#随机元素" class="headerlink" title="随机元素"></a>随机元素</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> luckyDraw=[<span class="string">"Colin"</span>,<span class="string">"John"</span>,<span class="string">"James"</span>,<span class="string">"Lily"</span>,<span class="string">"Mary"</span>];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickRandomPerson</span>(<span class="params">luckyDraw</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> index=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(luckyDraw.length<span class="number">-1</span>));</div><div class="line">  <span class="keyword">return</span> luckyDraw[index];</div><div class="line">&#125;</div><div class="line">pickRandomPerson(luckyDraw);<span class="comment">//John</span></div><div class="line"><span class="comment">//Lodash</span></div><div class="line">_.sample(luckyDraw);<span class="comment">//Colin</span></div><div class="line"><span class="comment">//Lodash-Getting 2 random item</span></div><div class="line">_.sample(luckyDraw,<span class="number">2</span>);<span class="comment">//['Jhon','Lily']</span></div></pre></td></tr></table></figure>
<p>_.sample支持随机挑选多个元素并返回新的数组。</p>
<h3 id="针对JSON-parse的错误处理"><a href="#针对JSON-parse的错误处理" class="headerlink" title="针对JSON.parse的错误处理"></a>针对JSON.parse的错误处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(str);</div><div class="line">  &#125;<span class="keyword">catch</span>(e)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//With Lodash</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseLodash</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> _.attempt(<span class="built_in">JSON</span>.parse.bind(<span class="literal">null</span>,str));</div><div class="line">&#125;</div><div class="line">parse(<span class="string">'a'</span>);</div><div class="line"><span class="comment">//=&gt;false</span></div><div class="line">parseLodash(<span class="string">'a'</span>);</div><div class="line"><span class="comment">//=&gt;return an error object</span></div><div class="line">parse(<span class="string">'&#123;"name":"colin"&#125;'</span>);</div><div class="line"><span class="comment">//=&gt;return &#123;"name":"colin"&#125;</span></div><div class="line">parseLodash(<span class="string">'&#123;"name":"colin"&#125;'</span>);</div><div class="line"><span class="comment">//=&gt;return &#123;"name":"colin"&#125;</span></div></pre></td></tr></table></figure>
<p>如果你在使用JSON.parse时没有预置错误处理，那么它很有可能会成为一个定时炸弹，我们不应该默认接受的JSON对象都是有效的。try-catch是最常见的错误处理方式，如果项目中Loadsh，那么可以使用_.attmpt替代try-catch的方式，当解析JSON出错时，该方法会返回一个Error对象。</p>
<blockquote>
<p>随着 ES6 的普及，Lodash 的功能或多或少会被原生功能所替代，所以使用时还需要进一步甄别，建议优先使用原生函数。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lodash 是这样的一套工具库，它内部封装了诸多对字符串、数组、对象等常见数据类型的处理函数，其中部分是目前 ECMAScript 尚未制定的规范，但同时被业界所认可的辅助函数。目前每天使用 npm 安装 Lodash 的数量在百万级以上，这在一定程度上证明了其代码的健壮性，值得我们在项目中一试。&lt;/p&gt;
&lt;h2 id=&quot;模块组成&quot;&gt;&lt;a href=&quot;#模块组成&quot; class=&quot;headerlink&quot; title=&quot;模块组成&quot;&gt;&lt;/a&gt;模块组成&lt;/h2&gt;&lt;p&gt;Lodash提供的辅助函数主要分为以下几类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Array&lt;/code&gt;，适用于数组类型，比如填充数据，部分适用于字符串，比如分组、查找、过滤等操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Collection&lt;/code&gt;，适用于数组和对象类型，部分适用于字符串，比如分组、查找、过滤等操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function&lt;/code&gt;，适用于函数类型，比如节流、延迟、缓存、设置钩子等操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lang&lt;/code&gt;，普遍适用于各种类型，常用于执行类型判断和类型转换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Math&lt;/code&gt;，适用于数组类型，常用于执行数学运算。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Number&lt;/code&gt;，适用于生成随机数，比较数值与数值区间的关系。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object&lt;/code&gt;，适用于对象类型，常用于对象的创建、扩展、类型转换、检索、集合等操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Seq&lt;/code&gt;，常用于创建链式调用，提高执行性能（惰性计算）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;，适用于字符串类型。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
      <category term="lodash" scheme="http://html-js.site/tags/lodash/"/>
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="http://html-js.site/2017/10/11/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <id>http://html-js.site/2017/10/11/函数柯里化/</id>
    <published>2017-10-11T15:00:59.000Z</published>
    <updated>2017-10-11T15:07:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家哈斯凯尔·加里命名的，尽管它是 Moses Schönfinkel 和 Gottlob Frege 发明的。</p>
<p>这是来自维基百科的名词解释。顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。</p>
<a id="more"></a>
<p>看一下通用实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice,</div><div class="line">    __args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> __inargs = slice.call(<span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, __args.concat(__inargs));</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>柯里化的实用性体现在很多方面：</p>
<h3 id="提高适用性。"><a href="#提高适用性。" class="headerlink" title="提高适用性。"></a>提高适用性。</h3><p>【通用函数】解决了兼容性问题，但同时也会再来，使用的不便利性，不同的应用场景往，要传递很多参数，以达到解决特定问题的目的。有时候应用中，同一种规则可能会反复使用，这就可能会造成代码的重复性。</p>
<p>看下面一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> i * i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dubble</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> i *= <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">handeler, list</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> list.map(handeler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 数组的每一项平方</span></div><div class="line">map(square, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">map(square, [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);</div><div class="line">map(square, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]);</div><div class="line"><span class="comment">// ......</span></div><div class="line"></div><div class="line"><span class="comment">// 数组的每一项加倍</span></div><div class="line">map(dubble, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">map(dubble, [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);</div><div class="line">map(dubble, [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]);</div></pre></td></tr></table></figure></p>
<p>例子中，创建了一个map通用函数，用于适应不同的应用场景。显然，通用性不用怀疑。同时，例子中重复传入了相同的处理函数：square和dubble。</p>
<p>应用中这种可能会更多。当然，通用性的增强必然带来适用性的减弱。但是，我们依然可以在中间找到一种平衡。</p>
<p>看下面，我们利用柯里化改造一下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> i * i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dubble</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> i *= <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">handeler, list</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> list.map(handeler);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> mapSQ = currying(map, square);</div><div class="line">mapSQ([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">mapSQ([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);</div><div class="line">mapSQ([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]);</div><div class="line"><span class="comment">// ......</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> mapDB = currying(map, dubble);</div><div class="line">mapDB([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">mapDB([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]);</div><div class="line">mapDB([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>]);</div><div class="line"><span class="comment">// ......</span></div></pre></td></tr></table></figure></p>
<p>我们缩小了函数的适用范围，但同时提高函数的适性。当然，也有扩展函数适用范围的方法–反柯里化，留到下一篇再讨论。</p>
<p>由此，可知柯里化不仅仅是提高了代码的合理性，更重的它突出一种思想—降低适用范围，提高适用性。</p>
<p>下面再看一个例子，一个应用范围更广泛更熟悉的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ajax</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">&#125;</div><div class="line"></div><div class="line">Ajax.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params">type, url, data, callback</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        callback(<span class="keyword">this</span>.xhr.responseText, <span class="keyword">this</span>.xhr.status, <span class="keyword">this</span>.xhr);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.xhr.open(type, url, data.async);</div><div class="line">    <span class="keyword">this</span>.xhr.send(data.paras);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="string">'get post'</span>.split(<span class="string">' '</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">mt</span>) </span>&#123;</div><div class="line">    Ajax.prototype[mt] = currying(Ajax.prototype.open, mt);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> Ajax();</div><div class="line">xhr.get(<span class="string">'/articles/list.php'</span>, &#123;&#125;,</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">datas</span>) </span>&#123;</div><div class="line">    <span class="comment">// done(datas)    </span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> xhr1 = <span class="keyword">new</span> Ajax();</div><div class="line">xhr1.post(<span class="string">'/articles/add.php'</span>, &#123;&#125;,</div><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">datas</span>) </span>&#123;</div><div class="line">    <span class="comment">// done(datas)    </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>柯里化的另一个应用场景是延迟执行。不断的柯里化，累积传入的参数，最后执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>,</div><div class="line">    _args = <span class="built_in">arguments</span></div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</div><div class="line">            <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,</div><div class="line">            c; c = _args[i++];) sum += c</div><div class="line">            <span class="keyword">return</span> sum</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">Array</span>.prototype.push.apply(_args, <span class="built_in">arguments</span>) <span class="keyword">return</span> <span class="built_in">arguments</span>.callee</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)();<span class="comment">//10</span></div></pre></td></tr></table></figure></p>
<p>通用的写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> curry = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _args = []</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, _args)</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">Array</span>.prototype.push.apply(_args, <span class="built_in">arguments</span>);</div><div class="line">        <span class="keyword">return</span> cb;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="固定易变因素"><a href="#固定易变因素" class="headerlink" title="固定易变因素"></a>固定易变因素</h3><p>柯里化特性决定了它这应用场景。提前把易变因素，传参固定下来，生成一个更明确的应用函数。最典型的代表应用，是bind函数用以固定this这个易变对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>,</div><div class="line">    _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> _this.apply(context, _args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)))</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由 Christopher Strachey 以逻辑学家哈斯凯尔·加里命名的，尽管它是 Moses Schönfinkel 和 Gottlob Frege 发明的。&lt;/p&gt;
&lt;p&gt;这是来自维基百科的名词解释。顾名思义，柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求。这增加了函数的适用性，但同时也降低了函数的适用范围。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>git学习</title>
    <link href="http://html-js.site/2017/09/13/git%E5%AD%A6%E4%B9%A0/"/>
    <id>http://html-js.site/2017/09/13/git学习/</id>
    <published>2017-09-13T06:58:40.000Z</published>
    <updated>2017-09-13T06:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>git config –global user.name “username”<br>git config –global user.email “email”</p>
<p>提交流程：<br>git add .<br>git commit -m “代码提交信息”<br>git pull “代码提交信息”<br>git push origin <local_branch> # 创建远程分支， origin是远程仓库名</local_branch></p>
<p>git branch branchName 创建新分支<br>git checkout branchName 切换到新分支</p>
<p>查看、添加、提交、删除、找回，重置修改文件<br>git help <command> # 显示command的help<br>git show # 显示某次提交的内容 git show $id<br>git co – <file> # 抛弃工作区修改<br>git co . # 抛弃工作区修改<br>git add <file> # 将工作文件修改提交到本地暂存区<br>git add . # 将所有修改过的工作文件提交暂存区<br>git rm <file> # 从版本库中删除文件<br>git rm <file> –cached # 从版本库中删除文件，但不删除文件<br>git reset <file> # 从暂存区恢复到工作文件<br>git reset – . # 从暂存区恢复到工作文件<br>git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改<br>git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　git ci -am “some comments”<br>git ci –amend # 修改最后一次提交记录<br>git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象<br>git revert HEAD # 恢复最后一次提交的状态</file></file></file></file></file></file></p>
<p>git commit -m “代码提交信息”</p>
<p>查看文件diff<br>git diff <file> # 比较当前文件和暂存区文件差异 git diff<br>git diff <id1><id1><id2> # 比较两次提交之间的差异<br>git diff <branch1>..<branch2> # 在两个分支之间比较<br>git diff –staged # 比较暂存区和版本库差异<br>git diff –cached # 比较暂存区和版本库差异<br>git diff –stat # 仅仅比较统计信息</branch2></branch1></id2></id1></id1></file></p>
<p>查看提交记录<br>git log git log <file> # 查看该文件每次提交记录<br>git log -p <file> # 查看每次详细修改内容的diff<br>git log -p -2 # 查看最近两次详细修改内容的diff<br>git log –stat #查看提交统计信息<br>tig Mac上可以使用tig代替diff和log，brew install tig<br>Git 本地分支管理</file></file></p>
<p>查看、切换、创建和删除分支<br>git br -r # 查看远程分支<br>git br <new_branch> # 创建新的分支<br>git br -v # 查看各个分支最后提交信息<br>git br –merged # 查看已经被合并到当前分支的分支<br>git br –no-merged # 查看尚未被合并到当前分支的分支<br>git co <branch> # 切换到某个分支<br>git co -b <new_branch> # 创建新的分支，并且切换过去<br>git co -b <new_branch> <branch> # 基于branch创建新的new_branch<br>git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除<br>git co $id -b <new_branch> # 把某次历史提交记录checkout出来，创建成一个分支<br>git br -d <branch> # 删除某个分支<br>git br -D <branch> # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</branch></branch></new_branch></branch></new_branch></new_branch></branch></new_branch></p>
<p>分支合并和rebase<br>git merge <branch> # 将branch分支合并到当前分支<br>git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交<br>git rebase master <branch> # 将master rebase到branch，相当于： git co <branch> &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge <branch><br>Git补丁管理(方便在多台机器上开发同步时用)<br>git diff &gt; ../sync.patch # 生成补丁<br>git apply ../sync.patch # 打补丁<br>git apply –check ../sync.patch #测试补丁能否成功</branch></branch></branch></branch></p>
<p>Git暂存管理<br>git stash # 暂存<br>git stash list # 列所有stash<br>git stash apply # 恢复暂存的内容<br>git stash drop # 删除暂存区</p>
<p>Git远程分支管理<br>git pull # 抓取远程仓库所有分支更新并合并到本地<br>git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并<br>git fetch origin # 抓取远程仓库更新<br>git merge origin/master # 将远程主分支合并到本地当前分支<br>git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支<br>git co -b <local_branch> origin/<remote_branch> # 基于远程分支创建本地分支，功能同上<br>git push # push所有分支<br>git push origin master # 将本地主分支推到远程主分支<br>git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)<br>git push origin <local_branch> # 创建远程分支， origin是远程仓库名<br>git push origin <local_branch>:<remote_branch> # 创建远程分支<br>git push origin :<remote_branch> #先删除本地分支(git br -d <branch>)，然后再push删除远程分支<br>删除远程分支<br>git branch -a<br>git branch -r -d origin/branch-name<br>git push origin :branch-name</branch></remote_branch></remote_branch></local_branch></local_branch></remote_branch></local_branch></p>
<p>Git远程仓库管理<br>GitHub<br>git remote -v # 查看远程服务器地址和仓库名称<br>git remote show origin # 查看远程服务器仓库状态<br>git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址<br>git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm <repository> # 删除远程仓库</repository></p>
<p>创建远程仓库<br>git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库<br>scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上<br>mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库<br>git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址<br>git push -u origin master # 客户端首次提交<br>git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track<br>git remote set-head origin master # 设置远程仓库的HEAD指向master分支</p>
<p>也可以命令设置跟踪远程库和本地库<br>git branch –set-upstream master origin/master<br>git branch –set-upstream develop origin/develop</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git config –global user.name “username”&lt;br&gt;git config –global user.email “email”&lt;/p&gt;
&lt;p&gt;提交流程：&lt;br&gt;git add .&lt;br&gt;git commit -m “代码提交信息”&lt;br&gt;g
    
    </summary>
    
    
      <category term="git" scheme="http://html-js.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>javascript进阶-惰性函数</title>
    <link href="http://html-js.site/2017/09/09/javascript%E8%BF%9B%E9%98%B6-%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0/"/>
    <id>http://html-js.site/2017/09/09/javascript进阶-惰性函数/</id>
    <published>2017-09-09T07:15:03.000Z</published>
    <updated>2017-09-09T07:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>函数是js世界的一等公民，js的动态性、易变性在函数的应用上，体现的淋漓尽致。做为参数，做为返回值等，正是函数这些特性，使得js开发变的有趣。</p>
</blockquote>
<p>下面就阐述一下，js一个有趣的应用–惰性函数定义（Lazy Function Definition）。</p>
<p>惰性载入表示函数执行的分支只会在函数第一次掉用的时候执行，在第一次调用过程中，该函数会被覆盖为另一个按照合适方式执行的函数，这样任何对原函数的调用就不用再经过执行的分支了。</p>
<p>下面我们看几个典型的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">        element.addEventListener(type, fun, <span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</div><div class="line">        element.attachEvent(<span class="string">'on'</span> + type, fun);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        element[<span class="string">'on'</span> + type] = fun;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面是注册函数监听的各浏览器兼容函数。由于，各浏览之间的差异，不得不在用的时候做能力检测。显然，单从功能上讲，已经做到了兼容浏览器。美中不足，每次绑定监听，都会对能力做一次检测。然而，真正的应用中，这显然是多余的，同一个应用环境中，其实只需要检测一次即可。</p>
<p>下面我们重写上面的addEvent：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">            element.addEventListener(type, fun, <span class="literal">false</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</div><div class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">            element.attachEvent(<span class="string">'on'</span> + type, fun);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">type, element, fun</span>) </span>&#123;</div><div class="line">            element[<span class="string">'on'</span> + type] = fun;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addEvent(type, element, fun);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由上，第一次调用addEvent会对浏览器做能力检测，然后，重写了addEvent。下次再调用的时候，由于函数被重写，不会再做能力检测。</p>
<p>同样的应用，javascript高级程序设计里的一例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>)&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>)&#123;</div><div class="line">            <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>,</div><div class="line">                            <span class="string">"MSXML2.XMLHttp"</span>];</div><div class="line">    </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>,len=versions.length; i &lt; len; i++)&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(versions[i]);</div><div class="line">                    <span class="built_in">arguments</span>.callee.activeXString = versions[i];</div><div class="line">                    <span class="keyword">return</span> xhr;</div><div class="line">                &#125; <span class="keyword">catch</span> (ex)&#123;</div><div class="line">                    <span class="comment">//skip</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很显然，惰性函数在这里优势更加明显，因为这里有更多的分支。下面我们看一下重写后台的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>) &#123;</div><div class="line">        createXHR = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>) &#123;</div><div class="line">        <span class="keyword">var</span> curxhr;</div><div class="line">        <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>,</div><div class="line">            <span class="string">"MSXML2.XMLHttp"</span>];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = versions.length; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(versions[i]);</div><div class="line">                curxhr = versions[i];</div><div class="line">                createXHR = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(curxhr);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> xhr;</div><div class="line">            &#125; <span class="keyword">catch</span> (ex) &#123;</div><div class="line">                <span class="comment">//skip</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>浏览器之间最大的差异，莫过于Dom操作，Dom操作也是前端应用 中最频繁的操作，前端的大多性能提升，均体现在Dom操作方面。下面看一个Dom操作方面的惰性函数定义例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.pageYOffset == <span class="string">'number'</span>) &#123;</div><div class="line"></div><div class="line">        getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">window</span>.pageYOffset;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">typeof</span> <span class="built_in">document</span>.compatMode == <span class="string">'string'</span>) &amp;&amp;</div><div class="line">               (<span class="built_in">document</span>.compatMode.indexOf(<span class="string">'CSS'</span>) &gt;= <span class="number">0</span>) &amp;&amp;</div><div class="line">               (<span class="built_in">document</span>.documentElement) &amp;&amp;</div><div class="line">               (<span class="keyword">typeof</span> <span class="built_in">document</span>.documentElement.scrollTop == <span class="string">'number'</span>)) &#123;</div><div class="line"></div><div class="line">        getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="built_in">document</span>.documentElement.scrollTop;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">document</span>.body) &amp;&amp;</div><div class="line">               (<span class="keyword">typeof</span> <span class="built_in">document</span>.body.scrollTop == <span class="string">'number'</span>)) &#123;</div><div class="line"></div><div class="line">      getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="built_in">document</span>.body.scrollTop;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">      getScrollY = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="literal">NaN</span>;</div><div class="line">      &#125;;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> getScrollY();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>惰性函数定义应用还体现在创建单例上：(目前还不清楚创建单例的话有什么好处)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">unction Universe() &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 缓存的实例</span></div><div class="line">    <span class="keyword">var</span> instance = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 其它内容</span></div><div class="line">    <span class="keyword">this</span>.start_time = <span class="number">0</span>;</div><div class="line">    <span class="keyword">this</span>.bang = <span class="string">"Big"</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 重写构造函数</span></div><div class="line">    Universe = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，像上面这种例子有很多。惰性函数定义，应用场景我们可以总结一下：</p>
<p>1 应用频繁，如果只用一次，是体现不出它的优点出来的，用的次数越多，越能体现这种模式的优势所在；</p>
<p>2 固定不变，一次判定，在固定的应用环境中不会发生改变；</p>
<p>3 复杂的分支判断，没有差异性，不需要应用这种模式；</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;函数是js世界的一等公民，js的动态性、易变性在函数的应用上，体现的淋漓尽致。做为参数，做为返回值等，正是函数这些特性，使得js开发变的有趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面就阐述一下，js一个有趣的应用–惰性函数定义（Lazy F
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
      <category term="javascript进阶" scheme="http://html-js.site/tags/javascript%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>react-router 按需加载</title>
    <link href="http://html-js.site/2017/09/09/react-router-%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD/"/>
    <id>http://html-js.site/2017/09/09/react-router-按需加载/</id>
    <published>2017-09-08T16:54:49.000Z</published>
    <updated>2017-09-08T17:16:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>注：本文使用的 react-router 版本为 2.8.1</p>
</blockquote>
<p>React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript 文件变得巨大，这导致首页渲染的时间让人难以忍受。实际上程序应当只加载当前渲染页所需的 JavaScript，也就是大家说的“代码分拆” — 将所有的代码分拆成多个小包，在用户浏览过程中按需加载。</p>
<p>效果：<br>以前是这样：<br><img src="/images/page/reactRouter/01.png" alt=""></p>
<p>现在是这样：<img src="/images/page/reactRouter/02.png" alt=""></p>
<p>实际上就是将一个大 javascript 文件拆分成了若干个 chunk file。</p>
<p>下面是改造过程</p>
<h2 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h2><p>首先在 <code>webpack.config.js</code> 的 <code>output</code> 内加上 <code>chunkFilename</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">'/../dist/assets'</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">'app.js'</span>,</div><div class="line">    <span class="attr">publicPath</span>: defaultSettings.publicPath,</div><div class="line">    <span class="comment">// 添加 chunkFilename</span></div><div class="line">    chunkFilename: <span class="string">'[name].[chunkhash:5].chunk.js'</span>,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p><code>name</code> 是在代码里为创建的 <code>chunk</code> 指定的名字，如果代码中没指定则 <code>webpack</code> 默认分配 <code>id</code> 作为 <code>name</code>。</p>
<p><code>chunkhash</code> 是文件的 <code>hash</code> 码，这里只使用前五位。</p>
<h2 id="添加首页"><a href="#添加首页" class="headerlink" title="添加首页"></a>添加首页</h2><p>以前你的路由大概应该是这样的：（作为需要按需加载的大型应用，路由肯定是相当复杂，这里只列举部分路由举例）<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ReactDOM.render(</div><div class="line">  (</div><div class="line">    &lt;Router history=&#123;browserHistory&#125;&gt;</div><div class="line">      &#123;/* 主页 */&#125;</div><div class="line">      &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">        &#123;/* 默认 */&#125;</div><div class="line">        &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</div><div class="line"></div><div class="line">        &#123;/* baidu */&#125;</div><div class="line">        &lt;Route path="/baidu" component=&#123;BaiduPage&#125;&gt;</div><div class="line">          &lt;Route path="result" component=&#123;BaiduResultPage&#125; /&gt;</div><div class="line">          &lt;Route path="frequency" component=&#123;BaiduFrequencyPage&#125; /&gt;</div><div class="line">        &lt;/Route&gt;</div><div class="line"></div><div class="line">        &#123;/* 404 */&#125;</div><div class="line">        &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt;</div><div class="line">        </div><div class="line">        &#123;/* 其他重定向到 404 */&#125;</div><div class="line">        &lt;Redirect from='*' to='/404' /&gt;</div><div class="line">      &lt;/Route&gt;</div><div class="line">    &lt;/Router&gt;</div><div class="line">  ), document.getElementById('app')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>按需加载之后，我们需要让路由动态加载组件，需要将 <code>component</code> 换成 <code>getComponent</code>。首先将路由拆出来（因为路由庞大之后全部写在一起会很难看），创建一个根路由 <code>rootRoute</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> rootRoute = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'/'</span>,</div><div class="line">  <span class="attr">indexRoute</span>: &#123;</div><div class="line">    getComponent(nextState, cb) &#123;</div><div class="line">      <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">        cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/HomePage'</span>))</div><div class="line">      &#125;, <span class="string">'HomePage'</span>)</div><div class="line">    &#125;,</div><div class="line">  &#125;,</div><div class="line">  getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/Main'</span>))</div><div class="line">    &#125;, <span class="string">'Main'</span>)</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">childRoutes</span>: [</div><div class="line">    <span class="built_in">require</span>(<span class="string">'./routes/baidu'</span>),</div><div class="line">    <span class="built_in">require</span>(<span class="string">'./routes/404'</span>),</div><div class="line">    <span class="built_in">require</span>(<span class="string">'./routes/redirect'</span>)</div><div class="line">  ]</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  (</div><div class="line">    &lt;Router</div><div class="line">      history=&#123;browserHistory&#125;</div><div class="line">      routes=&#123;rootRoute&#125;</div><div class="line">      /&gt;</div><div class="line">  ), document.getElementById('app')</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p><code>history</code> 不变，在 <code>Router</code> 中添加 <code>routes</code> 属性，将创建的路由传递进去。</p>
<p>这里有四个属性：</p>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>将匹配的路由，也就是以前的 path。</p>
<h3 id="getComponent"><a href="#getComponent" class="headerlink" title="getComponent"></a>getComponent</h3><p>对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。</p>
<p>这里面有个 <strong>require.ensure</strong> 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure(dependencies, callback, chunkName)</div></pre></td></tr></table></figure></p>
<p>这是 <code>webpack</code> 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 <code>chunkName</code>，用来指定这个 <code>chunk file</code> 的 <code>name</code>。</p>
<p>如果需要返回多个子组件，则使用 <code>getComponents</code> 方法，将多个组件作为一个对象的属性通过 <code>cb</code> 返回出去即可。这个在官方示例也有，但是我们这里并不需要，而且根组件是不能返回多个子组件的，所以使用 <code>getComponent</code>。</p>
<h3 id="indexRoute"><a href="#indexRoute" class="headerlink" title="indexRoute"></a>indexRoute</h3><p>用来设置主页，对应于以前的 <code>&lt;IndexRoute&gt;</code>。</p>
<p>注意这里的 <code>indexRoute</code> 写法， <strong>这是个对象，在对象里面使用 getComponent</strong>。</p>
<h3 id="childRoutes"><a href="#childRoutes" class="headerlink" title="childRoutes"></a>childRoutes</h3><p>这里面放置的就是子路由的配置，对应于以前的子路由们。我们将以前的 <code>/baidu</code>、<code>/404</code> 和 <code>*</code> 都拆了出来，接下来将分别为他们创建路由配置。</p>
<h2 id="路由控制"><a href="#路由控制" class="headerlink" title="路由控制"></a>路由控制</h2><p>上面的 <code>childRoutes</code> 里面，我们 <code>require</code> 了三个子路由，在目录下创建 <code>routes</code> 目录，将这三个路由放置进去。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">routes/</div><div class="line">├── <span class="number">404</span></div><div class="line">│   └── index.js</div><div class="line">├── baidu</div><div class="line">│   ├── index.js</div><div class="line">│   └── routes</div><div class="line">│       ├── frequency</div><div class="line">│       │   └── index.js</div><div class="line">│       └── result</div><div class="line">│           └── index.js</div><div class="line">└── redirect</div><div class="line">    └── index.js</div></pre></td></tr></table></figure>
<p>和 rootRoute 类似，里面的每个 index.js 都是一个路由对象：</p>
<h3 id="404-index-js"><a href="#404-index-js" class="headerlink" title="/404/index.js"></a>/404/index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'404'</span>,</div><div class="line"></div><div class="line">  getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/NotFoundPage'</span>))</div><div class="line">    &#125;, <span class="string">'NotFoundPage'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>/baidu/index.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'baidu'</span>,</div><div class="line"></div><div class="line">  getChildRoutes(partialNextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, [</div><div class="line">        <span class="built_in">require</span>(<span class="string">'./routes/result'</span>),</div><div class="line">        <span class="built_in">require</span>(<span class="string">'./routes/frequency'</span>)</div><div class="line">      ])</div><div class="line">    &#125;)</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/BaiduPage'</span>))</div><div class="line">    &#125;, <span class="string">'BaiduPage'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="baidu-routes-frequency-index-js"><a href="#baidu-routes-frequency-index-js" class="headerlink" title="/baidu/routes/frequency/index.js"></a>/baidu/routes/frequency/index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'frequency'</span>,</div><div class="line"></div><div class="line">  getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/BaiduFrequencyPage'</span>))</div><div class="line">    &#125;, <span class="string">'BaiduFrequencyPage'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举这几个例子应该就差不多了，其他都是一样的，稍微有点特别的是 redirect。</p>
<h2 id="设置-Redirect"><a href="#设置-Redirect" class="headerlink" title="设置 Redirect"></a>设置 Redirect</h2><p>之前我们在根路由下是这么设置重定向的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;Router history=&#123;browserHistory&#125;&gt;</div><div class="line">    &lt;Route path="/" component=&#123;App&#125;&gt;</div><div class="line">    &#123;/* home */&#125;</div><div class="line">    &lt;IndexRoute component=&#123;HomePage&#125; /&gt;</div><div class="line"></div><div class="line">    &lt;Route path="/baidu" component=&#123;BaiduPage&#125;&gt;</div><div class="line">        &lt;Route path="result" component=&#123;BaiduResultPage&#125; /&gt;</div><div class="line">        &lt;Route path="frequency" component=&#123;BaiduFrequencyPage&#125; /&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line"></div><div class="line">    &lt;Route path='/404' component=&#123;NotFoundPage&#125; /&gt;</div><div class="line">    &#123;/* 如果都不匹配，重定向到 404 */&#125;</div><div class="line">    &lt;Redirect from='*' to='/404' /&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure></p>
<p>当改写之后，我们需要把这个重定向的路由单独拆出来，也就是 * 这个路由，我们上面已经为他创建了一个 <code>redirect</code> 目录。这里使用到 <code>onEnter</code> 方法，然后在这个方法里改变路由状态，调到另外的路由，实现 <code>redirect</code> ：</p>
<h3 id="redirect-index-js"><a href="#redirect-index-js" class="headerlink" title="/redirect/index.js"></a>/redirect/index.js</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">path</span>: <span class="string">'*'</span>,</div><div class="line">  <span class="attr">onEnter</span>: <span class="function">(<span class="params">_, replaceState</span>) =&gt;</span> replaceState(<span class="literal">null</span>, <span class="string">"/404"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="The-root-route-must-render-a-single-element"><a href="#The-root-route-must-render-a-single-element" class="headerlink" title="The root route must render a single element"></a>The root route must render a single element</h2><p>跟着官方示例和上面码出来之后，可能页面并没有渲染出来，而是报 <strong>The root route must render a single element</strong> 这个异常，这是因为 <code>module.exports</code> 和 ES6 里的 <code>export default</code> 有区别。</p>
<p>如果你是使用 <code>es6</code> 的写法，也就是你的组件都是通过 <code>export default</code> 导出的，那么在 <code>getComponent</code> 方法里面需要加入 <code>.default</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">getComponent(nextState, cb) &#123;</div><div class="line">    <span class="built_in">require</span>.ensure([], (<span class="built_in">require</span>) =&gt; &#123;</div><div class="line">      <span class="comment">// 在后面加 .default</span></div><div class="line">      cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'components/layer/ReportPage'</span>)).default</div><div class="line">    &#125;, <span class="string">'ReportPage'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你是使用 <code>CommonJS</code> 的写法，也就是通过 <code>module.exports</code> 导出的，那就无须加 <code>.default</code> 了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;注：本文使用的 react-router 版本为 2.8.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;React Router 是一个非常出色的路由解决方案，同时也非常容易上手。但是当网站规模越来越大的时候，首先出现的问题是 Javascript
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
      <category term="react-router" scheme="http://html-js.site/tags/react-router/"/>
    
  </entry>
  
  <entry>
    <title>React和Redux的连接react-redux</title>
    <link href="http://html-js.site/2017/09/02/React%E5%92%8CRedux%E7%9A%84%E8%BF%9E%E6%8E%A5react-redux/"/>
    <id>http://html-js.site/2017/09/02/React和Redux的连接react-redux/</id>
    <published>2017-09-02T02:45:57.000Z</published>
    <updated>2017-09-02T03:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://leozdgao.me/reacthe-reduxde-qiao-jie-react-redux/" target="_blank" rel="external">http://leozdgao.me/reacthe-reduxde-qiao-jie-react-redux/</a></p>
</blockquote>
<p>Redux本身和React并没有之间的关联，它是一个通用Javscript App模块，用做App State的管理。要在React的项目中使用Redux，比较好的方式是借助react-redux这个库来做连接，这里的意思是，并不是没有react-redux，这两个库就不弄一起用了，而是说react-redux提供了一些封装，一种更科学的代码组织方式，让我们更舒服地在React的代码中使用Redux。</p>
<p>之前仅通过Redux文档来了解react-redux，在一段时间的实践后准备翻一翻源代码，顺便做些相关的总结。我看的代码的npm版本为<code>v4.0.0</code>，也就是说使用的React版本是<code>v0.14.x</code>。</p>
<p>react-redux提供两个关键模块：Provider和connect。</p>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h3><p>Provider这个模块是作为整个App的容器，在你原有的App Container的基础上再包上一层，它的工作很简单，就是接受Redux的store作为props，并将其声明为context的属性之一，子组件可以在声明了<code>contextTypes</code>之后可以方便的通过<code>this.context.store</code>访问到store。不过我们的组件通常不需要这么做，将store放在context里，是为了给下面的connect用的。</p>
<p>这个是Provider的使用示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// config app root</span></div><div class="line"><span class="keyword">const</span> history = createHistory()  </div><div class="line"><span class="keyword">const</span> root = (  </div><div class="line">  &lt;Provider store=&#123;store&#125; key="provider"&gt;</div><div class="line">    &lt;Router history=&#123;history&#125; routes=&#123;routes&#125; /&gt;</div><div class="line">  &lt;/Provider&gt;</div><div class="line">)</div><div class="line"></div><div class="line">// render</div><div class="line">ReactDOM.render(  </div><div class="line">  root,</div><div class="line">  document.getElementById('root')</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p>这个模块是算是真正意义上连接了Redux和React，正好它的名字也叫connect。</p>
<p>先考虑Redux是怎么运作的：首先store中维护了一个state，我们dispatch一个action，接下来reducer根据这个action更新state。</p>
<p>映射到我们的React应用中，store中维护的state就是我们的app state，一个React组件作为View层，做两件事：render和响应用户操作。于是connect就是将store中的必要数据作为props传递给React组件来render，并包装action creator用于在响应用户操作时dispatch一个action。</p>
<p>好了，详细看看connect这个模块做了什么。先从它的使用来说，它的API如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</div></pre></td></tr></table></figure></p>
<p>mapStateToProps是一个函数，返回值表示的是需要merge进props的state。默认值为<code>() =&gt; ({})</code>，即什么都不传。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(state, props) =&gt; (&#123;  &#125;) <span class="comment">// 通常会省略第二个参数</span></div></pre></td></tr></table></figure></p>
<p><code>mapDispatchToProps</code>是可以是一个函数，返回值表示的是需要<code>merge</code>仅<code>props</code>的<code>actionCreators</code>，这里的<code>actionCreator</code>应该是已经被包装了<code>dispatch</code>了的，推荐使用<code>redux</code>的<code>bindActionCreators</code>函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(dispatch, props) =&gt; (&#123; <span class="comment">// 通常会省略第二个参数</span></div><div class="line"> ...bindActionCreators(&#123;</div><div class="line">   ...ResourceActions</div><div class="line"> &#125;, dispatch)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>更方便的是可以直接接受一个对象，此时<code>connect</code>函数内部会将其转变为函数，这个函数和上面那个例子是一模一样的。</p>
<p><code>mergeProps</code>用于自定义<code>merge</code>流程，下面这个是默认流程，<code>parentProps</code>值的就是组件自身的<code>props</code>，可以发现如果组件的<code>props</code>上出现同名，会被覆盖。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(stateProps, dispatchProps, parentProps) =&gt; (&#123;</div><div class="line">  ...parentProps,</div><div class="line">  ...stateProps,</div><div class="line">  ...dispatchProps</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p><code>options</code>共有两个开关：<code>pure</code>代表是否打开优化，详细内容下面会提，默认为<code>true</code>，<code>withRef</code>用来给包装在里面的组件一个<code>ref</code>，可以通过<code>getWrappedInstance</code>方法来获取这个<code>ref</code>，默认为<code>false</code>。</p>
<p><code>connect</code>返回一个函数，它接受一个<code>React</code>组件的构造函数作为连接对象，最终返回连接好的组件构造函数。</p>
<p>然后几个问题：</p>
<ul>
<li>React组件如何响应store的变化？</li>
<li>为什么connect选择性的merge一些props，而不是直接将整个state传入？</li>
<li>pure优化的是什么？</li>
</ul>
<p>我们把<code>connect</code>返回的函数叫做<code>Connector</code>，它返回的是内部的一个叫<code>Connect</code>的组件，它在包装原有组件的基础上，还在内部监听了<code>Redux</code>的<code>store</code>的变化，为了让被它包装的组件可以响应<code>store</code>的变化:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">trySubscribe() &#123;  </div><div class="line">  <span class="keyword">if</span> (shouldSubscribe &amp;&amp; !<span class="keyword">this</span>.unsubscribe) &#123;</div><div class="line">    <span class="keyword">this</span>.unsubscribe = <span class="keyword">this</span>.store.subscribe(::<span class="keyword">this</span>.handleChange)</div><div class="line">    <span class="keyword">this</span>.handleChange()</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">handleChange () &#123;  </div><div class="line">  <span class="keyword">this</span>.setState(&#123;</div><div class="line">    <span class="attr">storeState</span>: <span class="keyword">this</span>.store.getState()</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是通常，我们<code>connect</code>的是某个<code>Container</code>组件，它并不承载所有<code>App state</code>，然而我们的<code>handler</code>是响应所有<code>state</code>变化的，于是我们需要优化的是：当<code>storeState</code>变化的时候，仅在我们真正依赖那部分<code>state</code>变化时，才重新<code>render</code>相应的<code>React</code>组件，那么什么是我们真正依赖的部分？就是通过<code>mapStateToProps</code>和<code>mapDispatchToProps</code>得到的。</p>
<p>具体优化的方式就是在<code>shouldComponentUpdate</code>中做检查，如果只有在组件自身的<code>props</code>改变，或者<code>mapStateToProps</code>的结果改变，或者是<code>mapDispatchToProps</code>的结果改变时<code>shouldComponentUpdate</code>才会返回<code>true</code>，检查的方式是进行<code>shallowEqual</code>的比较。</p>
<p>所以对于某个reducer来说：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = &#123;&#125;, action) =&gt; &#123;  </div><div class="line">  <span class="keyword">return</span> &#123; ...state &#125; <span class="comment">// 返回的是一个新的对象，可能会使组件reRender</span></div><div class="line">  <span class="comment">// return state // 可能不会使得组件reRender</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外在<code>connect</code>的时候，要谨慎<code>map</code>真正需要的<code>state</code>或者<code>actionCreators</code>到<code>props</code>中，以避免不必要的性能损失。</p>
<p>最后，根据<code>connect</code>的<code>API</code>我们发现可以使用<code>ES7 decorator</code>功能来配合<code>React ES6</code>的写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@connect(</div><div class="line">  <span class="function"><span class="params">state</span> =&gt;</span> (&#123;</div><div class="line">    <span class="attr">user</span>: state.user,</div><div class="line">    <span class="attr">resource</span>: state.resource</div><div class="line">  &#125;),</div><div class="line">  dispatch =&gt; (&#123;</div><div class="line">    ...bindActionCreators(&#123;</div><div class="line">      <span class="attr">loadResource</span>: ResourceActions.load</div><div class="line">    &#125;, dispatch)</div><div class="line">  &#125;)</div><div class="line">)</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，结束了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://leozdgao.me/reacthe-reduxde-qiao-jie-react-redux/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://leozdgao.me/re
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
      <category term="redux" scheme="http://html-js.site/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>react事件研究及阻止冒泡</title>
    <link href="http://html-js.site/2017/08/25/react%E4%BA%8B%E4%BB%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E9%98%BB%E6%AD%A2%E5%86%92%E6%B3%A1/"/>
    <id>http://html-js.site/2017/08/25/react事件研究及阻止冒泡/</id>
    <published>2017-08-25T14:14:08.000Z</published>
    <updated>2017-08-25T14:34:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="React-中的事件处理逻辑"><a href="#React-中的事件处理逻辑" class="headerlink" title="React 中的事件处理逻辑"></a>React 中的事件处理逻辑</h3><p>为了解决跨浏览器兼容性问题，<code>React</code> 会将浏览器原生事件（<code>Browser Native Event</code>）封装为合成事件（<code>SyntheticEvent</code>）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，<code>React</code> 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 <code>React</code> 在更新 <code>DOM</code> 的时候就不需要考虑如何去处理附着在 <code>DOM</code> 上的事件监听器，最终达到优化性能的目的。</p>
<h3 id="合成事件-SyntheticEvent"><a href="#合成事件-SyntheticEvent" class="headerlink" title="合成事件 SyntheticEvent"></a>合成事件 SyntheticEvent</h3><p><code>SyntheticEvent</code> 是浏览器原生事件跨浏览器的封装。<code>SyntheticEvent</code> 和浏览器原生事件一样有 <code>stopPropagation()</code>、<code>preventDefault()</code> 接口，而且这些接口夸浏览器兼容。</p>
<p>如果出于某些原因想使用浏览器原生事件，可以使用 <code>nativeEvent</code> 属性获取。每个和成事件（<code>SyntheticEvent</code>）对象都有以下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">boolean bubbles</div><div class="line">boolean cancelable</div><div class="line">DOMEventTarget currentTarget</div><div class="line">boolean defaultPrevented</div><div class="line">Number eventPhase</div><div class="line">boolean isTrusted</div><div class="line">DOMEvent nativeEvent</div><div class="line">void preventDefault()</div><div class="line">void stopPropagation()</div><div class="line">DOMEventTarget target</div><div class="line">Date timeStamp</div><div class="line">String type</div></pre></td></tr></table></figure></p>
<h3 id="支持的事件"><a href="#支持的事件" class="headerlink" title="支持的事件"></a>支持的事件</h3><p>React 将事件统一化，使事件在不同浏览器上有一致的属性。</p>
<p>事件处理程序在事件冒泡阶段被触发。如果要注册事件捕获处理程序，应该使用 <code>Capture</code> 事件，例如使用 <code>onClickCapture</code> 处理点击事件的捕获阶段，而不是 <code>onClick</code>。</p>
<h3 id="阻止冒泡事件分三种情况"><a href="#阻止冒泡事件分三种情况" class="headerlink" title="阻止冒泡事件分三种情况"></a>阻止冒泡事件分三种情况</h3><p>A、阻止合成事件间的冒泡，用e.stopPropagation();<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM,&#123;findDOMNode&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">count</span>:<span class="number">0</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick(e)&#123;</div><div class="line">        <span class="comment">// 阻止合成事件间的冒泡</span></div><div class="line">        e.stopPropagation();</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:++<span class="keyword">this</span>.state.count&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    testClick()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'test'</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span>(</div><div class="line">            &lt;div ref="test" onClick=&#123;()=&gt;this.testClick()&#125;&gt;</div><div class="line">                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;</div><div class="line">                &lt;a ref="update" onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;更新&lt;/a&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</div><div class="line">ReactDOM.render(&lt;Counter/&gt;,div1,()=&gt;&#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>B、阻止合成事件与最外层<code>document</code>上的事件间的冒泡，用<code>e.nativeEvent.stopImmediatePropagation()</code>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM,&#123;findDOMNode&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">count</span>:<span class="number">0</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick(e)&#123;</div><div class="line">        <span class="comment">// 阻止合成事件与最外层document上的事件间的冒泡</span></div><div class="line">        e.nativeEvent.stopImmediatePropagation();</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:++<span class="keyword">this</span>.state.count&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span>(</div><div class="line">            &lt;div ref="test"&gt;</div><div class="line">                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;</div><div class="line">                &lt;a ref="update" onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;更新&lt;/a&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">        <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'document'</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</div><div class="line"></div><div class="line">ReactDOM.render(&lt;Counter/&gt;,div1,()=&gt;&#123;&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="C、阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e-target来避免"><a href="#C、阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e-target来避免" class="headerlink" title="C、阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免"></a>C、阻止合成事件与除最外层document上的原生事件上的冒泡，通过判断e.target来避免</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React,&#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM,&#123;findDOMNode&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">count</span>:<span class="number">0</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick(e)&#123;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:++<span class="keyword">this</span>.state.count&#125;);</div><div class="line">    &#125;</div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span>(</div><div class="line">            &lt;div ref="test"&gt;</div><div class="line">                &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt;</div><div class="line">                &lt;a ref="update" onClick=&#123;(e)=&gt;this.handleClick(e)&#125;&gt;更新&lt;/a&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">        <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>,e=&gt;&#123;</div><div class="line">            <span class="comment">// 通过e.target判断阻止冒泡</span></div><div class="line">            <span class="keyword">if</span>(e.target&amp;&amp;e.target.matches(<span class="string">'a'</span>))&#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'body'</span>);</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> div1 = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>);</div><div class="line"></div><div class="line">ReactDOM.render(&lt;Counter/&gt;,div1,()=&gt;&#123;&#125;);</div></pre></td></tr></table></figure>
<h3 id="stackoverflow"><a href="#stackoverflow" class="headerlink" title="stackoverflow"></a>stackoverflow</h3><p><a href="https://stackoverflow.com/questions/24415631/reactjs-syntheticevent-stoppropagation-only-works-with-react-events" target="_blank" rel="external">https://stackoverflow.com/questions/24415631/reactjs-syntheticevent-stoppropagation-only-works-with-react-events</a></p>
<p>React uses event delegation with a single event listener on document for events that bubble, like ‘click’ in this example, which means stopping propagation is not possible; the real event has already propagated by the time you interact with it in React. stopPropagation on React’s synthetic event is possible because React handles propagation of synthetic events internally.</p>
<p>Working JSFiddle with the fixes from below: <a href="http://jsfiddle.net/7LEDT/6/" target="_blank" rel="external">http://jsfiddle.net/7LEDT/6/</a></p>
<p>React Stop Propagation on jQuery Event</p>
<p>Use <code>Event.stopImmediatePropagation</code> to prevent your other (jQuery in this case) listeners on the root from being called. It is supported in IE9+ and modern browsers.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">stopPropagation: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    e.stopPropagation();</div><div class="line">    e.nativeEvent.stopImmediatePropagation();</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<ul>
<li>Caveat: Listeners are called in the order in which they are bound. React must be initialized before other code (jQuery here) for this to work.</li>
</ul>
<p>jQuery Stop Propagation on React Event</p>
<p>Your jQuery code uses event delegation as well, which means calling stopPropagation in the handler is not stopping anything; the event has already propagated to document, and React’s listener will be triggered.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Listener bound to `document`, event delegation</span></div><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'click'</span>, <span class="string">'.stop-propagation'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    e.stopPropagation();</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>To prevent propagation beyond the element, the listener must be bound to the element itself:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Listener bound to `.stop-propagation`, no delegation</span></div><div class="line">$(<span class="string">'.stop-propagation'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">    e.stopPropagation();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Clarified that delegation is necessarily only used for events that bubble. For more details on event handling, React’s source has descriptive comments: <a href="https://github.com/facebook/react/blob/3b96650e39ddda5ba49245713ef16dbc52d25e9e/src/renderers/dom/client/ReactBrowserEventEmitter.js#L23" target="_blank" rel="external">https://github.com/facebook/react/blob/3b96650e39ddda5ba49245713ef16dbc52d25e9e/src/renderers/dom/client/ReactBrowserEventEmitter.js#L23</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;React-中的事件处理逻辑&quot;&gt;&lt;a href=&quot;#React-中的事件处理逻辑&quot; class=&quot;headerlink&quot; title=&quot;React 中的事件处理逻辑&quot;&gt;&lt;/a&gt;React 中的事件处理逻辑&lt;/h3&gt;&lt;p&gt;为了解决跨浏览器兼容性问题，&lt;code&gt;Re
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 中的匿名递归</title>
    <link href="http://html-js.site/2017/08/17/JavaScript-%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E9%80%92%E5%BD%92/"/>
    <id>http://html-js.site/2017/08/17/JavaScript-中的匿名递归/</id>
    <published>2017-08-17T06:12:47.000Z</published>
    <updated>2017-08-17T08:42:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>代码如果这么写，过一段时间之后自己还能明白？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">f</span>) =&gt;</span> f(f)</div><div class="line">  )</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">f</span>) =&gt;</span></div><div class="line">      (l) =&gt; &#123;</div><div class="line">        <span class="built_in">console</span>.log(l)</div><div class="line"><span class="keyword">if</span> (l.length) f(f)(l.slice(<span class="number">1</span>))</div><div class="line">        <span class="built_in">console</span>.log(l)</div><div class="line">      &#125;</div><div class="line">  )</div><div class="line">)</div><div class="line">(</div><div class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line">)</div></pre></td></tr></table></figure>
<p>是的，这就是想要分享给大家的一个有趣的示例。这个例子包含以下特性：闭包)，自执行函数，箭头函数，函数式编程 和 匿名递归。</p>
<p>你可以复制粘贴上述代码到浏览器控制台，会看到打印结果如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</div><div class="line">[ <span class="number">2</span>, <span class="number">3</span> ]</div><div class="line">[ <span class="number">3</span> ]</div><div class="line">[]</div><div class="line">[]</div><div class="line">[ <span class="number">3</span> ]</div><div class="line">[ <span class="number">2</span>, <span class="number">3</span> ]</div><div class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="Unwind"><a href="#Unwind" class="headerlink" title="Unwind"></a>Unwind</h3><p>像其他很多编程语言一样，js函数调用是通过在函数名称后添加括号 () 来完成的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'hey'</span> &#125;</div><div class="line">foo()</div></pre></td></tr></table></figure></p>
<p>在 JavaScript 中我们可以使用括号包裹任意数量的表达式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="string">'hey'</span>, <span class="number">2</span>+<span class="number">5</span>, <span class="string">'dev.to'</span>)</div></pre></td></tr></table></figure></p>
<p>上面代码返回结果是 ‘dev.to’，原因是 JavaScript 返回最后一个表达式作为结果。</p>
<p>使用括号 () 包裹一个匿名函数表示其结果就是 匿名函数 本身.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'hey'</span> &#125;)</div></pre></td></tr></table></figure></p>
<p>这本身并没有用处，因为匿名函数没有命名，无法被引用，除非在初始化的时候立即调用它。</p>
<p>就像是普通函数一样，我们可以在其后面添加括号 () 来进行调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">'hey'</span> &#125;)()</div></pre></td></tr></table></figure></p>
<p>也可以使用箭头函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'hey'</span>)()</div></pre></td></tr></table></figure></p>
<p>同样地，在匿名函数后添加括号 () 来执行函数，这被称为 自执行函数。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包) 指的是函数和该函数声明词法环境的组合。结合 箭头功能，我们可以定义如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">hi</span>) =&gt;</span> (dev) =&gt; hi + <span class="string">' '</span> + dev</div></pre></td></tr></table></figure></p>
<p>在控制台调用上述函数会打印 hey dev.to:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo(<span class="string">'hey'</span>)(<span class="string">'dev.to'</span>)</div></pre></td></tr></table></figure></p>
<p>注意，我们可以在内部函数作用域访问外部函数的参数 hi。</p>
<p>以下代码跟上述代码一样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">hi</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">dev</span>) </span>&#123; <span class="keyword">return</span> hi + <span class="string">' '</span> + dev &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>自执行的版本如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  <span class="function">(<span class="params">hi</span>) =&gt;</span></div><div class="line">    (</div><div class="line">      <span class="function">(<span class="params">dev</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;hi&#125;</span> <span class="subst">$&#123;dev&#125;</span>`</span></div><div class="line">    )</div><div class="line">    (<span class="string">'dev.to'</span>)</div><div class="line">)</div><div class="line">(<span class="string">'hey'</span>)</div></pre></td></tr></table></figure></p>
<p>首先，将 hey 作为参数 hi 的值传给最外层作用域的函数，然后这个函数返回另一个自执行函数。dev.to 作为参数 dev 的值传给内部函数，最后这个函数返回最终值：’hey dev.to’。</p>
<h3 id="再深入一点"><a href="#再深入一点" class="headerlink" title="再深入一点"></a>再深入一点</h3><p>这个一个上述自执行函数的修改版本：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">dev</span>) =&gt;</span></div><div class="line">      (hi) =&gt; <span class="string">`<span class="subst">$&#123;hi&#125;</span> <span class="subst">$&#123;dev&#125;</span>`</span></div><div class="line">  )</div><div class="line">  (<span class="string">'dev.to'</span>)</div><div class="line">)</div><div class="line">(<span class="string">'hey'</span>)</div></pre></td></tr></table></figure></p>
<p>需要注意的是，自执行函数 和 闭包) 用作初始化和封装状态，接下来我们来看另外一个例子。</p>
<h3 id="匿名递归"><a href="#匿名递归" class="headerlink" title="匿名递归"></a>匿名递归</h3><p>回到我们最初的例子，这次加点注释：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">f</span>) =&gt;</span> f(f) <span class="comment">// 3.</span></div><div class="line">  )</div><div class="line">  (</div><div class="line">    <span class="function">(<span class="params">f</span>) =&gt;</span> <span class="comment">// 2.</span></div><div class="line">      (l) =&gt; &#123; <span class="comment">// 4.</span></div><div class="line">        <span class="built_in">console</span>.log(l)</div><div class="line"><span class="keyword">if</span> (l.length) f(f)(l.slice(<span class="number">1</span>))</div><div class="line">        <span class="built_in">console</span>.log(l)</div><div class="line">      &#125;</div><div class="line">  )</div><div class="line">)</div><div class="line">(</div><div class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// 1.</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">    (</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> f(f)</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">    (</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">l</span>)</span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'1'</span>,l)</div><div class="line">                <span class="keyword">if</span>(l.length)</div><div class="line">                    f(f)(l.slice(<span class="number">1</span>))</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">'2'</span>,l)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    )</div><div class="line">)([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">f</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">l</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'1'</span>,l)</div><div class="line">        <span class="keyword">if</span>(l.length)</div><div class="line">            f(f)(l.slice(<span class="number">1</span>))</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'2'</span>,l)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">b(b)([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure></p>
<ul>
<li>输入函数 [1, 2, 3] 传给最外层作用域</li>
<li>整个函数作为参数传给上面函数</li>
<li>这个函数接收下面函数作为参数 f 的值，然后自身调用</li>
<li>2.将被调用被作为 3.的结果然后返回函数 4. ，该函数是满足最外层作用域的函数，因此接收输入数组作为 l 参数的值</li>
</ul>
<p>至于结果为什么是那样子，原因是在递归内部有一个对函数 f 的引用来接收输入数组 l。所以能那样调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f(f)(l.slice(<span class="number">1</span>))</div></pre></td></tr></table></figure></p>
<p>注意，f 是一个闭包，所以我们只需要调用它就可以访问到操作输入数组的最里面的函数。</p>
<p>为了说明目的，第一个 console.log(l) 语句表示递归自上而下，第二个语句表示递归自下而上。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>希望你喜欢这篇文章，并从中学到了新的东西。闭包、自执行函数、函数式编程模式不是黑魔法。它们遵循一套易于理解和玩乐的简单原则。</p>
<p>话虽如此，你必须培养自己何时使用它们，何时不用的这样一种感觉。如果你的代码变得难以维护，那这可能会成为重构中一些好点子。</p>
<p>然而，理解这些基本技术对于创建清晰优雅的解决方案以及提升自我是至关重要的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;代码如果这么写，过一段时间之后自己还能明白？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;f&lt;/span&gt;) =&amp;gt;&lt;/span&gt; f(f)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;f&lt;/span&gt;) =&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      (l) =&amp;gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(l)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (l.length) f(f)(l.slice(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(l)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  )&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;(&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;是的，这就是想要分享给大家的一个有趣的示例。这个例子包含以下特性：闭包)，自执行函数，箭头函数，函数式编程 和 匿名递归。&lt;/p&gt;
&lt;p&gt;你可以复制粘贴上述代码到浏览器控制台，会看到打印结果如下：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; ]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://html-js.site/tags/js/"/>
    
      <category term="es6" scheme="http://html-js.site/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>八段代码彻底掌握 Promise</title>
    <link href="http://html-js.site/2017/08/01/%E5%85%AB%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1-Promise/"/>
    <id>http://html-js.site/2017/08/01/八段代码彻底掌握-Promise/</id>
    <published>2017-08-01T06:51:00.000Z</published>
    <updated>2017-08-01T12:44:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Promise的立即执行性"><a href="#1-Promise的立即执行性" class="headerlink" title="1.Promise的立即执行性"></a>1.Promise的立即执行性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"create a promise"</span>);</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"after new Promise"</span>);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;create a promise&quot;</div><div class="line">&quot;after new Promise&quot;</div><div class="line">&quot;success&quot;</div></pre></td></tr></table></figure></p>
<p>Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。<br><a id="more"></a></p>
<h3 id="2-Promise-三种状态"><a href="#2-Promise-三种状态" class="headerlink" title="2.Promise 三种状态"></a>2.Promise 三种状态</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    resolve(<span class="number">2</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    reject(<span class="number">3</span>);  </div><div class="line">  &#125;, <span class="number">500</span>);      </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1);</div><div class="line"><span class="built_in">console</span>.log(p2);</div><div class="line"><span class="built_in">console</span>.log(p3);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p2);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p3);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line">p3.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。</p>
<p>p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1 的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。</p>
<h3 id="3-Promise-状态的不可逆性"><a href="#3-Promise-状态的不可逆性" class="headerlink" title="3.Promise 状态的不可逆性"></a>3.Promise 状态的不可逆性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success1"</span>);</div><div class="line">  resolve(<span class="string">"success2"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">  reject(<span class="string">"reject"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;success1&quot;</div><div class="line">&quot;success&quot;</div></pre></td></tr></table></figure></p>
<p>Promise状态的一旦变成<code>resolved</code>或<code>rejected</code>时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中<code>resolve(&quot;success2&quot;)</code>并不能将p1的值更改为success2，p2中r<code>eject(&quot;reject&quot;)</code>也不能将p2的状态由resolved改变为rejected.</p>
<h3 id="4-链式调用"><a href="#4-链式调用" class="headerlink" title="4.链式调用"></a>4.链式调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;               <span class="comment">//第一个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> value*<span class="number">2</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第二个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第三个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>); </div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第四个then</span></div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;              <span class="comment">//第五个then</span></div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>+ value);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span> + err);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">undefined</div><div class="line">&quot;resolve&quot;</div><div class="line">&quot;reject: reject&quot;</div></pre></td></tr></table></figure></p>
<p>Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种：</p>
<ul>
<li><code>return</code> 一个同步的值 ，或者 <code>undefined</code>（当没有返回一个有效值时，默认返回undefined），<code>then</code>方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。</li>
<li><code>return</code> 另一个 Promise，<code>then</code>方法将根据这个Promise的状态和值创建一个新的Promise对象返回。</li>
<li><code>throw</code> 一个同步异常，<code>then</code>方法将返回一个rejected状态的Promise, 值是该异常。</li>
</ul>
<h3 id="5-Promise-then-回调异步性"><a href="#5-Promise-then-回调异步性" class="headerlink" title="5.Promise then() 回调异步性"></a>5.Promise then() 回调异步性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="string">"success"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"which one is called first ?"</span>);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;which one is called first ?&quot;</div><div class="line">&quot;success&quot;</div></pre></td></tr></table></figure></p>
<p>Promise接收的函数参数是同步执行的，但<code>then</code>方法中的回调函数执行则是异步的，因此，”success”会在后面输出。</p>
<h3 id="6-Promise-中的异常"><a href="#6-Promise-中的异常" class="headerlink" title="6.Promise 中的异常"></a>6.Promise 中的异常</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  foo.bar();</div><div class="line">  resolve( <span class="number">1</span> );      </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span>+value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</div><div class="line">  resolve( <span class="number">2</span> );    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value);</div><div class="line">    foo.bar();</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err);</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">).then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value);</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p1 then err: ReferenceError: foo is not defined</div><div class="line">p2 then value: 2</div><div class="line">p1 then then value: undefined</div><div class="line">p2 then then err: ReferenceError: foo is not defined</div><div class="line">p2 then then then value: 1</div></pre></td></tr></table></figure></p>
<p>Promise中的异常由<code>then</code>参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，<code>then</code>返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级<code>then</code>的回调函数是交替执行的 ，这正是由Promise <code>then</code>回调的异步性决定的。</p>
<h3 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7.Promise.resolve()"></a>7.Promise.resolve()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve( <span class="number">1</span> );</div><div class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.resolve( p1 );</div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(p1);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(p1 === p2); </div><div class="line"><span class="built_in">console</span>.log(p1 === p3);</div><div class="line"><span class="built_in">console</span>.log(p1 === p4);</div><div class="line"><span class="built_in">console</span>.log(p3 === p4);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p4='</span> + value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p2='</span> + value);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'p1='</span> + value);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">false</div><div class="line">false</div><div class="line">false</div><div class="line">p2=1</div><div class="line">p1=1</div><div class="line">p4=1</div></pre></td></tr></table></figure></p>
<p><code>Promise.resolve(...)</code>可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的<code>then</code>最先调用，但在控制台上是最后输出结果的呢？因为p4的<code>resolve</code>中接收的参数是一个Promise对象p1，<code>resolve</code>会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。</p>
<h3 id="8-resolve-vs-reject"><a href="#8-resolve-vs-reject" class="headerlink" title="8.resolve vs reject"></a>8.resolve vs reject</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p2.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div><div class="line"></div><div class="line">p3.then(</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value);</div><div class="line">  &#125;, </div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err);</div><div class="line">  &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">p3 rejected: [object Promise]</div><div class="line">p1 fulfilled: resolve</div><div class="line">p2 rejected: reject</div></pre></td></tr></table></figure></p>
<p>Promise回调函数中的第一个参数<code>resolve</code>，会对Promise执行”拆箱”动作。即当<code>resolve</code>的参数是一个Promise对象时，<code>resolve</code>会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是<code>resolved</code>，因此<code>fulfilled</code>回调被执行；p2”拆箱”后，获取到Promise对象的状态是<code>rejected</code>，因此<code>rejected</code>回调被执行。但Promise回调函数中的第二个参数<code>reject</code>不具备”拆箱“的能力，<code>reject</code>的参数会直接传递给then方法中的<code>rejected</code>回调。因此，即使p3 reject接收了一个<code>resolved</code>状态的Promise，<code>then</code>方法中被调用的依然是<code>rejected</code>，并且参数就是<code>reject</code>接收到的Promise对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-Promise的立即执行性&quot;&gt;&lt;a href=&quot;#1-Promise的立即执行性&quot; class=&quot;headerlink&quot; title=&quot;1.Promise的立即执行性&quot;&gt;&lt;/a&gt;1.Promise的立即执行性&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resolve, reject&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;create a promise&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  resolve(&lt;span class=&quot;string&quot;&gt;&quot;success&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;after new Promise&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;p.then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;控制台输出：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;create a promise&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;after new Promise&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;quot;success&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。&lt;br&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
      <category term="ECMAScript6" scheme="http://html-js.site/tags/ECMAScript6/"/>
    
      <category term="promise" scheme="http://html-js.site/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>webpack的重要功能——Plugins</title>
    <link href="http://html-js.site/2017/06/23/webpack%E7%9A%84%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94Plugins/"/>
    <id>http://html-js.site/2017/06/23/webpack的重要功能——Plugins/</id>
    <published>2017-06-23T06:57:18.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>webpack</code>中另一个非常重要的功能是<code>Plugins</code>。<br>插件（<code>Plugins</code>）是用来拓展<code>webpack</code>功能的，它们会在整个构建过程中生效，执行相关的任务。<br><code>Loaders</code>和<code>Plugins</code>常常被弄混，但是他们其实是完全不同的东西：<code>Loaders</code>是在打包构建过程中用来处理源文件的（<code>JSX，Scss，Less..</code>），一次处理一个;插件并不直接操作单个文件，它直接对整个构建过程其作用。<br><code>webpack</code>有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<a id="more"></a>
<h2 id="使用插件的方法"><a href="#使用插件的方法" class="headerlink" title="使用插件的方法"></a>使用插件的方法</h2><p>要使用某个插件，需要通过<code>npm</code>安装它，然后在<code>webpack.config.js</code>中的<code>plugins</code>关键字部分添加该插件的一个实例（<code>plugins</code>是一个数组，<code>new</code>一个插件即可）。<br>如添加一个实现版权声明的插件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">        <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,  </div><div class="line">        <span class="attr">entry</span>:  __dirname + <span class="string">"/app/main.js"</span>,  </div><div class="line">        <span class="attr">output</span>: &#123;...&#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">                <span class="attr">loaders</span>: [  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, <span class="attr">loader</span>: <span class="string">"json"</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> &#125;<span class="comment">//这里添加PostCSS  </span></div><div class="line">                ]  </div><div class="line">    &#125;,  </div><div class="line">        <span class="attr">postcss</span>: [  </div><div class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  </div><div class="line">        ],  </div><div class="line">        <span class="attr">plugins</span>: [  </div><div class="line">                <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"Copyright Flying Unicorns inc."</span>)    </div><div class="line">    ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;...&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="几个常用的插件"><a href="#几个常用的插件" class="headerlink" title="几个常用的插件"></a>几个常用的插件</h2><h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>这个插件的作用是依据一个简单的模板，帮助生成最终的<code>HTML5</code>文件，这个文件中自动引用了打包后的<code>JS</code>文件。每次编译都在文件名中插入一个不同的哈希值。<br>安装命令：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev html-webpack-plugin</div></pre></td></tr></table></figure></p>
<p>这个插件自动完成了之前手动做的一些事情，在正式使用之前需要对项目结构做一些改变：</p>
<ol>
<li>移除public文件夹，利用此插件，html5文件会自动生成，此外CSS已经通过前面的操作打包到JS中了。</li>
<li><p>在app目录下，创建一个HTML文件模板index.tmpl.html，这个模板包含title等其它需要的元素，在编译过程中，本插件会依据此模板生成最终的HTML页面，会自动添加所依赖的 css, js，favicon等文件，模板源代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;  </div><div class="line">&lt;html lang="en"&gt;  </div><div class="line">    &lt;head&gt;  </div><div class="line">    &lt;/head&gt;  </div><div class="line">    &lt;body&gt;  </div><div class="line">            &lt;div id='root'&gt;  </div><div class="line">            &lt;/div&gt;  </div><div class="line">    &lt;/body&gt;  </div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>更新webpack的配置文件，方法同上，新建一个build文件夹用来存放最终的输出文件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);<span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);  </div><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">        <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,  </div><div class="line">        <span class="attr">entry</span>:  __dirname + <span class="string">"/app/main.js"</span>,  </div><div class="line">        <span class="attr">output</span>: &#123;  </div><div class="line">                <span class="attr">path</span>: __dirname + <span class="string">"/build"</span>,  </div><div class="line">                <span class="attr">filename</span>: <span class="string">"bundle.js"</span>  </div><div class="line">        &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">                <span class="attr">loaders</span>: [  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, <span class="attr">loader</span>: <span class="string">"json"</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span> &#125;,  </div><div class="line">                &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> &#125;  </div><div class="line">            ]  </div><div class="line">        &#125;,  </div><div class="line">        <span class="attr">postcss</span>: [  </div><div class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  </div><div class="line">        ],  </div><div class="line">        <span class="attr">plugins</span>: [  </div><div class="line">                <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  </div><div class="line">                    <span class="attr">template</span>: __dirname + <span class="string">"/app/index.tmpl.html"</span><span class="comment">//new 一个这个插件的实例，并传入相关的参数  </span></div><div class="line">                &#125;)  </div><div class="line">        ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">                <span class="attr">colors</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">inline</span>: <span class="literal">true</span>  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h3><p><code>Hot Module Replacement（HMR）</code>也是<code>webpack</code>里很有用的一个插件，它允许在修改组件代码后，自动刷新实时预览修改后的效果。<br>在<code>webpack</code>中实现<code>HMR</code>也很简单，只需要做两项配置</p>
<ol>
<li>在webpack配置文件中添加HMR插件；</li>
<li>在Webpack Dev Server中添加“hot”参数。</li>
</ol>
<p>不过配置完这些后，JS模块其实还是不能自动热加载的，还需要在JS模块中执行一个<code>Webpack</code>提供的<code>API</code>才能实现热加载，虽然这个<code>API</code>不难使用，但是如果是<code>React</code>模块，使用已经熟悉的<code>Babel</code>可以更方便的实现功能热加载。<br>具体实现方法如下：</p>
<ol>
<li>Babel和webpack是独立的工具；</li>
<li>二者可以一起工作；</li>
<li>二者都可以通过插件拓展功能；</li>
<li>HMR是一个webpack插件，它让你能浏览器中实时观察模块修改后的效果，但是如果你想让它工作，需要对模块进行额外的配额；</li>
<li>Babel有一个叫做react-transform-hrm的插件，可以在不对React模块进行额外的配置的前提下让HMR正常工作。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);  </div><div class="line"><span class="keyword">var</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);  </div><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">        <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,  </div><div class="line">        <span class="attr">entry</span>: __dirname + <span class="string">"/app/main.js"</span>,  </div><div class="line">        <span class="attr">output</span>: &#123;  </div><div class="line">                <span class="attr">path</span>: __dirname + <span class="string">"/build"</span>,  </div><div class="line">                <span class="attr">filename</span>: <span class="string">"bundle.js"</span>  </div><div class="line">        &#125;,  </div><div class="line">        <span class="attr">module</span>: &#123;  </div><div class="line">                <span class="attr">loaders</span>: [  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.json$/</span>, <span class="attr">loader</span>: <span class="string">"json"</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="attr">loader</span>: <span class="string">'babel'</span> &#125;,  </div><div class="line">                    &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span> &#125;  </div><div class="line">                ]     </div><div class="line">        &#125;,  </div><div class="line">        <span class="attr">postcss</span>: [  </div><div class="line">                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)  </div><div class="line">        ],  </div><div class="line">    <span class="attr">plugins</span>: [  </div><div class="line">                <span class="keyword">new</span> HtmlWebpackPlugin(&#123;  </div><div class="line">                    <span class="attr">template</span>: __dirname + <span class="string">"/app/index.tmpl.html"</span>  </div><div class="line">                &#125;),  </div><div class="line">                <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()<span class="comment">//热加载插件  </span></div><div class="line">        ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">                <span class="attr">colors</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">historyApiFallback</span>: <span class="literal">true</span>,  </div><div class="line">                <span class="attr">inline</span>: <span class="literal">true</span>,  </div><div class="line">            <span class="attr">hot</span>: <span class="literal">true</span>  </div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>安装react-transform-hmr：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-plugin-react-transform react-transform-hmr</div></pre></td></tr></table></figure></p>
<p>配置Babel<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&#123;  </div><div class="line">        <span class="string">"presets"</span>: [<span class="string">"react"</span>, <span class="string">"es2015"</span>],  </div><div class="line">        <span class="string">"env"</span>: &#123;  </div><div class="line">                <span class="string">"development"</span>: &#123;  </div><div class="line">                    <span class="string">"plugins"</span>: [[<span class="string">"react-transform"</span>, &#123;  </div><div class="line">                    <span class="string">"transforms"</span>: [&#123;  </div><div class="line">                            <span class="string">"transform"</span>: <span class="string">"react-transform-hmr"</span>,  </div><div class="line">                    <span class="string">"imports"</span>: [<span class="string">"react"</span>],  </div><div class="line">                    <span class="string">"locals"</span>: [<span class="string">"module"</span>]  </div><div class="line">                    &#125;]  </div><div class="line">                    &#125;]]  </div><div class="line">        &#125;  </div><div class="line">            &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用React时，可以热加载模块了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;webpack&lt;/code&gt;中另一个非常重要的功能是&lt;code&gt;Plugins&lt;/code&gt;。&lt;br&gt;插件（&lt;code&gt;Plugins&lt;/code&gt;）是用来拓展&lt;code&gt;webpack&lt;/code&gt;功能的，它们会在整个构建过程中生效，执行相关的任务。&lt;br&gt;&lt;code&gt;Loaders&lt;/code&gt;和&lt;code&gt;Plugins&lt;/code&gt;常常被弄混，但是他们其实是完全不同的东西：&lt;code&gt;Loaders&lt;/code&gt;是在打包构建过程中用来处理源文件的（&lt;code&gt;JSX，Scss，Less..&lt;/code&gt;），一次处理一个;插件并不直接操作单个文件，它直接对整个构建过程其作用。&lt;br&gt;&lt;code&gt;webpack&lt;/code&gt;有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack最强大的功能———Loaders</title>
    <link href="http://html-js.site/2017/06/23/webpack%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8A%9F%E8%83%BD%E2%80%94%E2%80%94%E2%80%94Loaders/"/>
    <id>http://html-js.site/2017/06/23/webpack最强大的功能———Loaders/</id>
    <published>2017-06-23T02:06:43.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h3><p><code>Loaders</code>是<code>webpack</code>中最强大的功能之一了。通过使用不同的<code>loader</code>，<code>webpack</code>通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，如分析<code>JSON</code>文件并把它转换为<code>JavaScript</code>文件；或把下一代的<code>js</code>文件（<code>ES6，ES7</code>)转换为现代浏览器可以识别的<code>JS</code>文件；或对<code>React</code>的开发而言，合适的<code>Loaders</code>可以把<code>react</code>的<code>JSX</code>文件转换为<code>JS</code>文件。</p>
<p><code>Loaders</code>需要单独安装并且需要在<code>webpack.config.js</code>下的<code>modules</code>关键字下进行配置。安装命令为<code>npm install --save-dev json-loader</code>，<code>Loaders</code>的配置选项包括以下几方面：</p>
<ul>
<li>test  一个匹配loaders所处理的文件的拓展名的正则表达式（必须）</li>
<li>loader  loader的名称（必须）</li>
<li>include/exclude  手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）</li>
<li>query  为loaders提供额外的设置选项（可选）<a id="more"></a>
</li>
</ul>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p><code>Loaders</code>很好，不过有的<code>Loaders</code>使用起来比较复杂，如<code>Babel</code>。<br><code>Babel</code>其实是一个编译<code>javascript</code>的平台，它的强大之处表现在可以通过编译达到以下目的：</p>
<ul>
<li>1) 下一代的<code>JavaScript</code>标准（<code>ES6，ES7</code>），这些标准目前并未被当前的浏览器完全的支持；</li>
<li>2) 使用基于<code>JavaScript</code>进行了拓展的语言，如<code>React</code>的<code>JSX</code>。<br><code>Babel</code>其实是几个模块化的包，其核心功能位于称为<code>babel-core</code>的<code>npm</code>包中，不过<code>webpack</code>把它们整合在一起使用，但是对于每一个需要的功能或拓展，都需要安装单独的包（用得最多的是解析Es6的<code>babel-preset-es2015</code>包和解析<code>JSX</code>的<code>babel-preset-react</code>包）。<br>一次性安装这些依赖包（npm一次性安装多个依赖模块，模块之间用空格隔开）：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在<code>webpack</code>中配置<code>Babel</code>的方法如下（在<code>webpack.config.js</code>的<code>module</code>部分的<code>loaders</code>里进行配置即可）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>webpack</code>进行以上配置后，允许使用<code>ES6</code>以及<code>JSX</code>的语法。</p>
<p><strong>Babel的配置选项：</strong><br><code>Babel</code>其实可以完全在<code>webpack.config.js</code>中进行配置，但考虑到<code>babel</code>具有非常多的配置选项，在单一的<code>webpack.config.js</code>文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把<code>babel</code>的配置选项放在一个单独的名为 <code>&quot;.babelrc&quot;</code> 的配置文件中。现在的<code>babel</code>的配置并不算复杂，不过之后会再加一些东西，因此现在就提取出相关部分，分两个配置文件进行配置（<code>webpack</code>会自动调用<code>.babelrc</code>里的<code>babel</code>配置选项），如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>.babelrc：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;  </div><div class="line">    <span class="string">"presets"</span>: [<span class="string">"react"</span>, <span class="string">"es2015"</span>]  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><code>webpack</code>的优点：把所有的文件都可以当做模块处理，包括<code>JavaScript</code>代码，也包括<code>CSS</code>和<code>fonts</code>以及图片等，通过合适的<code>loaders</code>，它们都可以被当做模块被处理。<br><strong>1）CSS</strong><br><code>webpack</code>提供两个工具处理样式表，<code>css-loader</code> 和 <code>style-loader</code>，二者处理的任务不同，<code>css-loader</code>使得能够使用类似<code>@import</code> 和 <code>url(...)</code>的方法实现 <code>require()</code>的功能，<code>style-loader</code>将所有的计算后的样式加入页面中，二者组合在一起能够把样式表嵌入<code>webpack</code>打包后的JS文件中。<br>安装命令：<code>npm install --save-dev style-loader css-loader</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：感叹号的作用在于使同一文件能够使用不同类型的<code>loader</code>。</p>
<p><strong>2）CSS modules</strong><br><code>CSS modules</code> 的技术就意在把<code>JS</code>的模块化思想带入<code>CSS</code>中来，通过<code>CSS</code>模块，所有的类名，动画名默认都只作用于当前模块。<code>Webpack</code>从一开始就对<code>CSS</code>模块化提供了支持，在<code>CSS loader</code>中进行配置后，所需要做的一切就是把<code>modules</code>传递都所需要的地方，然后就可以直接把<code>CSS</code>的类名传递到组件的代码中，且这样做只对当前组件有效，不必担心在不同的模块中具有相同的类名可能会造成的问题。具体的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css?modules'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><p>有关<code>Less Loader</code>、<code>Sass Loader</code>、<code>Stylus Loader</code>的介绍请见：<a href="http://blog.csdn.net/zhouziyu2011/article/details/67646875。" target="_blank" rel="external">http://blog.csdn.net/zhouziyu2011/article/details/67646875。</a><br>还有一个<code>CSS</code>的处理平台-<code>PostCSS</code>，可以帮助<code>CSS</code>实现更多的功能，使用<code>PostCSS</code>来为<code>CSS</code>代码自动添加适应不同浏览器的CSS前缀。<br>安装<code>postcss-loader</code> 和 <code>autoprefixer</code>（自动添加前缀的插件）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save-dev postcss-loader autoprefixer。</div></pre></td></tr></table></figure></p>
<p>在<code>webpack.config.js</code>中进行设置，只需要新建一个<code>postcss</code>关键字，并在里面申明依赖的插件，<code>css</code>会自动根据数据添加不同前缀了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>,<span class="comment">//配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>,<span class="comment">//已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">module</span>: &#123;  </div><div class="line">        <span class="attr">loaders</span>: [  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.json$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">"json-loader"</span>  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,  </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>,  </div><div class="line">                <span class="attr">query</span>: &#123;  </div><div class="line">                    <span class="attr">presets</span>: [<span class="string">'es2015'</span>,<span class="string">'react'</span>]  </div><div class="line">                &#125;  </div><div class="line">            &#125;,  </div><div class="line">            &#123;  </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,  </div><div class="line">                <span class="attr">loader</span>: <span class="string">'style!css?modules!postcss'</span>  </div><div class="line">            &#125;  </div><div class="line">        ]  </div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">postcss</span>: [  </div><div class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)<span class="comment">//调用autoprefixer插件  </span></div><div class="line">    ],  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>处理<code>JS</code>的<code>Babel</code>和处理<code>CSS</code>的<code>PostCSS</code>其实也是两个单独的平台，配合<code>Webpack</code>可以很好的发挥它们的作用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Loaders&quot;&gt;&lt;a href=&quot;#Loaders&quot; class=&quot;headerlink&quot; title=&quot;Loaders&quot;&gt;&lt;/a&gt;Loaders&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Loaders&lt;/code&gt;是&lt;code&gt;webpack&lt;/code&gt;中最强大的功能之一了。通过使用不同的&lt;code&gt;loader&lt;/code&gt;，&lt;code&gt;webpack&lt;/code&gt;通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，如分析&lt;code&gt;JSON&lt;/code&gt;文件并把它转换为&lt;code&gt;JavaScript&lt;/code&gt;文件；或把下一代的&lt;code&gt;js&lt;/code&gt;文件（&lt;code&gt;ES6，ES7&lt;/code&gt;)转换为现代浏览器可以识别的&lt;code&gt;JS&lt;/code&gt;文件；或对&lt;code&gt;React&lt;/code&gt;的开发而言，合适的&lt;code&gt;Loaders&lt;/code&gt;可以把&lt;code&gt;react&lt;/code&gt;的&lt;code&gt;JSX&lt;/code&gt;文件转换为&lt;code&gt;JS&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Loaders&lt;/code&gt;需要单独安装并且需要在&lt;code&gt;webpack.config.js&lt;/code&gt;下的&lt;code&gt;modules&lt;/code&gt;关键字下进行配置。安装命令为&lt;code&gt;npm install --save-dev json-loader&lt;/code&gt;，&lt;code&gt;Loaders&lt;/code&gt;的配置选项包括以下几方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test  一个匹配loaders所处理的文件的拓展名的正则表达式（必须）&lt;/li&gt;
&lt;li&gt;loader  loader的名称（必须）&lt;/li&gt;
&lt;li&gt;include/exclude  手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）&lt;/li&gt;
&lt;li&gt;query  为loaders提供额外的设置选项（可选）
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>浅谈webpack模块引用的五种方法</title>
    <link href="http://html-js.site/2017/06/23/%E6%B5%85%E8%B0%88webpack%E6%A8%A1%E5%9D%97%E5%BC%95%E7%94%A8%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://html-js.site/2017/06/23/浅谈webpack模块引用的五种方法/</id>
    <published>2017-06-23T01:24:54.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="commonjs格式的require同步语法"><a href="#commonjs格式的require同步语法" class="headerlink" title="commonjs格式的require同步语法"></a>commonjs格式的require同步语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">… <span class="comment">// 使用</span></div></pre></td></tr></table></figure>
<h3 id="commonjs格式的require-ensure异步语法"><a href="#commonjs格式的require-ensure异步语法" class="headerlink" title="commonjs格式的require.ensure异步语法"></a>commonjs格式的require.ensure异步语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>Home.js会被打包成一个单独的chunk文件：1.fb874860b35831bc96a8.js，其名称不具有可读性，因此一般给require.ensure传递第三个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/home<span class="string">');</span></div></pre></td></tr></table></figure></p>
<p>Home.js会被打包成一个具有指定文件名称的chunk文件：home.fb874860b35831bc96a8.js，该文件在bundle目录下。<br>在webpack.config.js文件中配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">output: &#123;  </div><div class="line">    <span class="attr">path</span>: __dirname + <span class="string">'/public'</span>,  </div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].js'</span>,  </div><div class="line">    <span class="attr">chunkFilename</span>: <span class="string">'[name].bundle.js'</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Home.js会被打包成一个具有指定文件名称的chunk文件：home.bundle.js，该文件在bundle目录下，而bundle目录又在/public目录下。<br>注意：如果在require.ensure的回调函数中引用了两个以上的模块，webpack会把它们打包在一起。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">    <span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/a-b<span class="string">');</span></div></pre></td></tr></table></figure></p>
<p>a.js和b.js会被打包成一个具有指定文件名称的chunk文件：a-b.bundle.js，，该文件在bundle目录下。如果不希望打包在一起，只能写多个require.ensure分别引用每一个模块。<br>给require.ensure传递的第一个参数可以是空数组，其实也可以是模块，实现预加载懒执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([<span class="string">'./Home'</span>], <span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/home<span class="string">');</span></div></pre></td></tr></table></figure></p>
<p>Home.js会被下载下来，即所谓的预加载，但不会执行Home.js模块中的代码，当执行到onsthome = require(‘./Home’)一句时才执行，即所谓的懒执行。</p>
<h3 id="webpack自带的require-include"><a href="#webpack自带的require-include" class="headerlink" title="webpack自带的require.include"></a>webpack自带的require.include</h3><p>require.include是webpack自身提供的，它可以实现require.ensure中的预加载功能，而不用把模块写在数组中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([],<span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="built_in">require</span>.include(<span class="string">'./Home'</span>);<span class="comment">// 只加载不执行  </span></div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>require.include的返回值是undefined，如果想使用模块，需要再通过require引入。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure([],<span class="built_in">require</span> =&gt; &#123;  </div><div class="line">    <span class="built_in">require</span>.include(<span class="string">'./Home'</span>);<span class="comment">// 只加载不执行  </span></div><div class="line">    <span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>); <span class="comment">// 执行  </span></div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;, bundle/home<span class="string">');</span></div></pre></td></tr></table></figure></p>
<h3 id="AMD异步加载"><a href="#AMD异步加载" class="headerlink" title="AMD异步加载"></a>AMD异步加载</h3><p>webpack既支持commonjs规范也支持AMD规范。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'./Home'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">home</span>)</span>&#123;  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>如果写了多个模块，那么这些模块都会被打包成一个文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;  </div><div class="line">    … <span class="comment">//使用  </span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>a.js和b.js会被打包在一起，但AMD的方式无法传入第三个参数来指定文件名称。<br>require AMD与require.ensure的区别：</p>
<ul>
<li>require AMD传递一个模块数组和回调函数，模块都被下载下来且都被执行后才执行回调函数；</li>
<li>require.ensure也是传递一个模块数组和回调函数，但是模块只会被下载下来，不会被执行，只有在回调函数中执行到require(模块)一句时，该模块才会被执行。<br>在webpack.config.js文件中配置：<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">entry</span>: <span class="string">'index.js'</span>  </div><div class="line">    output: &#123;  </div><div class="line">            <span class="attr">path</span>: __dirname + <span class="string">'/public'</span>,  </div><div class="line">            <span class="attr">filename</span>: <span class="string">'[name].js'</span>,  </div><div class="line">            <span class="attr">chunkFilename</span>: <span class="string">'[name].bundle.js'</span>  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ES6的import"><a href="#ES6的import" class="headerlink" title="ES6的import"></a>ES6的import</h3><p>import会被转化为commonjs格式或是AMD格式，所以它不是一种新的模块引用方式。babel默认会把ES6的模块转化为commonjs规范，因此不需要再把它转成AMD规范。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> home <span class="keyword">from</span> <span class="string">'./Home'</span>;</div></pre></td></tr></table></figure></p>
<p>等价于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">'./Home'</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;commonjs格式的require同步语法&quot;&gt;&lt;a href=&quot;#commonjs格式的require同步语法&quot; class=&quot;headerlink&quot; title=&quot;commonjs格式的require同步语法&quot;&gt;&lt;/a&gt;commonjs格式的require同步语法&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; home = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./Home&#39;&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;… &lt;span class=&quot;comment&quot;&gt;// 使用&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;commonjs格式的require-ensure异步语法&quot;&gt;&lt;a href=&quot;#commonjs格式的require-ensure异步语法&quot; class=&quot;headerlink&quot; title=&quot;commonjs格式的require.ensure异步语法&quot;&gt;&lt;/a&gt;commonjs格式的require.ensure异步语法&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;.ensure([], &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt; =&amp;gt; &amp;#123;  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; home = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;./Home&#39;&lt;/span&gt;);  &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    … &lt;span class=&quot;comment&quot;&gt;//使用  &lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack入门</title>
    <link href="http://html-js.site/2017/06/22/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://html-js.site/2017/06/22/webpack入门/</id>
    <published>2017-06-22T11:13:44.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在webpack看来，所有的资源文件都是模块，只是处理的方式不同。<br>webpack解决的需求点是：如何更好地加载前端模块。</p>
<h3 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h3><p>只需要指定一个入口文件，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果webpack没有进行全局安装，那么在终端中使用此命令时，需要额外指定其在node_modules中的地址。</p>
<p>若webpack全局安装，使用webpack app/main.js public/bundle.js命令即可。<br>若webpack非全局安装，需使用node_modules.bin\webpack app/main.js public/bundle.js命令。<br>注意：node_modules.bin\webpack的路径需用右斜杠形式，用左斜杠形式会报错。<br><a id="more"></a></p>
<h3 id="通过配置文件来使用webpack"><a href="#通过配置文件来使用webpack" class="headerlink" title="通过配置文件来使用webpack"></a>通过配置文件来使用webpack</h3><p>webpack拥有很多其它比较高级的功能，如<code>loaders</code>和<code>plugins</code>，这些功能其实都可以通过命令行模式实现，但这样不太方便且容易出错，一个更好的办法是定义一个配置文件，这个配置文件其实也是一个简单的<code>javascript</code>模块，可以把所有的与构建相关的信息放在里面。<br>以上面例子为例，在当根目录下新建一个名为<code>webpack.config.js</code>的文件，并进行配置，它包含入口文件路径和存放打包后文件的地方的路径。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;    </div><div class="line">    <span class="attr">entry</span>: __dirname + <span class="string">"/app/main.js"</span>, <span class="comment">// 唯一入口文件    </span></div><div class="line">    output: &#123;      </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>,<span class="comment">//打包后的文件存放的地方      </span></div><div class="line">        filename: <span class="string">"bundle.js"</span><span class="comment">//打包后输出文件的文件名  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注：<code>__dirname</code>是<code>node.js</code>中的一个全局变量，它指向当前执行脚本所在的目录。<br>若<code>webpack</code>全局安装，使用<code>webpack</code>命令即可。<br>若<code>webpack</code>非全局安装，需使用<code>node_modules\.bin\webpack</code>命令。<br>这条命令会自动参考<code>webpack.config.js</code>文件中的配置选项打包项目，按照上面提到的结果查看方法即可查看结果。</p>
<h3 id="更快捷的执行打包任务"><a href="#更快捷的执行打包任务" class="headerlink" title="更快捷的执行打包任务"></a>更快捷的执行打包任务</h3><p>执行类似于<code>node_modules\.bin\webpack</code>这样的命令其实是容易出错的，<code>npm</code>可以引导任务执行，对其进行配置后可以使用简单的<code>npm start</code>命令来代替这些繁琐的命令。在<code>package.json</code>中对<code>npm</code>的脚本部分进行相关设置即可：<br>默认的<code>test</code>直接删除，设置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="string">"scripts"</span>: &#123;  </div><div class="line">    <span class="string">"start"</span>: <span class="string">"webpack"</span>  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：添加注释<code>//</code>或者<code>/**/</code>在<code>JSON</code>文件中是不允许的，若用<code>js</code>的方式添加注释会报错。<br><code>package.json</code>中的脚本部分已经默认在命令前添加了<code>node_modules\.bin</code>路径，所以无论是全局还是局部安装的<code>webpack</code>，都不需要在前面指明详细的路径了。<br>无论是全局安装还是非全局安装，都只需要使用<code>npm start</code>命令，按照上面提到的结果查看方法即可查看结果。</p>
<h3 id="生成Source-Maps（调试更容易）"><a href="#生成Source-Maps（调试更容易）" class="headerlink" title="生成Source Maps（调试更容易）"></a>生成Source Maps（调试更容易）</h3><p>打包后的文件往往不容易找到出错的源代码的位置，<code>Source Maps</code>可以解决这个问题。<br>通过简单的配置后，<code>webpack</code>在打包时可以生成<code>source maps</code>，提供一种对应编译文件和源文件的方法，使得编译后的代码可读性更高，也更容易调试。<br>在<code>webpack</code>的配置文件中配置<code>source maps</code>，需要配置<code>devtool</code>，它有以下四种不同的配置选项，各具优缺点，描述如下：<br><code>devtool</code>选项  配置结果 </p>
<ul>
<li>source-map 在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的<code>source map</code>，但是它会减慢打包文件的构建速度。</li>
<li>cheap-module-source-map 在一个单独的文件中生成一个不带列映射的<code>map</code>，不带列映射提高项目构建速度，但也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便。</li>
<li>eval-source-map 使用<code>eval</code>打包源文件模块，在同一个文件中生成干净的完整的<code>source map</code>。这个选项可以在不影响构建速度的前提下生成完整的<code>sourcemap</code>，但是对打包后输出的<code>JS</code>文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项。</li>
<li>cheap-module-eval-source-map 这是在打包文件时最快的生成<code>source map</code>的方法，生成的<code>Source map</code>会和打包后的<code>JS</code>文件同行显示，没有列映射，和<code>eval-source-map</code>选项具有相似的缺点。</li>
</ul>
<p>上述选项由上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的构建速度的后果就是对打包后的文件的的执行有一定影响。<br>在学习阶段以及在小到中性的项目上，<code>eval-source-map</code>是一个很好的选项，不过记得只在开发阶段使用它；<code>cheap-module-eval-source-map</code>方法构建速度更快，但是不利于调试，推荐在大型项目考虑da时间成本是使用。</p>
<p>以上述例子为例，继续配置webpack.config.js文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>, <span class="comment">// 配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>, <span class="comment">// 已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>, <span class="comment">// 打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span> <span class="comment">// 打包后输出文件的文件名  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用webpack构建本地服务器"><a href="#使用webpack构建本地服务器" class="headerlink" title="使用webpack构建本地服务器"></a>使用webpack构建本地服务器</h3><p><code>webpack</code>提供一个可选的本地开发服务器，这个本地服务器基于<code>node.js</code>构建，可以实现浏览器监测代码的修改，并自动刷新修改后的结果，不过它是一个单独的组件，在<code>webpack</code>中进行配置之前需要单独安装它作为项目依赖，安装命令为<code>npm install --save-dev webpack-dev-server</code>。<br><code>devserver</code>作为<code>webpack</code>配置选项中的一项，具有以下配置选项：</p>
<ul>
<li>contentBase 默认<code>webpack-dev-server</code>会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录</li>
<li>port 设置默认监听端口，如果省略，默认为<code>8080</code></li>
<li>inline 设置为<code>true</code>，当源文件改变时会自动刷新页面</li>
<li>colors 设置为<code>true</code>，使终端输出的文件为彩色的</li>
<li>historyApiFallback 在开发单页应用时非常有用，它依赖于<code>HTML5 history API</code>，如果设置为<code>true</code>，所有的跳转将指向<code>index.html</code></li>
</ul>
<p>以上述例子为例，继续配置<code>webpack.config.js</code>文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;  </div><div class="line">    <span class="attr">devtool</span>: <span class="string">'eval-source-map'</span>, <span class="comment">// 配置生成Source Maps，选择合适的选项  </span></div><div class="line">    entry:  __dirname + <span class="string">"/app/main.js"</span>, <span class="comment">// 已多次提及的唯一入口文件  </span></div><div class="line">    output: &#123;  </div><div class="line">        <span class="attr">path</span>: __dirname + <span class="string">"/public"</span>, <span class="comment">// 打包后的文件存放的地方  </span></div><div class="line">        filename: <span class="string">"bundle.js"</span> <span class="comment">// 打包后输出文件的文件名  </span></div><div class="line">    &#125;,  </div><div class="line">    <span class="attr">devServer</span>: &#123;  </div><div class="line">        <span class="attr">contentBase</span>: <span class="string">"./public"</span>, <span class="comment">// 本地服务器所加载的页面所在的目录  </span></div><div class="line">        colors: <span class="literal">true</span>, <span class="comment">// 终端中输出结果为彩色  </span></div><div class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转  </span></div><div class="line">        inline: <span class="literal">true</span> <span class="comment">// 实时刷新  </span></div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>webpack有两个重要的功能：Loaders和Plugins。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在webpack看来，所有的资源文件都是模块，只是处理的方式不同。&lt;br&gt;webpack解决的需求点是：如何更好地加载前端模块。&lt;/p&gt;
&lt;h3 id=&quot;使用webpack&quot;&gt;&lt;a href=&quot;#使用webpack&quot; class=&quot;headerlink&quot; title=&quot;使用webpack&quot;&gt;&lt;/a&gt;使用webpack&lt;/h3&gt;&lt;p&gt;只需要指定一个入口文件，webpack将自动识别项目所依赖的其它文件，不过需要注意的是如果webpack没有进行全局安装，那么在终端中使用此命令时，需要额外指定其在node_modules中的地址。&lt;/p&gt;
&lt;p&gt;若webpack全局安装，使用webpack app/main.js public/bundle.js命令即可。&lt;br&gt;若webpack非全局安装，需使用node_modules.bin\webpack app/main.js public/bundle.js命令。&lt;br&gt;注意：node_modules.bin\webpack的路径需用右斜杠形式，用左斜杠形式会报错。&lt;br&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>npmlist</title>
    <link href="http://html-js.site/2017/06/07/npmlist/"/>
    <id>http://html-js.site/2017/06/07/npmlist/</id>
    <published>2017-06-07T02:48:19.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里收集了一些目前用到的一些npm库以及相关的功能</p>
<h3 id="node-glob-获取对应规则的文件-路径-所有文件"><a href="#node-glob-获取对应规则的文件-路径-所有文件" class="headerlink" title="node-glob  获取对应规则的文件/路径/所有文件"></a>node-glob  获取对应规则的文件/路径/所有文件</h3><blockquote>
<p>node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.<br>这个glob工具基于javascript.它使用了 minimatch 库来进行匹配<br><a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">https://github.com/isaacs/node-glob</a><br><a id="more"></a></p>
</blockquote>
<h3 id="inquirer-js-常见的交互式命令行用户接口的集合"><a href="#inquirer-js-常见的交互式命令行用户接口的集合" class="headerlink" title="inquirer.js 常见的交互式命令行用户接口的集合"></a>inquirer.js 常见的交互式命令行用户接口的集合</h3><p>创建交互式命令行用户接口<br><img src="/images/page/inquirer/1.png" alt=""></p>
<p>github地址： <a href="https://github.com/SBoudrias/Inquirer.js" target="_blank" rel="external">https://github.com/SBoudrias/Inquirer.js</a></p>
<h3 id="commander-js-node-js命令行接口的完整解决方案"><a href="#commander-js-node-js命令行接口的完整解决方案" class="headerlink" title="commander.js node.js命令行接口的完整解决方案"></a>commander.js node.js命令行接口的完整解决方案</h3><p><a href="http://nodejs.org" target="_blank" rel="external">node.js</a> 命令行接口的完整解决方案，灵感来自 Ruby 的 commander。<br><a href="http://tj.github.com/commander.js/" target="_blank" rel="external">API 文档</a><br>本文所有的例子都可以用 <code>node name.js &lt;command/option&gt;</code> 执行<br>吐槽：commander.js中文文档真的好难找哇</p>
<h3 id="portscanner-端口检查器"><a href="#portscanner-端口检查器" class="headerlink" title="portscanner 端口检查器"></a>portscanner 端口检查器</h3><p>portscanner可以检查对应端口是否被占用<br><a href="https://github.com/baalexander/node-portscanner" target="_blank" rel="external">https://github.com/baalexander/node-portscanner</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里收集了一些目前用到的一些npm库以及相关的功能&lt;/p&gt;
&lt;h3 id=&quot;node-glob-获取对应规则的文件-路径-所有文件&quot;&gt;&lt;a href=&quot;#node-glob-获取对应规则的文件-路径-所有文件&quot; class=&quot;headerlink&quot; title=&quot;node-glob  获取对应规则的文件/路径/所有文件&quot;&gt;&lt;/a&gt;node-glob  获取对应规则的文件/路径/所有文件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.&lt;br&gt;这个glob工具基于javascript.它使用了 minimatch 库来进行匹配&lt;br&gt;&lt;a href=&quot;https://github.com/isaacs/node-glob&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/isaacs/node-glob&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node-glob</title>
    <link href="http://html-js.site/2017/06/02/node-glob/"/>
    <id>http://html-js.site/2017/06/02/node-glob/</id>
    <published>2017-06-02T09:38:16.000Z</published>
    <updated>2017-07-06T06:55:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.<br>这个glob工具基于javascript.它使用了 minimatch 库来进行匹配<br><a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">https://github.com/isaacs/node-glob</a></p>
</blockquote>
<a id="more"></a>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install glob</div></pre></td></tr></table></figure>
<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> glob = <span class="built_in">require</span>(<span class="string">"glob"</span>)</div><div class="line"></div><div class="line"><span class="comment">// options 是可选的</span></div><div class="line">glob(<span class="string">"**/*.js"</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">  <span class="comment">// files 是匹配到的文件的数组.</span></div><div class="line">  <span class="comment">// 如果 `nonull` 选项被设置为true, 而且没有找到任何文件,那么files就是glob规则本身,而不是空数组</span></div><div class="line">  <span class="comment">// er是当寻找的过程中遇的错误</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>“globs” 就是模型,比如当你在命令行里输入 ls <em>.js,  又或者是你在 .gitignore 文件里写的 bulid/</em> 这些.<br>在解析路径模型的时候, 大括号里用多个逗号隔开的内容会被展开, 里面的部分也可以包含”/“ ,比如  <code>a{/b/c, bcd}</code>  会被展开成 <code>a/b/c</code> 和 <code>abcd</code></p>
<h2 id="路径中的某一段可以使用下面的这些字符表示-他们各自都有很炫的作用"><a href="#路径中的某一段可以使用下面的这些字符表示-他们各自都有很炫的作用" class="headerlink" title="路径中的某一段可以使用下面的这些字符表示,他们各自都有很炫的作用:"></a>路径中的某一段可以使用下面的这些字符表示,他们各自都有很炫的作用:</h2><h3 id="1-匹配该路径段中0个或多个任意字符"><a href="#1-匹配该路径段中0个或多个任意字符" class="headerlink" title="1. * : 匹配该路径段中0个或多个任意字符:"></a>1. * : 匹配该路径段中0个或多个任意字符:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//*:匹配路径中某部分:0个或多个字符</span></div><div class="line">glob(<span class="string">"js/*.js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>获取js目录下的所有js文件.(不包括以’.’开头的文件)</p>
<h3 id="2-匹配该路径段中1个任意字符"><a href="#2-匹配该路径段中1个任意字符" class="headerlink" title="2. ? : 匹配该路径段中1个任意字符:"></a>2. ? : 匹配该路径段中1个任意字符:</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//?:匹配路径中某部分:1个字符</span></div><div class="line">glob(<span class="string">"js/?.js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>获取js目录下所有名字只有1个字的js.</p>
<h3 id="3-…-匹配该路径段中在指定范围内字符"><a href="#3-…-匹配该路径段中在指定范围内字符" class="headerlink" title="3. […] : 匹配该路径段中在指定范围内字符:"></a>3. […] : 匹配该路径段中在指定范围内字符:</h3><p>注意不能组合,只能是其中一个字符<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//[]:匹配路径中某部分:指定的范围</span></div><div class="line">glob(<span class="string">"js/a[0-3].js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下a开头,第二个字符为0-3之间(包括0和3)的js(a03.js不能被匹配到)</p>
<h3 id="4-pattern-pattern-pattern-匹配括号中多个模型的0个或多个或任意个的组合"><a href="#4-pattern-pattern-pattern-匹配括号中多个模型的0个或多个或任意个的组合" class="headerlink" title="4. *(pattern|pattern|pattern) : 匹配括号中多个模型的0个或多个或任意个的组合"></a>4. *(pattern|pattern|pattern) : 匹配括号中多个模型的0个或多个或任意个的组合</h3><p>注意|前后不能有空格<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//*(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的0个或多个.</span></div><div class="line"><span class="comment">//除了三个模型本身,如果是组合也可以,比如ab.js,但是仅仅包含某个模型是不行的,比如a4.js.</span></div><div class="line">glob(<span class="string">"js/*(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下a.js,a1.js,b.js,或者a,a1,b这几个字符的组合的js,比如ab.js</p>
<h3 id="5-pattern-pattern-pattern-匹配不包含任何模型"><a href="#5-pattern-pattern-pattern-匹配不包含任何模型" class="headerlink" title="5. !(pattern|pattern|pattern) : 匹配不包含任何模型"></a>5. !(pattern|pattern|pattern) : 匹配不包含任何模型</h3><p>需要注意: !(pattern|pattern|pattern)  不等于 !(*(pattern|pattern|pattern))<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//!(pattern|pattern|pattern): 匹配路径中的某部分: 不包含任何模型.</span></div><div class="line"><span class="comment">//带有a或者b的,都排除.需要注意的是,它并非是*(a|b)的取反</span></div><div class="line">glob(<span class="string">"js/!(a|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下名字中不包含a,也不包含b的所有文件.</p>
<h3 id="6-pattern-pattern-pattern-匹配多个模型中的0个或任意1个"><a href="#6-pattern-pattern-pattern-匹配多个模型中的0个或任意1个" class="headerlink" title="6. ?(pattern|pattern|pattern) : 匹配多个模型中的0个或任意1个."></a>6. ?(pattern|pattern|pattern) : 匹配多个模型中的0个或任意1个.</h3><p>它和 4 的区别是,不可以组合.必须完全匹配<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//?(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的0个或1个.</span></div><div class="line"><span class="comment">//精确匹配模型,不可以组合.</span></div><div class="line">glob(<span class="string">"js/?(a|a2|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>获取js目录下a.js,a2.js,b.js</p>
<h3 id="7-pattern-pattern-pattern-匹配多个模型中的1个或多个"><a href="#7-pattern-pattern-pattern-匹配多个模型中的1个或多个" class="headerlink" title="7. +(pattern|pattern|pattern) : 匹配多个模型中的1个或多个."></a>7. +(pattern|pattern|pattern) : 匹配多个模型中的1个或多个.</h3><p>它和 4 的区别是,必须有一个,为空不匹配<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//+(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的1个或多个.</span></div><div class="line"><span class="comment">//可以是任意一个模型,也可以是他们的组合,比如ab.js</span></div><div class="line">glob(<span class="string">"js/+(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="8-pattern-pat-pat-erN-匹配多个模型中的任意1个"><a href="#8-pattern-pat-pat-erN-匹配多个模型中的任意1个" class="headerlink" title="8. @(pattern|pat*|pat?erN) : 匹配多个模型中的任意1个."></a>8. @(pattern|pat*|pat?erN) : 匹配多个模型中的任意1个.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//@(pattern|pattern|pattern): 匹配路径中的某部分: 多个模型中的1个.</span></div><div class="line"><span class="comment">//精确匹配模型,不可以组合.和?的区别就是不可以为空.必须要是其中的一个.</span></div><div class="line">glob(<span class="string">"js/@(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>和 6 的区别是不匹配为空的情况</p>
<h3 id="9-和-1-一样-可以匹配任何内容-但不仅匹配路径中的某一段-而且可以匹配-‘a-b-c’-这样带有’-‘的内容-所以-它还可以匹配子文件夹下的文件"><a href="#9-和-1-一样-可以匹配任何内容-但不仅匹配路径中的某一段-而且可以匹配-‘a-b-c’-这样带有’-‘的内容-所以-它还可以匹配子文件夹下的文件" class="headerlink" title="9.  : 和 1 一样,可以匹配任何内容,但不仅匹配路径中的某一段,而且可以匹配 ‘a/b/c’ 这样带有’/‘的内容,所以,它还可以匹配子文件夹下的文件."></a>9. <strong> : 和 1 一样,可以匹配任何内容,但</strong>不仅匹配路径中的某一段,而且可以匹配 ‘a/b/c’ 这样带有’/‘的内容,所以,它还可以匹配子文件夹下的文件.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//**: 不是一个单独的路径中的某部分,而是可以带有'/',所以所有当前文件夹和子文件夹下都进行匹配</span></div><div class="line">glob(<span class="string">"**/@(a|a1|b).js"</span>,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>获取当前目录所有文件夹及子文件夹下的a.js,a1.js,b.js<br>还有一种方式是设置 <code>matchBase</code> 属性为<code>true</code> ,同样可以起到在当前路径下搜索所有子文件夹的效果:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//matchBase: 设置为true以后,在当前目录下所有的文件夹和子文件夹里寻找匹配的文件</span></div><div class="line">glob(<span class="string">"@(a|a1|b).js"</span>,&#123;<span class="attr">matchBase</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="没有获取到任何匹配文件"><a href="#没有获取到任何匹配文件" class="headerlink" title="没有获取到任何匹配文件:"></a>没有获取到任何匹配文件:</h3><p>当glob没有获取到任何匹配的文件是,并不会像shell里那样返回模型本身,files参数返回的是一个空数组,如果需要让files返回的是模型本身,需要设置 <code>nonull</code> 属性为 <code>true</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//nonull: 设置为true以后,如果没有找到匹配的文件,不返回空字符串,而是返回原始glob语句</span></div><div class="line">glob(<span class="string">"@(c|d|e).js"</span>,&#123;<span class="attr">nonull</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">er, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="同步获取匹配文件列表"><a href="#同步获取匹配文件列表" class="headerlink" title="同步获取匹配文件列表:"></a>同步获取匹配文件列表:</h3><p>前面讲到的都是异步的方法,传入一个回调,当获取到匹配的文件的时候执行回调.如果需要同步的获取文件列表,可以这样做:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> files = glob.sync(pattern, [options])</div></pre></td></tr></table></figure></p>
<h2 id="Glob类"><a href="#Glob类" class="headerlink" title="Glob类:"></a>Glob类:</h2><p>通过实例化一个glob.Glob类,可以获得一个glob对象:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Glob = <span class="built_in">require</span>(<span class="string">"glob"</span>).Glob</div><div class="line"><span class="keyword">var</span> mg = <span class="keyword">new</span> Glob(pattern, options, cb)</div></pre></td></tr></table></figure></p>
<p>实例化的时候传入的参数和glob(pattern,options,cb)是一样的.<br>它能够得到一个返回值,这个返回值是一个EventEmitter.<br>如果在选项中设置 <code>sync</code> 属性为 <code>true</code>, 表示同步获取.不可以传入cb回调. 要获取匹配结果,可以通过 <code>g.found</code> 来获取:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globInstance = <span class="keyword">new</span> glob.Glob(<span class="string">"@(a|a1|b).js"</span>,&#123;<span class="attr">nonull</span>:<span class="literal">true</span>,<span class="attr">matchBase</span>:<span class="literal">true</span>,<span class="attr">sync</span>:<span class="literal">true</span>&#125;);</div><div class="line"><span class="built_in">console</span>.log(globInstance.found);</div></pre></td></tr></table></figure></p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件:"></a>事件:</h3><ul>
<li>end :  end事件会在文件匹配结束,找出所有匹配结果的时候触发,它接受的参数就是找到的文件的数组</li>
<li>match :  match事件会在每次匹配到一个文件的时候触发,它接受的参数就是匹配到的文件</li>
<li>error :  error事件会在匹配遇到错误的时候触发.接受的参数就是错误信息</li>
<li>abort :  当实例调用了.abort()方法时,abort事件被触发</li>
</ul>
<p>###　方法:</p>
<ul>
<li>pause 暂停匹配搜索</li>
<li>resume 继续匹配搜索</li>
<li>abort 永远停止匹配搜索,不能继续<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globInstance = <span class="keyword">new</span> glob.Glob(<span class="string">"js/@(a|a1|b).js"</span>,&#123;<span class="attr">nonull</span>:<span class="literal">true</span>&#125;);</div><div class="line">globInstance.on(<span class="string">'match'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(file)</div><div class="line">&#125;);</div><div class="line">globInstance.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">files</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(files)</div><div class="line">&#125;);</div><div class="line">globInstance.on(<span class="string">'abort'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'abort'</span>)</div><div class="line">&#125;);</div><div class="line">globInstance.pause();</div><div class="line">globInstance.resume();</div><div class="line">globInstance.abort();</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h3><ul>
<li>minimatch glob所使用的minimatch对象.</li>
<li>options 传递给函数的options选项.</li>
<li>aborted 调用过abort()函数后它的值就是true.</li>
<li>cache</li>
<li>statCache</li>
<li>symlinks</li>
<li>realpathCache </li>
</ul>
<h3 id="options选项"><a href="#options选项" class="headerlink" title="options选项:"></a>options选项:</h3><p>options用于配置模型匹配时候的匹配方式. 所有可以被传入到minimatch里的参数也都可以被传入到glob,另外node-glob还自己添加了一些配置项.</p>
<p>所有的选项如果没有特殊说明,默认值都是false</p>
<p>所有的选项也都适用于Glob类.</p>
<ul>
<li>cwd :检索目录</li>
<li>root </li>
<li>dot </li>
<li>nomount </li>
<li>mark</li>
<li>nosort </li>
<li>stat</li>
<li>… </li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;node的glob模块允许你使用 *等符号, 来写一个glob规则,获取匹配对应规则的文件.&lt;br&gt;这个glob工具基于javascript.它使用了 minimatch 库来进行匹配&lt;br&gt;&lt;a href=&quot;https://github.com/isaacs/node-glob&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/isaacs/node-glob&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="node" scheme="http://html-js.site/tags/node/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端-洋仔</title>
  <subtitle>专注于前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://html-js.site/"/>
  <updated>2017-02-14T09:17:22.200Z</updated>
  <id>http://html-js.site/</id>
  
  <author>
    <name>wangyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端跨域整理</title>
    <link href="http://html-js.site/2017/02/14/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E6%95%B4%E7%90%86/"/>
    <id>http://html-js.site/2017/02/14/前端跨域整理/</id>
    <published>2017-02-14T08:18:34.000Z</published>
    <updated>2017-02-14T09:17:22.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨域整理"><a href="#跨域整理" class="headerlink" title="跨域整理"></a>跨域整理</h2><h2 id="跨域资源共享-CORS"><a href="#跨域资源共享-CORS" class="headerlink" title="跨域资源共享 CORS"></a>跨域资源共享 CORS</h2><p>对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。<br>它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。<br><img src="/images/page/cors/1.png" alt=""><br>使用 CORS 跨域的时候其实和普通的 ajax 过程是一样的，只是浏览器在发现这是一个跨域请求的时候会自动帮我们处理一些事，比如验证等等，所以说只要服务端提供支持，前端是不需要做额外的事情的。</p>
<a id="more"></a>
<h2 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h2><p>CORS 的请求分两种，这也是浏览器为了安全做的一些处理，不同情况下浏览器执行的操作也是不一样的，主要分为两种请求，当然这一切我们是不需要做额外处理的，浏览器会自动处理的。</p>
<h2 id="简单请求（simple-request）"><a href="#简单请求（simple-request）" class="headerlink" title="简单请求（simple request）"></a>简单请求（simple request）</h2><p>只要同时满足以下两大条件，就属于简单请求。</p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1) 请求方法是以下三种方法中的一个：</div><div class="line">HEAD</div><div class="line">GET</div><div class="line">POST</div><div class="line">2）HTTP的头信息不超出以下几种字段：</div><div class="line">Accept</div><div class="line">Accept-Language</div><div class="line">Content-Language</div><div class="line">Last-Event-ID</div><div class="line">Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</div></pre></td></tr></table></figure>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>对于简单的跨域请求，浏览器会自动在请求的头信息加上 Origin 字段，表示本次请求来自哪个源（协议 + 域名 + 端口），服务端会获取到这个值，然后判断是否同意这次请求并返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 请求</div><div class="line">GET /cors HTTP/1.1</div><div class="line">Origin: https://api.qiutc.me</div><div class="line">Host: api.alice.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure></p>
<h3 id="1-服务端允许"><a href="#1-服务端允许" class="headerlink" title="1.服务端允许"></a>1.服务端允许</h3><p>如果服务端许可本次请求，就会在返回的头信息多出几个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 返回</div><div class="line">Access-Control-Allow-Origin: https://api.qiutc.me</div><div class="line">Access-Control-Allow-Credentials: true</div><div class="line">Access-Control-Expose-Headers: Info</div><div class="line">Content-Type: text/html; charset=utf-8</div></pre></td></tr></table></figure></p>
<p>这三个带有 <code>Access-Control</code> 开头的字段分别表示：</p>
<ul>
<li>Access-Control-Allow-Origin<br>必须。它的值是请求时Origin字段的值或者 <code>*</code>，表示接受任意域名的请求。</li>
<li>Access-Control-Allow-Credentials；<br>可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。<br>再需要发送cookie的时候还需要注意要在AJAX请求中打开withCredentials属性：<code>var xhr = new XMLHttpRequest(); xhr.withCredentials = true;</code><br><strong>需要注意的是</strong>，如果要发送Cookie，Access-Control-Allow-Origin就不能设为<code>*</code>，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</li>
<li>Access-Control-Expose-Headers<br>可选。CORS请求时，XMLHttpRequest对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，<code>getResponseHeader(&#39;Info&#39;)</code>可以返回Info字段的值。</li>
</ul>
<h3 id="2-服务端拒绝"><a href="#2-服务端拒绝" class="headerlink" title="2.服务端拒绝"></a>2.服务端拒绝</h3><p>当然我们为了防止接口被乱调用，需要限制源，对于不允许的源，服务端还是会返回一个正常的HTTP回应，但是不会带上 <code>Access-Control-Allow-Origin</code> 字段，浏览器发现这个跨域请求的返回头信息没有该字段，就会抛出一个错误，会被 <code>XMLHttpRequest</code> 的 <code>onerror</code> 回调捕获到。<br><strong>这种错误无法通过 HTTP 状态码判断，因为回应的状态码有可能是200</strong></p>
<h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>除了简单请求以外的CORS请求。<br>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<h2 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h2><h3 id="1）预检请求"><a href="#1）预检请求" class="headerlink" title="1）预检请求"></a>1）预检请求</h3><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>预检请求的发送请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OPTIONS /cors HTTP/1.1</div><div class="line">Origin: https://api.qiutc.me</div><div class="line">Access-Control-Request-Method: PUT</div><div class="line">Access-Control-Request-Headers: X-Custom-Header</div><div class="line">Host: api.qiutc.com</div><div class="line">Accept-Language: en-US</div><div class="line">Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0...</div></pre></td></tr></table></figure></p>
<p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。<br>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p>
<ul>
<li>Access-Control-Request-Method<br>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li><p>Access-Control-Request-Headers<br>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。<br>预检请求的返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</div><div class="line">Server: Apache/2.0.61 (Unix)</div><div class="line">Access-Control-Allow-Origin: https://api.qiutc.me</div><div class="line">Access-Control-Allow-Methods: GET, POST, PUT</div><div class="line">Access-Control-Allow-Headers: X-Custom-Header</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Content-Encoding: gzip</div><div class="line">Content-Length: 0</div><div class="line">Keep-Alive: timeout=2, max=100</div><div class="line">Connection: Keep-Alive</div><div class="line">Content-Type: text/plain</div></pre></td></tr></table></figure>
</li>
<li><p>Access-Control-Allow-Methods<br>必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p>
</li>
<li>Access-Control-Allow-Headers<br>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</li>
<li>Access-Control-Max-Age<br>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</li>
</ul>
<h3 id="2）浏览器的正常请求和回应"><a href="#2）浏览器的正常请求和回应" class="headerlink" title="2）浏览器的正常请求和回应"></a>2）浏览器的正常请求和回应</h3><p>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p>参考: <a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">《跨域资源共享 CORS 详解》:https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
<h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>sonp = json + padding<br>其实对于常用性来说，jsonp应该是使用最经常的一种跨域方式了，他不受浏览器兼容性的限制。但是他也有他的局限性，只能发送 GET 请求，需要服务端和前端规定好，写法丑陋。<br>它的原理在于浏览器请求 script 资源不受同源策略限制，并且请求到 script 资源后立即执行。<br>主要做法是这样的：</p>
<ul>
<li><p>在浏览器端：<br>首先全局注册一个callback回调函数，记住这个函数名字（比如：resolveJson），这个函数接受一个参数，参数是期望的到的服务端返回数据，函数的具体内容是处理这个数据。<br>然后动态生成一个 script 标签，src 为：请求资源的地址＋获取函数的字段名＋回调函数名称，这里的获取函数的字段名是要和服务端约定好的，是为了让服务端拿到回调函数名称。（如：<code>www.qiute.com?callbackName=resolveJson</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function resolveJosn(result) &#123;</div><div class="line">	console.log(result.name);</div><div class="line">&#125;</div><div class="line">var jsonpScript= document.createElement(&quot;script&quot;);</div><div class="line">jsonpScript.type = &quot;text/javascript&quot;;</div><div class="line">jsonpScript.src = &quot;https://www.qiute.com?callbackName=resolveJson&quot;;</div><div class="line">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(jsonpScript);</div></pre></td></tr></table></figure>
</li>
<li><p>服务端<br>在接受到浏览器端 script 的请求之后，从url的query的callbackName获取到回调函数的名字，例子中是<code>resolveJson</code>。<br>然后动态生成一段javascript片段去给这个函数传入参数执行这个函数。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">resolveJson(&#123;name: &apos;qiutc&apos;&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>执行<br>服务端返回这个 script 之后，浏览器端获取到 script 资源，然后会立即执行这个 javascript，也就是上面那个片段。这样就能根据之前写好的回调函数处理这些数据了。</p>
</li>
</ul>
<p>在一些第三方库往往都会封装jsonp的操作，比如 jQuery 的<code>$.getJSON</code>。</p>
<h2 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h2><p>一个页面框架（iframe／frame）之间（父子或同辈），是能够获取到彼此的window对象的，但是这个 window 不能拿到方法和属性（尼玛这有什么用，甩脸）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 当前页面域名 https://blog.qiutc.me/a.html</div><div class="line">&lt;script&gt;</div><div class="line">function onLoad() &#123;</div><div class="line">	var iframe =document.getElementById(&apos;iframe&apos;);</div><div class="line">	var iframeWindow = iframe.contentWindow; // 这里可以获取 iframe 里面 window 对象，但是几乎没用</div><div class="line">	var doc = iframeWindow.document; // 获取不到</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe src=&quot;https://www.qiutc.me/b.html&quot; onload=&quot;onLoad()&quot;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p>
<p>这个时候，<code>document.domain</code>就可以派上用场了，我们只要把 <code>https://blog.qiutc.me/a.html</code> 和 <code>https://www.qiutc.me/b.html</code> 这两个页面的 <code>document.domain</code> 都设成相同的域名就可以了。<br>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致。<br>但要注意的是，<code>document.domain</code> 的设置是有限制的，我们只能把 <code>document.domain</code> 设置成自身或更高一级的父域，且主域必须相同。例如：<code>a.b.example.com</code> 中某个文档的 <code>document.domain</code> 可以设成<code>a.b.example.com</code>、<code>b.example.com、example.com</code>中的任意一个，但是不可以设成 <code>c.a.b.example.com</code>,因为这是当前域的子域，也不可以设成<code>baidu.com</code>,因为主域已经不相同了。<br>这样我们就可以通过js访问到iframe中的各种属性和对象了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 主页面：https://blog.qiutc.me/a.html</div><div class="line">&lt;script&gt;</div><div class="line">document.domain = &apos;qiutc.me&apos;;</div><div class="line">function onLoad() &#123;</div><div class="line">	var iframe =document.getElementById(&apos;iframe&apos;);</div><div class="line">	var iframeWindow = iframe.contentWindow; // 这里可以获取 iframe 里面 window 对象并且能得到方法和属性</div><div class="line">	var doc = iframeWindow.document; // 获取到</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe src=&quot;https://www.qiutc.me/b.html&quot; onload=&quot;onLoad()&quot;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// iframe 里面的页面</div><div class="line">&lt;script&gt;</div><div class="line">document.domain = &apos;qiutc.me&apos;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 <code>window.name</code> 的，每个页面对 <code>window.name</code> 都有读写的权限，<code>window.name</code> 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<br>比如有一个<code>www.qiutc.me/a.html</code>页面，需要通过a.html页面里的js来获取另一个位于不同域上的页面<code>www.qiutc.com/data.html</code>里的数据。<br><code>data.html</code>页面里的代码很简单，就是给当前的<code>window.name</code>设置一个<code>a.html</code>页面想要得到的数据值。<code>data.html</code>里的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">window.name = &apos;我是被期望得到的数据&apos;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>那么在 <code>a.html</code> 页面中，我们怎么把 <code>data.html</code> 页面载入进来呢？显然我们不能直接在 <code>a.html</code> 页面中通过改变 <code>window.location</code> 来载入<code>data.html</code>页面（这简直扯蛋）因为我们想要即使 <code>a.html</code>页面不跳转也能得到 <code>data.html</code> 里的数据。<br>答案就是在 <code>a.html</code> 页面中使用一个隐藏的 <code>iframe</code> 来充当一个中间人角色，由 <code>iframe</code> 去获取 <code>data.html</code> 的数据，然后 <code>a.html</code> 再去得到 <code>iframe</code> 获取到的数据。<br>充当中间人的 <code>iframe</code> 想要获取到<code>data.html</code>的通过<code>window.name</code>设置的数据，只需要把这个<code>iframe</code>的<code>src</code>设为<code>www.qiutc.com/data.html</code>就行了。然后<code>a.html</code>想要得到iframe所获取到的数据，也就是想要得到<code>iframe</code>的<code>window.name</code>的值，还必须把这个<code>iframe</code>的<code>src</code>设成跟<code>a.html</code>页面同一个域才行，不然根据前面讲的同源策略，<code>a.html</code>是不能访问到<code>iframe</code>里的<code>window.name</code>属性的。这就是整个跨域过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// a.html</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;title&gt;Document&lt;/title&gt;</div><div class="line">  &lt;script&gt;</div><div class="line">	function getData() &#123;</div><div class="line">		var iframe =document.getElementById(&apos;iframe&apos;);</div><div class="line">		iframe.onload = function() &#123;</div><div class="line">			var data = iframe.contentWindow.name; // 得到</div><div class="line">		&#125;</div><div class="line">		iframe.src = &apos;b.html&apos;;  // 这里b和a同源</div><div class="line">	&#125;</div><div class="line">  &lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  &lt;iframe src=&quot;https://www.qiutc.com/data.html&quot; style=&quot;display:none&quot; onload=&quot;getData()&quot;&lt;/iframe&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h2 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h2><p><code>window.postMessage(message, targetOrigin)</code> 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。兼容性：<br><img src="/images/page/cors/2.png" alt=""><br>调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。<br>需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。<br>上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。在讨论第种方法的时候，我们说过，不同域的框架间是可以获取到对方的window对象的，虽然没什么用，但是有一个方法是可用的－<code>window.postMessage</code>。下面看一个简单的示例，有两个页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 主页面  blog.qiutc.com</div><div class="line">&lt;script&gt;</div><div class="line">function onLoad() &#123;</div><div class="line">	var iframe =document.getElementById(&apos;iframe&apos;);</div><div class="line">	var iframeWindow = iframe.contentWindow;</div><div class="line">	iframeWindow.postMessage(&quot;I&apos;m message from main page.&quot;);</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div><div class="line">&lt;iframe src=&quot;https://www.qiutc.me/b.html&quot; onload=&quot;onLoad()&quot;&lt;/iframe&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// b 页面</div><div class="line">&lt;script&gt;</div><div class="line">window.onmessage = function(e) &#123;</div><div class="line">	e = e || event;</div><div class="line">	console.log(e.data);</div><div class="line">&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h2 id="CSST-CSS-Text-Transformation"><a href="#CSST-CSS-Text-Transformation" class="headerlink" title="CSST (CSS Text Transformation)"></a>CSST (CSS Text Transformation)</h2><p>一种用 CSS 跨域传输文本的方案。<br>优点：相比 JSONP 更为安全，不需要执行跨站脚本。<br>缺点：没有 JSONP 适配广，CSST 依赖支持 CSS3 的浏览器。<br>原理：通过读取 CSS3 content 属性获取传送内容。<br>具体可以参考：<a href="https://github.com/zswang/csst" target="_blank" rel="external">CSST (CSS Text Transformation)</a></p>
<p>转载自： <a href="https://qiutc.me/post/cross-domain-collections.html" target="_blank" rel="external">https://qiutc.me/post/cross-domain-collections.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;跨域整理&quot;&gt;&lt;a href=&quot;#跨域整理&quot; class=&quot;headerlink&quot; title=&quot;跨域整理&quot;&gt;&lt;/a&gt;跨域整理&lt;/h2&gt;&lt;h2 id=&quot;跨域资源共享-CORS&quot;&gt;&lt;a href=&quot;#跨域资源共享-CORS&quot; class=&quot;headerlink&quot; title=&quot;跨域资源共享 CORS&quot;&gt;&lt;/a&gt;跨域资源共享 CORS&lt;/h2&gt;&lt;p&gt;对于web开发来讲，由于浏览器的同源策略，我们需要经常使用一些hack的方法去跨域获取资源，但是hack的方法总归是hack。直到W3C出了一个标准－CORS－”跨域资源共享”（Cross-origin resource sharing）。&lt;br&gt;它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。&lt;br&gt;首先来说 CORS 需要浏览器和服务端同时支持的，对于兼容性来说主要是ie10+，其它现代浏览器都是支持的。&lt;br&gt;&lt;img src=&quot;/images/page/cors/1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;使用 CORS 跨域的时候其实和普通的 ajax 过程是一样的，只是浏览器在发现这是一个跨域请求的时候会自动帮我们处理一些事，比如验证等等，所以说只要服务端提供支持，前端是不需要做额外的事情的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android WebView调试</title>
    <link href="http://html-js.site/2017/02/08/Android-WebView%E8%B0%83%E8%AF%95/"/>
    <id>http://html-js.site/2017/02/08/Android-WebView调试/</id>
    <published>2017-02-08T08:59:21.000Z</published>
    <updated>2017-02-08T09:31:29.213Z</updated>
    
    <content type="html"><![CDATA[<p>Google DevTools支持在PC Chrome上检查、分析、调试Android设备或者模拟器上的WebView页面。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1、PC"><a href="#1、PC" class="headerlink" title="1、PC"></a>1、PC</h3><p>a) 安装Chrome32以上版本。<br>b) 开启Chrome的USB检索功能：<br><br>   在Chrome中打开”chrome://inspect/#devices“，勾选”Discover USB devices“。<br><img src="/images/page/android-webview/1.png" alt=""></p>
<h3 id="2、Android手机（4-4及以上版本）-Android4-4模拟器"><a href="#2、Android手机（4-4及以上版本）-Android4-4模拟器" class="headerlink" title="2、Android手机（4.4及以上版本）/ Android4.4模拟器"></a>2、Android手机（4.4及以上版本）/ Android4.4模拟器</h3><p>a） 开启Debug:<br><br>    打开 “设置”à“开发选项”à“USB调试”。<br><img src="/images/page/android-webview/2.png" alt=""><br>注：一些手机默认隐藏了”开发选项“，需要进入”设置“à”关于手机“，然后连续点击”Android版本号“栏（大于等于7次），之后“设置“中将会出现”开发选项“。</p>
<h3 id="3、需要调试的目标Android-APP"><a href="#3、需要调试的目标Android-APP" class="headerlink" title="3、需要调试的目标Android APP"></a>3、需要调试的目标Android APP</h3><p>需要App中的WebView开启debug功能：<br><img src="/images/page/android-webview/3.png" alt=""><br>千牛Android App可以在运行时开启WebView的Debug功能：<br><br><a id="more"></a><br>进入“设置”à“关于千牛”,在如下界面点击千牛图标大于等于10次开启debug模式，开启后会有提示如下图：<br><img src="/images/page/android-webview/4.png" alt=""></p>
<h2 id="调试WebView页面"><a href="#调试WebView页面" class="headerlink" title="调试WebView页面"></a>调试WebView页面</h2><h3 id="1、通过USB线连接Android手机与PC。"><a href="#1、通过USB线连接Android手机与PC。" class="headerlink" title="1、通过USB线连接Android手机与PC。"></a>1、通过USB线连接Android手机与PC。</h3><p>如果出现”是否允许调试“的条框中，选择”确定“。<br><img src="/images/page/android-webview/5.png" alt=""></p>
<h3 id="2、调试Android-App中WebView页面："><a href="#2、调试Android-App中WebView页面：" class="headerlink" title="2、调试Android App中WebView页面："></a>2、调试Android App中WebView页面：</h3><p>在Android App中打开某个需要调试的WebView页面。然后在PC Chrome中打开”chrome://inspect“页面：<br><img src="/images/page/android-webview/6.png" alt=""><br>如图中列出的WebView实例，及其打开的页面信息。点击”inspect”打开页面调试窗口（注意：这步需要翻墙后才能打开,翻墙参考<a href="https://github.com/goagent/goagent）：" target="_blank" rel="external">https://github.com/goagent/goagent）：</a><br><img src="/images/page/android-webview/7.png" alt=""></p>
<p>FAQ:</p>
<ol>
<li>在PC Chrome”chrome://inspect“页面中看不到Android设备或者模拟器信息：</li>
<li>首先检查Android手机或者模拟器是否开起“Debug调试”，如果开启了还是不能展示，则需要检查驱动是否安装成功。</li>
<li>在PC Chrome”chrome://inspect“页面中看不到WebView页面信息：需要跟Android App人员确定获得的App是否开启WebView可调试。</li>
<li>在PC Chrome”chrome://inspect“页面中选择一个页面，点击“inspect”后打开的调试页面始终是空白：<strong>需要翻墙后再次打开</strong>。</li>
<li>更多详细资料可以参考：<a href="https://developer.chrome.com/devtools/docs/remote-debugging#install-adbplugin" target="_blank" rel="external">https://developer.chrome.com/devtools/docs/remote-debugging#install-adbplugin</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google DevTools支持在PC Chrome上检查、分析、调试Android设备或者模拟器上的WebView页面。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;h3 id=&quot;1、PC&quot;&gt;&lt;a href=&quot;#1、PC&quot; class=&quot;headerlink&quot; title=&quot;1、PC&quot;&gt;&lt;/a&gt;1、PC&lt;/h3&gt;&lt;p&gt;a) 安装Chrome32以上版本。&lt;br&gt;b) 开启Chrome的USB检索功能：&lt;br/&gt;&lt;br&gt;   在Chrome中打开”chrome://inspect/#devices“，勾选”Discover USB devices“。&lt;br&gt;&lt;img src=&quot;/images/page/android-webview/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、Android手机（4-4及以上版本）-Android4-4模拟器&quot;&gt;&lt;a href=&quot;#2、Android手机（4-4及以上版本）-Android4-4模拟器&quot; class=&quot;headerlink&quot; title=&quot;2、Android手机（4.4及以上版本）/ Android4.4模拟器&quot;&gt;&lt;/a&gt;2、Android手机（4.4及以上版本）/ Android4.4模拟器&lt;/h3&gt;&lt;p&gt;a） 开启Debug:&lt;br/&gt;&lt;br&gt;    打开 “设置”à“开发选项”à“USB调试”。&lt;br&gt;&lt;img src=&quot;/images/page/android-webview/2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;注：一些手机默认隐藏了”开发选项“，需要进入”设置“à”关于手机“，然后连续点击”Android版本号“栏（大于等于7次），之后“设置“中将会出现”开发选项“。&lt;/p&gt;
&lt;h3 id=&quot;3、需要调试的目标Android-APP&quot;&gt;&lt;a href=&quot;#3、需要调试的目标Android-APP&quot; class=&quot;headerlink&quot; title=&quot;3、需要调试的目标Android APP&quot;&gt;&lt;/a&gt;3、需要调试的目标Android APP&lt;/h3&gt;&lt;p&gt;需要App中的WebView开启debug功能：&lt;br&gt;&lt;img src=&quot;/images/page/android-webview/3.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;千牛Android App可以在运行时开启WebView的Debug功能：&lt;br/&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="手机调试" scheme="http://html-js.site/tags/%E6%89%8B%E6%9C%BA%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>React学习笔记1-Create React App</title>
    <link href="http://html-js.site/2017/01/17/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/"/>
    <id>http://html-js.site/2017/01/17/React学习笔记1/</id>
    <published>2017-01-17T06:37:57.000Z</published>
    <updated>2017-02-08T09:31:14.509Z</updated>
    
    <content type="html"><![CDATA[<p>React学习捷径：</p>
<blockquote>
<p>深入模式: React+ES6+WebPack+React Redux+Fetch+React Router+Immutable+React Native+NodeJs<br>正常模式: React+ES6+WebPack+React Redux<br>简易模式: React+ES6+WebPack+React Flux(React官方Flux库)</p>
</blockquote>
<p>在看了一些react的文档以及以下新手入门文档之后，就想动手写个项目练练手，虽然知道要用react、react-router等，但是项目的脚手架如果自己写的话对于新手来说基本不可能，所以网上找了一款脚手架：<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="external">Create React App</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm install -g create-react-app</div><div class="line"></div><div class="line">create-react-app my-app</div><div class="line">cd my-app/</div><div class="line">npm start</div></pre></td></tr></table></figure>
<p>然后访问 <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> 就可以看到初始页面了哦</p>
<p><img src="/images/page/react/1.png" alt=""></p>
<p>当然这个只是包含了react基础的npm包，以及静态服务，热插拔，其他如果要用的话可以自己install相关的插件。<br><a id="more"></a></p>
<ul><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#updating-to-new-releases" target="_blank" rel="external">Updating to New Releases</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#folder-structure" target="_blank" rel="external">Folder Structure</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#available-scripts" target="_blank" rel="external">Available Scripts</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#syntax-highlighting-in-the-editor" target="_blank" rel="external">Syntax Highlighting in the Editor</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#displaying-lint-output-in-the-editor" target="_blank" rel="external">Displaying Lint Output in the Editor</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#changing-the-page-title" target="_blank" rel="external">Changing the Page <code>&lt;title&gt;</code></a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#installing-a-dependency" target="_blank" rel="external">Installing a Dependency</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#importing-a-component" target="_blank" rel="external">Importing a Component</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-a-stylesheet" target="_blank" rel="external">Adding a Stylesheet</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#post-processing-css" target="_blank" rel="external">Post-Processing CSS</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-images-and-fonts" target="_blank" rel="external">Adding Images and Fonts</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#using-the-public-folder" target="_blank" rel="external">Using the <code>public</code> Folder</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#using-global-variables" target="_blank" rel="external">Using Global Variables</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-bootstrap" target="_blank" rel="external">Adding Bootstrap</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-flow" target="_blank" rel="external">Adding Flow</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-custom-environment-variables" target="_blank" rel="external">Adding Custom Environment Variables</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#can-i-use-decorators" target="_blank" rel="external">Can I Use Decorators?</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#integrating-with-a-node-backend" target="_blank" rel="external">Integrating with a Node Backend</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#proxying-api-requests-in-development" target="_blank" rel="external">Proxying API Requests in Development</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#using-https-in-development" target="_blank" rel="external">Using HTTPS in Development</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#generating-dynamic-meta-tags-on-the-server" target="_blank" rel="external">Generating Dynamic <code>&lt;meta&gt;</code> Tags on the Server</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#running-tests" target="_blank" rel="external">Running Tests</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#developing-components-in-isolation" target="_blank" rel="external">Developing Components in Isolation</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#making-a-progressive-web-app" target="_blank" rel="external">Making a Progressive Web App</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#deployment" target="_blank" rel="external">Deployment</a></li><br><li><a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#troubleshooting" target="_blank" rel="external">Troubleshooting</a></li><br></ul>

<blockquote>
<p>好了，赶紧开启我们的react之旅吧~</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;React学习捷径：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;深入模式: React+ES6+WebPack+React Redux+Fetch+React Router+Immutable+React Native+NodeJs&lt;br&gt;正常模式: React+ES6+WebPack+React Redux&lt;br&gt;简易模式: React+ES6+WebPack+React Flux(React官方Flux库)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在看了一些react的文档以及以下新手入门文档之后，就想动手写个项目练练手，虽然知道要用react、react-router等，但是项目的脚手架如果自己写的话对于新手来说基本不可能，所以网上找了一款脚手架：&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;Create React App&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;npm install -g create-react-app&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;create-react-app my-app&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cd my-app/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm start&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后访问 &lt;a href=&quot;http://localhost:3000&quot;&gt;http://localhost:3000&lt;/a&gt; 就可以看到初始页面了哦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/page/react/1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然这个只是包含了react基础的npm包，以及静态服务，热插拔，其他如果要用的话可以自己install相关的插件。&lt;br&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://html-js.site/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>package.json</title>
    <link href="http://html-js.site/2016/11/14/package-json/"/>
    <id>http://html-js.site/2016/11/14/package-json/</id>
    <published>2016-11-14T07:05:26.000Z</published>
    <updated>2016-11-14T08:48:21.902Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直没好好看过（看过忘了）package.json，然后各种项目本地运行的命令又很多，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">node index</div><div class="line">node server index</div><div class="line">npm run dev</div><div class="line">webpack --progress --colors</div><div class="line">webpack-dev-server --progress --colors</div></pre></td></tr></table></figure></p>
<p>这些命令很多，所以就研究了下package.json</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>每个项目的根目录下面，一般都有一个<code>package.json</code>文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。<code>npm install</code>命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。</p>
<p>下面是一个最简单的<code>package.json</code>文件，只定义两项元数据：项目名称和项目版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot; : &quot;xxx&quot;,</div><div class="line">  &quot;version&quot; : &quot;0.0.0&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码说明，<code>package.json</code>文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如<code>name</code>就是项目名称，<code>version</code>是版本（遵守“大版本.次要版本.小版本”的格式）。</p>
<a id="more"></a>
<p>下面是一个更完整的package.json文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	&quot;name&quot;: &quot;Hello World&quot;,</div><div class="line">	&quot;version&quot;: &quot;0.0.1&quot;,</div><div class="line">	&quot;author&quot;: &quot;张三&quot;,</div><div class="line">	&quot;description&quot;: &quot;第一个node.js程序&quot;,</div><div class="line">	&quot;keywords&quot;:[&quot;node.js&quot;,&quot;javascript&quot;],</div><div class="line">	&quot;repository&quot;: &#123;</div><div class="line">		&quot;type&quot;: &quot;git&quot;,</div><div class="line">		&quot;url&quot;: &quot;https://path/to/url&quot;</div><div class="line">	&#125;,</div><div class="line">	&quot;license&quot;:&quot;MIT&quot;,</div><div class="line">	&quot;engines&quot;: &#123;&quot;node&quot;: &quot;0.10.x&quot;&#125;,</div><div class="line">	&quot;bugs&quot;:&#123;&quot;url&quot;:&quot;http://path/to/bug&quot;,&quot;email&quot;:&quot;bug@example.com&quot;&#125;,</div><div class="line">	&quot;contributors&quot;:[&#123;&quot;name&quot;:&quot;李四&quot;,&quot;email&quot;:&quot;lisi@example.com&quot;&#125;],</div><div class="line">	&quot;scripts&quot;: &#123;</div><div class="line">		&quot;start&quot;: &quot;node index.js&quot;</div><div class="line">	&#125;,</div><div class="line">	&quot;dependencies&quot;: &#123;</div><div class="line">		&quot;express&quot;: &quot;latest&quot;,</div><div class="line">		&quot;mongoose&quot;: &quot;~3.8.3&quot;,</div><div class="line">		&quot;handlebars-runtime&quot;: &quot;~1.0.12&quot;,</div><div class="line">		&quot;express3-handlebars&quot;: &quot;~0.5.0&quot;,</div><div class="line">		&quot;MD5&quot;: &quot;~1.2.0&quot;</div><div class="line">	&#125;,</div><div class="line">	&quot;devDependencies&quot;: &#123;</div><div class="line">		&quot;bower&quot;: &quot;~1.2.8&quot;,</div><div class="line">		&quot;grunt&quot;: &quot;~0.4.1&quot;,</div><div class="line">		&quot;grunt-contrib-concat&quot;: &quot;~0.3.0&quot;,</div><div class="line">		&quot;grunt-contrib-jshint&quot;: &quot;~0.7.2&quot;,</div><div class="line">		&quot;grunt-contrib-uglify&quot;: &quot;~0.2.7&quot;,</div><div class="line">		&quot;grunt-contrib-clean&quot;: &quot;~0.5.0&quot;,</div><div class="line">		&quot;browserify&quot;: &quot;2.36.1&quot;,</div><div class="line">		&quot;grunt-browserify&quot;: &quot;~1.3.0&quot;,</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面详细解释<code>package.json</code>文件的各个字段。</p>
<h2 id="scripts字段"><a href="#scripts字段" class="headerlink" title="scripts字段"></a>scripts字段</h2><p><code>scripts</code>指定了运行脚本命令的npm命令行缩写，比如start指定了运行<code>npm run start</code>时，所要执行的命令。</p>
<p>下面的设置指定了<code>npm run preinstall</code>、<code>npm run postinstall</code>、<code>npm run start</code>、<code>npm run test</code>时，所要执行的命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;preinstall&quot;: &quot;echo here it comes!&quot;,</div><div class="line">    &quot;postinstall&quot;: &quot;echo there it goes!&quot;,</div><div class="line">    &quot;start&quot;: &quot;node index.js&quot;,</div><div class="line">    &quot;test&quot;: &quot;tap test/*.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="dependencies字段，devDependencies字段"><a href="#dependencies字段，devDependencies字段" class="headerlink" title="dependencies字段，devDependencies字段"></a>dependencies字段，devDependencies字段</h2><p><code>dependencies</code>字段指定了项目运行所依赖的模块，<code>devDependencies</code>指定项目开发所需要的模块。</p>
<p>它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;devDependencies&quot;: &#123;</div><div class="line">    &quot;browserify&quot;: &quot;~13.0.0&quot;,</div><div class="line">    &quot;karma-browserify&quot;: &quot;~5.0.1&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的版本可以加上各种限定，主要有以下几种：</p>
<blockquote>
<ul>
<li><strong>指定版本</strong>：比如<strong>1.2.2</strong>，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。</li>
<li><strong>波浪号（tilde）+指定版本</strong>：比如<strong>~1.2.2</strong>，表示安装<strong>1.2.x</strong>的最新版本（不低于<strong>1.2.2</strong>），但是不安装<strong>1.3.x</strong>，也就是说安装时不改变大版本号和次要版本号。</li>
<li><strong>插入号（caret）+指定版本</strong>：比如<strong>ˆ1.2.2</strong>，表示安装<strong>1.x.x</strong>的最新版本（不低于<strong>1.2.2</strong>），但是不安装<strong>2.x.x</strong>，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为<strong>0</strong>，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。</li>
<li><strong>latest</strong>：安装最新版本。</li>
</ul>
</blockquote>
<p><code>package.json</code>文件可以手工编写，也可以使用<code>npm init</code>命令自动生成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm init</div></pre></td></tr></table></figure></p>
<p>这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的<code>package.json</code>文件。所有问题之中，只有项目名称（<strong>name</strong>）和项目版本（<strong>version</strong>）是必填的，其他都是选填的。</p>
<p>有了<code>package.json</code>文件，直接使用<code>npm install</code>命令，就会在当前目录中安装所需要的模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install</div></pre></td></tr></table></figure></p>
<p>如果一个模块不在<code>package.json</code>文件之中，可以单独安装这个模块，并使用相应的参数，将其写入<code>package.json</code>文件之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install express --save</div><div class="line">$ npm install express --save-dev</div></pre></td></tr></table></figure></p>
<p>上面代码表示单独安装<code>express</code>模块，<code>--save</code>参数表示将该模块写入<code>dependencies</code>属性，<code>--save-dev</code>表示将该模块写入<code>devDependencies</code>属性。</p>
<h2 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a>peerDependencies</h2><p>有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。</p>
<p>大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。</p>
<p>最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。</p>
<p><code>peerDependencies</code>字段，就是用来供插件指定其所需要的主工具的版本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot;: &quot;chai-as-promised&quot;,</div><div class="line">  &quot;peerDependencies&quot;: &#123;</div><div class="line">    &quot;chai&quot;: &quot;1.x&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码指定，安装<code>chai-as-promised</code>模块时，主程序<code>chai</code>必须一起安装，而且<code>chai</code>的版本必须是<code>1.x</code>。如果你的项目指定的依赖是<code>chai</code>的<strong>2.0</strong>版本，就会报错。</p>
<p>注意，从<strong>npm 3.0</strong>版开始，<code>peerDependencies</code>不再会默认安装了。</p>
<h2 id="bin字段"><a href="#bin字段" class="headerlink" title="bin字段"></a>bin字段</h2><p>bin项用来指定各个内部命令对应的可执行文件的位置.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;bin&quot;: &#123;</div><div class="line">  &quot;someTool&quot;: &quot;./bin/someTool.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码指定，<strong>someTool</strong> 命令对应的可执行文件为 <strong>bin</strong> 子目录下的 <strong>someTool.js</strong>。<strong>Npm</strong>会寻找这个文件，在<code>node_modules/.bin/</code>目录下建立符号链接。在上面的例子中，<code>someTool.js</code>会建立符号链接<code>npm_modules/.bin/someTool</code>。由于<code>node_modules/.bin/</code>目录会在运行时加入系统的<strong>PATH</strong>变量，因此在运行<strong>npm</strong>时，就可以不带路径，直接通过命令来调用这些脚本。</p>
<p>因此，像下面这样的写法可以采用简写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">scripts: &#123;  </div><div class="line">  start: &apos;./node_modules/someTool/someTool.js build&apos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 简写为</div><div class="line"></div><div class="line">scripts: &#123;  </div><div class="line">  start: &apos;someTool build&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所有<code>node_modules/.bin/</code>目录下的命令，都可以用<code>npm run [命令]</code>的格式运行。在命令行下，键入<code>npm run</code>，然后按tab键，就会显示所有可以使用的命令。</p>
<h2 id="main字段"><a href="#main字段" class="headerlink" title="main字段"></a>main字段</h2><p><code>main</code>字段指定了加载的入口文件，<code>require(&#39;moduleName&#39;)</code>就会加载这个文件。这个字段的默认值是模块根目录下面的<code>index.js</code>。</p>
<h2 id="config字段"><a href="#config字段" class="headerlink" title="config字段."></a>config字段.</h2><p><strong>config</strong>字段用于向环境变量输出值。</p>
<p>下面是一个<strong>package.json</strong>文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;name&quot; : &quot;foo&quot;,</div><div class="line">  &quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;,</div><div class="line">  &quot;scripts&quot; : &#123; &quot;start&quot; : &quot;node server.js&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后，在<code>server.js</code>脚本就可以引用<strong>config</strong>字段的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http.createServer(...).listen(process.env.npm_package_config_port)</div></pre></td></tr></table></figure></p>
<p>用户可以改变这个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm config set foo:port 80</div></pre></td></tr></table></figure></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="browser字段"><a href="#browser字段" class="headerlink" title="browser字段"></a>browser字段</h3><p><strong>browser</strong>指定该模板供浏览器使用的版本。<strong>Browserify</strong>这样的浏览器打包工具，通过它就知道该打包那个文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;browser&quot;: &#123;</div><div class="line">  &quot;tipso&quot;: &quot;./node_modules/tipso/src/tipso.js&quot;</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<h3 id="engines字段"><a href="#engines字段" class="headerlink" title="engines字段"></a>engines字段</h3><p><strong>engines</strong>指明了该项目所需要的<strong>node.js</strong>版本。</p>
<h3 id="man字段"><a href="#man字段" class="headerlink" title="man字段"></a>man字段</h3><p><strong>man</strong>用来指定当前模块的<strong>man</strong>文档的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;man&quot; :[ &quot;./doc/calc.1&quot; ]</div></pre></td></tr></table></figure></p>
<h3 id="preferGlobal字段"><a href="#preferGlobal字段" class="headerlink" title="preferGlobal字段"></a>preferGlobal字段</h3><p><strong>preferGlobal</strong>的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用<strong>–global</strong>参数），要不要显示警告，表示该模块的本意就是安装为全局模块。</p>
<h3 id="style字段"><a href="#style字段" class="headerlink" title="style字段"></a>style字段</h3><p><strong>style</strong>指定供浏览器使用时，样式文件所在的位置。样式文件打包工具<strong>parcelify</strong>，通过它知道样式文件的打包位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;style&quot;: [</div><div class="line">  &quot;./node_modules/tipso/src/tipso.css&quot;</div><div class="line">]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前一直没好好看过（看过忘了）package.json，然后各种项目本地运行的命令又很多，如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;node index&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;node server index&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;npm run dev&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webpack --progress --colors&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;webpack-dev-server --progress --colors&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这些命令很多，所以就研究了下package.json&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;每个项目的根目录下面，一般都有一个&lt;code&gt;package.json&lt;/code&gt;文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。&lt;code&gt;npm install&lt;/code&gt;命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。&lt;/p&gt;
&lt;p&gt;下面是一个最简单的&lt;code&gt;package.json&lt;/code&gt;文件，只定义两项元数据：项目名称和项目版本。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;quot;name&amp;quot; : &amp;quot;xxx&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;quot;version&amp;quot; : &amp;quot;0.0.0&amp;quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面代码说明，&lt;code&gt;package.json&lt;/code&gt;文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如&lt;code&gt;name&lt;/code&gt;就是项目名称，&lt;code&gt;version&lt;/code&gt;是版本（遵守“大版本.次要版本.小版本”的格式）。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式六大原则之单一职责原则</title>
    <link href="http://html-js.site/2016/11/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E4%B9%8B%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://html-js.site/2016/11/11/设计模式六大原则之单一职责原则/</id>
    <published>2016-11-11T06:01:47.000Z</published>
    <updated>2016-11-11T06:24:42.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>此原则的核心就是解耦和增强内聚性。</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>一个方法只负责一项职责</p>
<p>其实很好理解，每个方法只有单一的功能，这样就不会相互影响，修改这个方法也就不会影响到其他的方法</p>
<p>说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。</p>
<h2 id="遵循单一职责原的优点"><a href="#遵循单一职责原的优点" class="headerlink" title="遵循单一职责原的优点"></a>遵循单一职责原的优点</h2><ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<blockquote>
<p>tips：请尽量遵循这一原则，不要为了偷懒而把一些简单的功能写到一个方法里面。因为未来可能会有一些需求或者什么，加点功能或修改一点功能，最终这个很简单的方法就会变得臃肿并且很难着手修改，修改也可能会影响到其他地方。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;此原则的核心就是解耦和增强内聚性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;一个方法只负责一项职责&lt;/p&gt;
&lt;p
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浏览器实现粘贴板复制功能</title>
    <link href="http://html-js.site/2016/10/28/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B2%98%E8%B4%B4%E6%9D%BF%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD/"/>
    <id>http://html-js.site/2016/10/28/浏览器实现粘贴板复制功能/</id>
    <published>2016-10-28T07:59:39.000Z</published>
    <updated>2016-10-28T08:26:32.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>PC端项目很多都会用到复制到粘贴板的功能，但是由于浏览器的差异（IE/ff）和支持情况的而不同导致各种兼容</p>
</blockquote>
<p>本来一直用的<a href="http://zeroclipboard.org/" target="_blank" rel="external">zeroClipboard</a>插件，这个插件主要用了flash来实现，flash可以绕过浏览器不兼容的问题，兼容性还不错，但是依赖浏览器flash插件，有些用户可能会为了禁掉各种广告而禁掉flash插件，甚至<a href="http://www.ghacks.net/2015/07/14/mozilla-blocks-all-versions-of-adobe-flash-in-firefox/" target="_blank" rel="external">FF浏览器本身就对flash插件进行了限制</a>，导致有客户来问，所以研究了下相关内容；</p>
<p>这里介绍一套解决方案：<a href="https://clipboardjs.com/" target="_blank" rel="external">clipBoard.js</a>，这个插件纯js实现，主要原理是用到了<code>document.execCommand(&#39;copy&#39;)</code>方法，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand" target="_blank" rel="external">使用详解</a>，这个方法可以鼠标选中的内容；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">简单的实现：</div><div class="line">&lt;input type=&quot;text&quot; id=&quot;input1&quot;&gt;</div><div class="line">    &lt;input type=&quot;button&quot; Value=&quot;click&quot; onclick=&quot;copy()&quot;&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">        function copy () &#123;</div><div class="line">            var input = document.createElement(&apos;input&apos;);</div><div class="line">            input.value = document.getElementById(&apos;input1&apos;).value;</div><div class="line">            input.style = &quot;opacity:0&quot;</div><div class="line">            document.body.appendChild(input);</div><div class="line">            input.select();</div><div class="line">            document.execCommand(&apos;copy&apos;);</div><div class="line">            console.log(&apos;Copy!&apos;);</div><div class="line">            input.remove();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>下面介绍一整套解决方案:</p>
<h3 id="判断浏览器"><a href="#判断浏览器" class="headerlink" title="判断浏览器"></a>判断浏览器</h3><p>因为clipboard兼容ie9以上，所以需要判断浏览器<br><img src="/images/page/clipboard/1.jpg" alt=""><br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div></pre></td><td class="code"><pre><div class="line">//getClient为判断浏览器 方法地址：/resources/js/component.js</div><div class="line">          var client = getClient();</div><div class="line">          if(window.clipboardData)&#123;</div><div class="line">            //for IE</div><div class="line">            var copyBtn = document.getElementById(&quot;copy&quot;);</div><div class="line">            copyBtn.onclick = function()&#123; </div><div class="line">            var text = $(&quot;#copy&quot;).attr(&quot;data-clipboard-text&quot;);</div><div class="line">              window.clipboardData.setData(&apos;text&apos;,text); </div><div class="line">              alert(&quot;复制成功，地址为： &quot; + text);</div><div class="line">            &#125;</div><div class="line">          &#125; else &#123;</div><div class="line">            if ((client.browser.firefox &amp;&amp; client.browser.firefox &gt; 41) || (client.browser.chrome &amp;&amp; client.browser.chrome &gt; 42) || (client.browser.ie &amp;&amp; client.browser.ie &gt; 8) || (client.browser.safari &amp;&amp; client.browser.safari &gt; 10) || (client.browser.opera &amp;&amp; client.browser.opera &gt; 29)) &#123;</div><div class="line">              //使用clipboard.js，非flash插件</div><div class="line">              clip = new Clipboard(&apos;.mytemp-list-copy&apos;);</div><div class="line"></div><div class="line">              clip.on(&apos;success&apos;, function(e) &#123;</div><div class="line">                Tatami.toast(&apos;复制成功,点击页面推广去设置&apos;);</div><div class="line">                console.info(&apos;Action:&apos;, e.action);</div><div class="line">                console.info(&apos;Text:&apos;, e.text);</div><div class="line">                console.info(&apos;Trigger:&apos;, e.trigger);</div><div class="line"></div><div class="line">                e.clearSelection();</div><div class="line">              &#125;);</div><div class="line"></div><div class="line">              clip.on(&apos;error&apos;, function(e) &#123;</div><div class="line">                console.error(&apos;Action:&apos;, e.action);</div><div class="line">                console.error(&apos;Trigger:&apos;, e.trigger);</div><div class="line">              &#125;);</div><div class="line">            &#125; else &#123;</div><div class="line">              // 用ZeroClipboard插件 使用的flash</div><div class="line">              clip = new ZeroClipboard($(&apos;.mytemp-list-copy&apos;));</div><div class="line">              clip.on(&apos;aftercopy&apos;, function () &#123;</div><div class="line">                Tatami.toast(&apos;复制成功,点击页面推广去设置&apos;);</div><div class="line">              &#125;);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * [浏览器引擎、平台、Windows操作系统、移动设备和游戏系统检测]</div><div class="line"> */</div><div class="line">function getClient() &#123;</div><div class="line">    //呈现引擎</div><div class="line">    var engine = &#123;</div><div class="line">        ie: 0,</div><div class="line">        gecko: 0,</div><div class="line">        webkit: 0,</div><div class="line">        khtml: 0,</div><div class="line">        opera: 0,</div><div class="line"></div><div class="line">        //版本号</div><div class="line">        ver: null</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    //浏览器</div><div class="line">    var browser = &#123;</div><div class="line">        ie: 0,</div><div class="line">        firefox: 0,</div><div class="line">        opera: 0,</div><div class="line">        safari: 0,</div><div class="line">        chrome: 0,</div><div class="line">        konq: 0,</div><div class="line">        //版本号</div><div class="line">        ver: null</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    //平台、设备和操作系统</div><div class="line">    var system = &#123;</div><div class="line">        win: false,</div><div class="line">        mac: false,</div><div class="line"></div><div class="line">        //移动设备</div><div class="line">        iphone: false,</div><div class="line">        ipod: false,</div><div class="line">        ipad: false,</div><div class="line">        ios: false,</div><div class="line">        android: false,</div><div class="line">        winMobile: false,</div><div class="line">        nokiaN: false,</div><div class="line"></div><div class="line">        //游戏系统</div><div class="line">        wii: false,</div><div class="line">        ps: false</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //检测浏览器和引擎</div><div class="line">    var ua = navigator.userAgent;</div><div class="line">    //优先检测opera浏览器</div><div class="line">    if (window.opera) &#123;</div><div class="line">        engine.ver = browser.ver = window.opera.version();</div><div class="line">        engine.opera = browser.opera = parseFloat(engine.ver);</div><div class="line">    &#125; else if (/AppleWebKit\/(\S+)/.test(ua)) &#123;</div><div class="line">        engine.ver = RegExp[&apos;$1&apos;];</div><div class="line">        engine.webkit = parseFloat(engine.ver);</div><div class="line"></div><div class="line">        //判断是chrome还是safari</div><div class="line">        if (/Chrome\/(\S+)/.test(ua)) &#123;</div><div class="line">            browser.ver = RegExp[&apos;$1&apos;];</div><div class="line">            browser.chrome = parseFloat(browser.ver);</div><div class="line">        &#125; else if (/Version\/(\S+)/.test(ua)) &#123;</div><div class="line">            browser.ver = RegExp[&apos;$1&apos;];</div><div class="line">            browser.safari = parseFloat(browser.ver);</div><div class="line">        &#125; else &#123;</div><div class="line">            //近似确定Safari版本号</div><div class="line">            var safariVersion = 1;</div><div class="line">            if (engine.webkit &lt; 100) &#123;</div><div class="line">                safariVersion = 1;</div><div class="line">            &#125; else if (engine.webkit &lt; 312) &#123;</div><div class="line">                safariVersion = 1.2;</div><div class="line">            &#125; else if (engine.webkit &lt; 412) &#123;</div><div class="line">                safariVersion = 1.3;</div><div class="line">            &#125; else &#123;</div><div class="line">                safariVersion = 2;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            browser.safari = browser.ver = safariVersion;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) &#123;</div><div class="line">        engine.ver = browser.ver = RegExp[&apos;$1&apos;];</div><div class="line">        engine.khtml = browser.konq = parseFloat(engine.ver);</div><div class="line">    &#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua)) &#123;</div><div class="line">        engine.ver = RegExp[&apos;$1&apos;];</div><div class="line">        engine.gecko = parseFloat(engine.ver);</div><div class="line"></div><div class="line">        //判断是否是firefox</div><div class="line">        if (/Firefox\/(\S+)/.test(ua)) &#123;</div><div class="line">            browser.ver = RegExp[&apos;$1&apos;];</div><div class="line">            browser.firefox = parseFloat(browser.ver);</div><div class="line">        &#125;</div><div class="line">    &#125; else if (/MSIE ([^;]+)/.test(ua)) &#123;</div><div class="line">        engine.ver = browser.ver = RegExp[&apos;$1&apos;];</div><div class="line">        engine.ie = browser.ie = parseFloat(engine.ver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //检测浏览器</div><div class="line">    browser.ie = engine.ie;</div><div class="line">    browser.opera = engine.opera;</div><div class="line"></div><div class="line">    //检测平台</div><div class="line">    var p = navigator.platform;</div><div class="line">    system.win = p.indexOf(&apos;Win&apos;) === 0;</div><div class="line">    system.mac = p.indexOf(&apos;Mac&apos;) === 0;</div><div class="line">    system.x11 = (p == &apos;X11&apos;) || (p.indexOf(&apos;Linux&apos;) === 0);</div><div class="line"></div><div class="line">    //检测windows操作系统</div><div class="line">    if (system.win) &#123;</div><div class="line">        if (/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/.test(ua)) &#123;</div><div class="line">            if (RegExp[&apos;$1&apos;] === &apos;NT&apos;) &#123;</div><div class="line">                switch (RegExp[&apos;$2&apos;]) &#123;</div><div class="line">                    case &apos;5.0&apos;:</div><div class="line">                        system.win = &apos;2000&apos;;</div><div class="line">                        break;</div><div class="line">                    case &apos;5.1&apos;:</div><div class="line">                        system.win = &apos;xp&apos;;</div><div class="line">                        break;</div><div class="line">                    case &apos;6.0&apos;:</div><div class="line">                        system.win = &apos;Vista&apos;;</div><div class="line">                        break;</div><div class="line">                    case &apos;6.1&apos;:</div><div class="line">                        system.win = &apos;7&apos;;</div><div class="line">                        break;</div><div class="line">                    default:</div><div class="line">                        system.win = &apos;NT&apos;;</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">            &#125; else if (RegExp[&apos;$1&apos;] === &apos;9x&apos;) &#123;</div><div class="line">                system.win = &apos;ME&apos;;</div><div class="line">            &#125; else &#123;</div><div class="line">                system.win = RegExp[&apos;$1&apos;];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //检测移动设备</div><div class="line">    system.iphone = ua.indexOf(&apos;iPhone&apos;) &gt; -1;</div><div class="line">    system.ipod = ua.indexOf(&apos;iPod&apos;) &gt; -1;</div><div class="line">    system.ipad = ua.indexOf(&apos;iPad&apos;) &gt; -1;</div><div class="line">    system.nokiaN = ua.indexOf(&apos;NokiaN&apos;) &gt; -1;</div><div class="line"></div><div class="line">    //windows mobile</div><div class="line">    if (system.win === &apos;CE&apos;) &#123;</div><div class="line">        system.winMobile = system.win;</div><div class="line">    &#125; else if (system.win === &apos;Ph&apos;) &#123;</div><div class="line">        if (/Windows Phone OS (\d+.\d+)/.test(ua)) &#123;</div><div class="line">            system.win = &apos;Phone&apos;;</div><div class="line">            system.winMobile = parseFloat(RegExp[&apos;$1&apos;]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //检测ios 版本</div><div class="line">    if (system.mac &amp;&amp; ua.indexOf(&apos;Mobile&apos;) &gt; -1) &#123;</div><div class="line">        if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)) &#123;</div><div class="line">            system.ios = parseFloat(RegExp.$1.replace(&apos;_&apos;, &apos;.&apos;));</div><div class="line">        &#125; else &#123;</div><div class="line">            system.ios = 2; //猜测的， 并非真正检测出来</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //检测android 版本</div><div class="line">    if (/Android(\d+\.\d+)/.test(ua)) &#123;</div><div class="line">        system.android = parseFloat(RegExp[&apos;$1&apos;]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //游戏系统</div><div class="line">    system.wii = ua.indexOf(&apos;Wii&apos;) &gt; -1;</div><div class="line">    system.ps = /playstation/i.test(ua);</div><div class="line"></div><div class="line">    return &#123;</div><div class="line">        engine: engine,</div><div class="line">        browser: browser,</div><div class="line">        system: system</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;PC端项目很多都会用到复制到粘贴板的功能，但是由于浏览器的差异（IE/ff）和支持情况的而不同导致各种兼容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本来一直用的&lt;a href=&quot;http://zeroclipboard.org/&quot;&gt;zeroClipboard&lt;/a&gt;插件，这个插件主要用了flash来实现，flash可以绕过浏览器不兼容的问题，兼容性还不错，但是依赖浏览器flash插件，有些用户可能会为了禁掉各种广告而禁掉flash插件，甚至&lt;a href=&quot;http://www.ghacks.net/2015/07/14/mozilla-blocks-all-versions-of-adobe-flash-in-firefox/&quot;&gt;FF浏览器本身就对flash插件进行了限制&lt;/a&gt;，导致有客户来问，所以研究了下相关内容；&lt;/p&gt;
&lt;p&gt;这里介绍一套解决方案：&lt;a href=&quot;https://clipboardjs.com/&quot;&gt;clipBoard.js&lt;/a&gt;，这个插件纯js实现，主要原理是用到了&lt;code&gt;document.execCommand(&amp;#39;copy&amp;#39;)&lt;/code&gt;方法，&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand&quot;&gt;使用详解&lt;/a&gt;，这个方法可以鼠标选中的内容；&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;简单的实现：&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;input1&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;input type=&amp;quot;button&amp;quot; Value=&amp;quot;click&amp;quot; onclick=&amp;quot;copy()&amp;quot;&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;script&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        function copy () &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            var input = document.createElement(&amp;apos;input&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            input.value = document.getElementById(&amp;apos;input1&amp;apos;).value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            input.style = &amp;quot;opacity:0&amp;quot;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            document.body.appendChild(input);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            input.select();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            document.execCommand(&amp;apos;copy&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            console.log(&amp;apos;Copy!&amp;apos;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            input.remove();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;/script&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下面介绍一整套解决方案:&lt;/p&gt;
&lt;h3 id=&quot;判断浏览器&quot;&gt;&lt;a href=&quot;#判断浏览器&quot; class=&quot;headerlink&quot; title=&quot;判断浏览器&quot;&gt;&lt;/a&gt;判断浏览器&lt;/h3&gt;&lt;p&gt;因为clipboard兼容ie9以上，所以需要判断浏览器&lt;br&gt;&lt;img src=&quot;/images/page/clipboard/1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue实例属性汇总和生命周期</title>
    <link href="http://html-js.site/2016/10/12/vue%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E6%B1%87%E6%80%BB%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://html-js.site/2016/10/12/vue实例属性汇总和生命周期/</id>
    <published>2016-10-12T07:20:42.000Z</published>
    <updated>2016-10-13T08:52:19.170Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>做了个仿cnode的spa项目，用vue-cli搭了项目，用到了cnode的api和vue-router. <a href="https://github.com/WangYang-Rex/learn-vue" target="_blank" rel="external">项目地址&gt;&gt;</a></p>
</blockquote>
<p>看了很多遍vue和vue-router的文档，这里记录下</p>
<a id="more"></a>
<h2 id="Vue实例属性汇总"><a href="#Vue实例属性汇总" class="headerlink" title="Vue实例属性汇总"></a>Vue实例属性汇总</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line">export default &#123;</div><div class="line">	init () &#123;</div><div class="line">		console.log(&apos;init&apos;);</div><div class="line">	&#125;,</div><div class="line">	created () &#123;</div><div class="line">		console.log(&apos;created&apos;);</div><div class="line">	&#125;,</div><div class="line">	beforeCompile () &#123;</div><div class="line">		console.log(&apos;beforeCompile&apos;);</div><div class="line">	&#125;,</div><div class="line">	compile () &#123;</div><div class="line">		console.log(&apos;compile&apos;);</div><div class="line">	&#125;,</div><div class="line">	ready () &#123;</div><div class="line">		console.log(&apos;ready&apos;);</div><div class="line">	&#125;,</div><div class="line">	attached () &#123;</div><div class="line">		console.log(&apos;attached&apos;);</div><div class="line">	&#125;,</div><div class="line">	detached () &#123;</div><div class="line">		console.log(&apos;detached&apos;);</div><div class="line">	&#125;,</div><div class="line">	beforeDestory () &#123;</div><div class="line">		console.log(&apos;beforeDestory&apos;);</div><div class="line">	&#125;,</div><div class="line">	destory () &#123;</div><div class="line">		console.log(&apos;destory&apos;);</div><div class="line">	&#125;,</div><div class="line">	components: &#123;</div><div class="line">	    mainHeader,</div><div class="line">	    list</div><div class="line">	&#125;,</div><div class="line">	//vuex</div><div class="line">	//store,</div><div class="line">	vuex: &#123;</div><div class="line">		actions: &#123;</div><div class="line"></div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	data () &#123;</div><div class="line">		// 数据对象</div><div class="line">      	return &#123;</div><div class="line"></div><div class="line">      	&#125;</div><div class="line">    &#125;,</div><div class="line">	props: &#123;</div><div class="line">		// 父组件数据</div><div class="line">	&#125;,</div><div class="line">	computed: &#123;</div><div class="line">		// 实例计算属性</div><div class="line">	&#125;,</div><div class="line">	watch: &#123;</div><div class="line">	    //&apos;page&apos;: function (val, oldVal) &#123;</div><div class="line">		//	console.log(&apos;new: %s, old: %s&apos;, val, oldVal)</div><div class="line">		//&#125;,</div><div class="line">	&#125;,</div><div class="line">	methods: &#123;</div><div class="line">	    // 可直接调用的函数</div><div class="line">	&#125;,</div><div class="line">	events: &#123;</div><div class="line"></div><div class="line">	&#125;,</div><div class="line">	// 路由生命周期</div><div class="line">	route: &#123;</div><div class="line">		activate (transition) &#123;</div><div class="line">			// 路由启用，比data先</div><div class="line">			console.log(&apos;activate&apos;);</div><div class="line">			transition.next();</div><div class="line">		&#125;,</div><div class="line"></div><div class="line">		data (transition) &#123;</div><div class="line">			// 数据处理，路由改变会触发</div><div class="line">			console.log(&apos;data&apos;);</div><div class="line">		&#125;,</div><div class="line"></div><div class="line">		deactivate (transition) &#123;</div><div class="line">			// 路由停用</div><div class="line">			console.log(&apos;deactivate&apos;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><img src="/images/page/vue/1.jpg" alt=""></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=1206879&auto=1&height=66"></iframe>



]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;做了个仿cnode的spa项目，用vue-cli搭了项目，用到了cnode的api和vue-router. &lt;a href=&quot;https://github.com/WangYang-Rex/learn-vue&quot;&gt;项目地址&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看了很多遍vue和vue-router的文档，这里记录下&lt;/p&gt;
    
    </summary>
    
    
      <category term="vue" scheme="http://html-js.site/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue学习-用vue-cli快速开发单页应用</title>
    <link href="http://html-js.site/2016/09/29/vue%E5%AD%A6%E4%B9%A0-%E7%94%A8vue-cli%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8/"/>
    <id>http://html-js.site/2016/09/29/vue学习-用vue-cli快速开发单页应用/</id>
    <published>2016-09-29T02:42:00.000Z</published>
    <updated>2016-10-13T06:24:30.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近正在学习vue，看了遍api和新手教程，打算动手做个单页面应用练手，在此记录一下</p>
</blockquote>
<p>开发一个单页面应用涉及的点很多，路由，模块打包，资源请求等，我们用<code>vue-cli</code>来帮助快速构建一个单页面应用，<code>vue-cli</code> 可以生成一套提前定义好的构建文件，和相应的文件。</p>
<h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p><code>vue-cli</code>有5个对应的项目结构。我们使用的是<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="external">vue-webpack-boilerplate</a>。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ npm install -g vue-cli</div><div class="line">$ vue init webpack my-project</div><div class="line">$ cd my-project</div><div class="line">$ npm install</div><div class="line">$ npm run dev</div></pre></td></tr></table></figure>
<p>执行上面命令后，我们将生成下面的文件结构，并开一个服务，你可以打开<a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a>看看。<br><img src="/images/page/vue-cli/1.png" alt=""></p>
<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p><img src="/images/page/vue-cli/2.png" alt=""><br>大致的项目结构，搭配vue-router、vuex.</p>
<blockquote>
<p>后面会用cnode的接口api来做个小项目练手，静待后续….</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近正在学习vue，看了遍api和新手教程，打算动手做个单页面应用练手，在此记录一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发一个单页面应用涉及的点很多，路由，模块打包，资源请求等，我们用&lt;code&gt;vue-cli&lt;/code&gt;来帮助快速构建一个单页面应用，&lt;code&gt;vue-cli&lt;/code&gt; 可以生成一套提前定义好的构建文件，和相应的文件。&lt;/p&gt;
&lt;h2 id=&quot;vue-cli&quot;&gt;&lt;a href=&quot;#vue-cli&quot; class=&quot;headerlink&quot; title=&quot;vue-cli&quot;&gt;&lt;/a&gt;vue-cli&lt;/h2&gt;&lt;p&gt;&lt;code&gt;vue-cli&lt;/code&gt;有5个对应的项目结构。我们使用的是&lt;a href=&quot;https://github.com/vuejs-templates/webpack&quot;&gt;vue-webpack-boilerplate&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 推送和删除远程标签</title>
    <link href="http://html-js.site/2016/09/18/Git-%E6%8E%A8%E9%80%81%E5%92%8C%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE/"/>
    <id>http://html-js.site/2016/09/18/Git-推送和删除远程标签/</id>
    <published>2016-09-18T06:34:41.000Z</published>
    <updated>2016-10-13T06:23:38.779Z</updated>
    
    <content type="html"><![CDATA[<p>事实上Git 的推送和删除远程标签命令是相同的，删除操作实际上就是推送空的源标签refs：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin 标签名</div></pre></td></tr></table></figure>
<p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin refs/tags/源标签名:refs/tags/目的标签名</div></pre></td></tr></table></figure></p>
<p>推送标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin 标签名</div></pre></td></tr></table></figure></p>
<p>删除本地标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -d 标签名</div></pre></td></tr></table></figure></p>
<p>删除远程标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git push origin :refs/tags/标签名</div><div class="line"></div><div class="line">git push origin :refs/tags/protobuf-2.5.0rc1</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其他本地操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#打标签</div><div class="line">git tag -a v1.1.4 -m &quot;tagging version 1.1.4&quot;</div><div class="line"></div><div class="line">#删除本地仓库标签</div><div class="line">git tag -d v1.1.4</div><div class="line"></div><div class="line">#列出标签</div><div class="line">git tag</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事实上Git 的推送和删除远程标签命令是相同的，删除操作实际上就是推送空的源标签refs：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git push origin 标签名&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;相当于&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git push origin refs/tags/源标签名:refs/tags/目的标签名&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;推送标签：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git push origin 标签名&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除本地标签：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git tag -d 标签名&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;删除远程标签：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;git push origin :refs/tags/标签名&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;git push origin :refs/tags/protobuf-2.5.0rc1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://html-js.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>fiddler之https抓包（windows）</title>
    <link href="http://html-js.site/2016/09/12/fiddler%E4%B9%8Bhttps%E6%8A%93%E5%8C%85%EF%BC%88windows%EF%BC%89/"/>
    <id>http://html-js.site/2016/09/12/fiddler之https抓包（windows）/</id>
    <published>2016-09-12T11:13:36.000Z</published>
    <updated>2016-10-13T06:23:20.178Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近因为fiddler升级，引发的一系列血案，花了整整2个小时才解决，必须记录一下</p>
</blockquote>
<h2 id="安装并设置"><a href="#安装并设置" class="headerlink" title="安装并设置"></a>安装并设置</h2><p>下载fiddler最新版本，官网地址：<a href="http://www.telerik.com/fiddler" target="_blank" rel="external">http://www.telerik.com/fiddler</a></p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>1.打开Fiddler，然后点击菜单栏的Tools &gt; Fiddler Options，打开“Fiddler Options”对话框。<br><img src="/images/page/fiddler/1.jpg" alt=""></p>
<p>2.在打开的对话框中切换到“HTTPS”选项卡<br><img src="/images/page/fiddler/2.jpg" alt=""></p>
<p>3.在打开的“HTTPS”选项卡中，勾选“Capture HTTPS  CONNECTs”和“Decrypt HTTPS traffic”前面的复选框，然后点击“OK”。<br><img src="/images/page/fiddler/3.jpg" alt=""></p>
<p>4.现在Fiddler就是在监听https的请求和响应了。<br><a id="more"></a></p>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="证书问题，需要重新安装"><a href="#证书问题，需要重新安装" class="headerlink" title="证书问题，需要重新安装"></a>证书问题，需要重新安装</h3><ol>
<li>导出证书：fiddler-&gt;tools-&gt;fiddler options-&gt;https tab-&gt;action-&gt;Export Root Certificate to Desktop</li>
<li>安装证书：</li>
</ol>
<ul>
<li>IE：Internet选项-&gt;内容 tab-&gt;证书-&gt;删除所有颁发者为DO_NOT_TRUST_FiddlerRoot-&gt;导入证书</li>
<li>Chrome:设置-&gt;高级设置-&gt;管理证书-&gt;删除所有颁发者为DO_NOT_TRUST_FiddlerRoot-&gt;导入证书<br><img src="/images/page/fiddler/4.jpg" alt=""></li>
</ul>
<h3 id="证书、设置都正确了发现还是有问题，请重启FIDDLER和浏览器，fiddler请用管理员权限运行，还不行就重启电脑"><a href="#证书、设置都正确了发现还是有问题，请重启FIDDLER和浏览器，fiddler请用管理员权限运行，还不行就重启电脑" class="headerlink" title="证书、设置都正确了发现还是有问题，请重启FIDDLER和浏览器，fiddler请用管理员权限运行，还不行就重启电脑"></a>证书、设置都正确了发现还是有问题，请重启FIDDLER和浏览器，fiddler请用管理员权限运行，还不行就重启电脑</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近因为fiddler升级，引发的一系列血案，花了整整2个小时才解决，必须记录一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装并设置&quot;&gt;&lt;a href=&quot;#安装并设置&quot; class=&quot;headerlink&quot; title=&quot;安装并设置&quot;&gt;&lt;/a&gt;安装并设置&lt;/h2&gt;&lt;p&gt;下载fiddler最新版本，官网地址：&lt;a href=&quot;http://www.telerik.com/fiddler&quot;&gt;http://www.telerik.com/fiddler&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置&quot;&gt;&lt;a href=&quot;#设置&quot; class=&quot;headerlink&quot; title=&quot;设置&quot;&gt;&lt;/a&gt;设置&lt;/h3&gt;&lt;p&gt;1.打开Fiddler，然后点击菜单栏的Tools &amp;gt; Fiddler Options，打开“Fiddler Options”对话框。&lt;br&gt;&lt;img src=&quot;/images/page/fiddler/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2.在打开的对话框中切换到“HTTPS”选项卡&lt;br&gt;&lt;img src=&quot;/images/page/fiddler/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.在打开的“HTTPS”选项卡中，勾选“Capture HTTPS  CONNECTs”和“Decrypt HTTPS traffic”前面的复选框，然后点击“OK”。&lt;br&gt;&lt;img src=&quot;/images/page/fiddler/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;4.现在Fiddler就是在监听https的请求和响应了。&lt;br&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://html-js.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript核心(转)</title>
    <link href="http://html-js.site/2016/08/24/JavaScript%E6%A0%B8%E5%BF%83-%E8%BD%AC/"/>
    <id>http://html-js.site/2016/08/24/JavaScript核心-转/</id>
    <published>2016-08-24T07:00:13.000Z</published>
    <updated>2016-10-13T06:24:55.878Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ol>
<li><a href="#对象">对象</a></li>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#执行上下文堆栈">执行上下文堆栈</a></li>
<li><a href="#执行上下文">执行上下文</a></li>
<li><a href="#变量对象">变量对象</a></li>
<li><a href="#活动对象">活动对象</a></li>
<li><a href="#作用域链">作用域链</a></li>
<li><a href="#闭包">闭包</a></li>
<li><a href="#this">this</a></li>
</ol>
</blockquote>
<p>这篇文章是“深入理解ECMA-262-3”的一个总览和概要，每个章节都有对应的详细的链接。</p>
<a id="more"></a>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>ECMAScript作为一个高度抽象的面向对象语言，是通过对象来做数据传递的。当然也有一些基本数据类型，但通常也会被转换为对象来处理。</p>
<blockquote>
<p>一个对象就是一组属性的集合，并拥有一个独立的prototype对象，这个prototype可以是个对象也可以是个null</p>
</blockquote>
<p>举个简单例子，对象的 prototype 是以内部的<code>[[Prototype]]</code>属性来引用的。但是我们在图表中使用 <code>__&lt;internal-property&gt;__</code>下划线标记来代替双括号，尤其是prototype对象：<code>__proto__</code></p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>于是就有这个结构：两个显式的自身属性和一个隐式属性<strong>proto</strong>,这个隐式属性就是对 foo 原型对象的引用<br><img src="/images/page/jsCore/1.png" alt=""></p>
<p>为什么需要这些prototype？那我们就以原型链 (prototype chain) 的概念来回答这个问题。</p>
<p>##　原型链<br>原型对象也是简单对象，并且也有自己的原型。如果一个原型对象的原型有一个非空(not null)的引用，那么以此类推，这就叫做原型链。</p>
<blockquote>
<p>原型链是一个可以实现继承和对象共享的有限对象链</p>
</blockquote>
<p>假设我们有两个对象，其中只有一小部分不同，其他绝大部分相同。很明显，对于一个有良好设计的系统，我们会复用相似的函数和代码。在基于类的系统中，代码复用风格叫做类继承<code>class-based inheritance</code> —— 把一组相似的功能放入Class A，然后Class B和C继承Class A，并又有独自的小改动。</p>
<p>ECMAScript中没有类的概念。但是代码复用的风格并没有多大的不同（尽管从某些方面来说这种方式比累积成要更灵活）并且通过原型链来实现。这种集成被称作委托继承<code>(delegation based inheritance)</code>(或者用ECMAScript的范式来说就叫做原型继承)。</p>
<p>类似子上面例子中的类A、B、C，在ECMAScript中创建对象a、b、c。那么在a中存储b、c通用的部分，b、c只存储自己额外属性和方法。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">  x: 10,</div><div class="line">  calculate: function (z) &#123;</div><div class="line">    return this.x + this.y + z;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var b = &#123;</div><div class="line">  y: 20,</div><div class="line">  __proto__: a</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var c = &#123;</div><div class="line">  y: 30,</div><div class="line">  __proto__: a</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// call the inherited method</div><div class="line">b.calculate(30); // 60</div><div class="line">c.calculate(40); // 80</div></pre></td></tr></table></figure></p>
<p>足够简单，对吧。b和c调用了a中的calculate方法，这就叫做原型链继承。</p>
<p>规则很简单：一个属性或一个方法没有在对象自身中找到（即对象自身没有那个属性），然后就尝试在原型中查找这个属性或者方法，如果原型中没有找到，就会继续查找原型的原型，以此来遍历整个原型链（当然这在基于类继承中是一样的，调用继承方法时会遍历真个Class链）第一个被查找到的同名属性/方法会被使用。因此，一个被查找到的属性叫作继承属性。如果在遍历了整个原型链之后还是没有查找到这个属性的话，返回<code>undefined</code>值。</p>
<p>规则很简单：如果一个属性或者一个方法在对象自身中无法找到（也就是对象自身没有一个那样的属性），然后它会尝试在原型链中寻找这个属性/方法。如果这个属性在原型中没有查找到，那么将会查找这个原型的原型，以此类推，遍历整个原型链（当然这在类继承中也是一样的，当解析一个继承的方法的时候－我们遍历class链（ class chain））。第一个被查找到的同名属性/方法会被使用。因此，一个被查找到的属性叫作继承属性。如果在遍历了整个原型链之后还是没有查找到这个属性的话，返回<code>undefined</code>值。</p>
<p>注意，继承方法中所使用的<code>this</code>的值被设置为原始对象，而并不是在其中查找到这个方法的（原型）对象。也就是，在上面的例子中<code>this.y</code>取的是<code>b</code>和<code>c</code>中的值，而不是<code>a</code>中的值。但是，<code>this.x</code>是取的是<code>a</code>中的值，并且又一次通过原型链机制完成。</p>
<p>如果没有明确为一个对象指定原型，那么它将会使用<code>__proto__</code>的默认值－<code>Object.prototype</code>。<code>Object.prototype</code>对象自身也有一个<code>__proto__</code>属性，这是原型链的终点并且值为<code>null</code>。</p>
<p>下一张图展示了对象<code>a</code>，<code>b</code>，<code>c</code>之间的继承层级：<br><img src="/images/page/jsCore/2.png" alt=""></p>
<p>注意：<br><br>ES5标准化了一个实现原型继承的可选方法，即使用<code>Object.create</code>函数：<br><code>var b = Object.create(a, {y: {value: 20}});
var c = Object.create(a, {y: {value: 30}});</code><br>你可以在<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-1-properties-and-property-descriptors/#new-api-methods" target="_blank" rel="external">对应的章节</a>获取到更多关于ES5新API的信息。<br>ES6标准化了 <code>__proto__</code>属性，并且可以在对象初始化的时候使用它。</p>
<p>通常情况下需要对象拥有相同或者相似的状态结构（也就是相同的属性集合），赋以不同的状态值。在这个情况下我们可能需要使用构造函数(constructor function)，其以指定的模式来创造对象。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>除了以指定模式创建对象之外，构造函数也做了另一个有用的事情－它自动地为新创建的对象设置一个原型对象。这个原型对象存储在<code>ConstructorFunction.prototype</code>属性中。</p>
<p>换句话说，我们可以使用构造函数来重写上一个拥有对象b和对象c的例子。因此，对象a（一个原型对象）的角色由<code>Foo.prototype</code>来扮演：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">// a constructor function</div><div class="line">function Foo(y) &#123;</div><div class="line">  // which may create objects</div><div class="line">  // by specified pattern: they have after</div><div class="line">  // creation own &quot;y&quot; property</div><div class="line">  this.y = y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// also &quot;Foo.prototype&quot; stores reference</div><div class="line">// to the prototype of newly created objects,</div><div class="line">// so we may use it to define shared/inherited</div><div class="line">// properties or methods, so the same as in</div><div class="line">// previous example we have:</div><div class="line"></div><div class="line">// inherited property &quot;x&quot;</div><div class="line">Foo.prototype.x = 10;</div><div class="line"></div><div class="line">// and inherited method &quot;calculate&quot;</div><div class="line">Foo.prototype.calculate = function (z) &#123;</div><div class="line">  return this.x + this.y + z;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// now create our &quot;b&quot; and &quot;c&quot;</div><div class="line">// objects using &quot;pattern&quot; Foo</div><div class="line">var b = new Foo(20);</div><div class="line">var c = new Foo(30);</div><div class="line"></div><div class="line">// call the inherited method</div><div class="line">b.calculate(30); // 60</div><div class="line">c.calculate(40); // 80</div><div class="line"></div><div class="line">// let&apos;s show that we reference</div><div class="line">// properties we expect</div><div class="line"></div><div class="line">console.log(</div><div class="line"></div><div class="line">  b.__proto__ === Foo.prototype, // true</div><div class="line">  c.__proto__ === Foo.prototype, // true</div><div class="line"></div><div class="line">  // also &quot;Foo.prototype&quot; automatically creates</div><div class="line">  // a special property &quot;constructor&quot;, which is a</div><div class="line">  // reference to the constructor function itself;</div><div class="line">  // instances &quot;b&quot; and &quot;c&quot; may found it via</div><div class="line">  // delegation and use to check their constructor</div><div class="line"></div><div class="line">  b.constructor === Foo, // true</div><div class="line">  c.constructor === Foo, // true</div><div class="line">  Foo.prototype.constructor === Foo // true</div><div class="line"></div><div class="line">  b.calculate === b.__proto__.calculate, // true</div><div class="line">  b.__proto__.calculate === Foo.prototype.calculate // true</div><div class="line"></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>这个代码可以表示为如下关系：<br><img src="/images/page/jsCore/3.png" alt=""><br>这张图又一次说明了每个对象都有一个原型。构造函数<code>Foo</code>也有自己的<code>__proto__</code>，值为<code>Function.prototype</code>，<code>Function.prototype</code>也通过其<code>__proto__</code>属性关联到<code>Object.prototype</code>。因此，重申一下，<code>Foo.prototype</code>就是<code>Foo</code>的一个明确的属性，指向对象<code>b</code>和对象<code>c</code>的原型。</p>
<p>正式来说，如果思考一下分类的概念（并且我们已经对<code>Foo</code>进行了分类），那么构造函数和原型对象合在一起可以叫作「类」。实际上，举个例子，Python的第一级（first-class）动态类（dynamic classes）显然是以同样的<code>属性/方法</code>处理方案来实现的。从这个角度来说，Python中的类就是ECMAScript使用的委托继承的一个语法糖。</p>
<p>注意: 在ES6中「类」的概念被标准化了，并且实际上以一种构建在构造函数上面的语法糖来实现，就像上面描述的一样。从这个角度来看原型链成为了类继承的一种具体实现方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// ES6</div><div class="line">class Foo &#123;</div><div class="line">  constructor(name) &#123;</div><div class="line">    this._name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  getName() &#123;</div><div class="line">    return this._name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Bar extends Foo &#123;</div><div class="line">  getName() &#123;</div><div class="line">    return super.getName() + &apos; Doe&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var bar = new Bar(&apos;John&apos;);</div><div class="line">console.log(bar.getName()); // John Doe</div></pre></td></tr></table></figure></p>
<p>有关这个主题的完整、详细的解释可以在ES3系列的第七章找到。分为两个部分：<a href="&quot;http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/">7.1 面向对象.基本理论</a>，在那里你将会找到对各种面向对象范例、风格的描述以及它们和ECMAScript之间的对比，然后在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/" target="_blank" rel="external">7.2 面向对象.ECMAScript实现</a>，是对ECMAScript中面向对象的介绍。</p>
<p>现在，在我们知道了对象的基础之后，让我们看看运行时程序的执行（runtime program execution）在ECMAScript中是如何实现的。这叫作执行上下文栈（execution context stack），其中的每个元素也可以抽象成为一个对象。是的，ECMAScript几乎在任何地方都和对象的概念打交道;)</p>
<h2 id="执行上下文堆栈"><a href="#执行上下文堆栈" class="headerlink" title="执行上下文堆栈"></a>执行上下文堆栈</h2><p>这里有三种类型的ECMAScript代码：全局代码、函数代码和eval代码。每个代码是在其执行上下文（execution context）中被求值的。这里只有一个全局上下文，可能有多个函数执行上下文以及eval执行上下文。对一个函数的每次调用，会进入到函数执行上下文中，并对函数代码类型进行求值。每次对<code>eval</code>函数进行调用，会进入eval执行上下文并对其代码进行求值。</p>
<p>注意，一个函数可能会创建无数的上下文，因为对函数的每次调用（即使这个函数递归的调用自己）都会生成一个具有新状态的上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo(bar) &#123;&#125;</div><div class="line"></div><div class="line">// call the same function,</div><div class="line">// generate three different</div><div class="line">// contexts in each call, with</div><div class="line">// different context state (e.g. value</div><div class="line">// of the &quot;bar&quot; argument)</div><div class="line"></div><div class="line">foo(10);</div><div class="line">foo(20);</div><div class="line">foo(30);</div></pre></td></tr></table></figure></p>
<p>一个执行上下文可能会触发另一个上下文，比如，一个函数调用另一个函数（或者在全局上下文中调用一个全局函数），等等。从逻辑上来说，这是以栈的形式实现的，它叫作执行上下文栈。</p>
<p>一个触发其他上下文的上下文叫作caller。被触发的上下文叫作callee。callee在同一时间可能是一些其他callee的caller（比如，一个在全局上下文中被调用的函数，之后调用了一些内部函数）。</p>
<p>当一个caller触发（调用）了一个callee，这个caller会暂缓自身的执行，然后把控制权传递给callee。这个callee被push到栈中，并成为一个运行中（活动的）执行上下文。在callee的上下文结束后，它会把控制权返回给caller，然后caller的上下文继续执行（它可能触发其他上下文）直到它结束，以此类推。callee可能简单的返回或者由于异常而退出。一个抛出的但是没有被捕获的异常可能退出（从栈中pop）一个或者多个上下文。</p>
<p>换句话说，所有ECMAScript<em>程序的运行时可以用执行上下文（EC）栈来表示，栈顶是当前活跃</em>(active)上下文：<br><img src="/images/page/jsCore/4.png" alt=""></p>
<p>当程序开始的时候它会进入全局执行上下文，此上下文位于栈底并且是栈中的第一个元素。然后全局代码进行一些初始化，创建需要的对象和函数。在全局上下文的执行过程中，它的代码可能触发其他（已经创建完成的）函数，这些函数将会进入它们自己的执行上下文，向栈中push新的元素，以此类推。当初始化完成之后，运行时系统（runtime system）就会等待一些事件（比如，用户鼠标点击），这些事件将会触发一些函数，从而进入新的执行上下文中。</p>
<p>在下个图中，拥有一些函数上下文EC1和全局上下文<code>Global EC</code>，当<code>EC1</code>进入和退出全局上下文的时候下面的栈将会发生变化：<br><img src="/images/page/jsCore/5.png" alt=""></p>
<p>这就是ECMAScript的运行时系统如何真正地管理代码执行的。</p>
<p>更多有关ECMAScript中执行上下文的信息可以在对应的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">第一章 执行上下文</a>中获取。</p>
<p>像我们所说的，栈中的每个执行上下文都可以用一个对象来表示。让我们来看看它的结构以及一个上下文到底需要什么状态（什么属性）来执行它的代码。</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>一个执行上下文可以抽象的表示为一个简单的对象。每一个执行上下文拥有一些属性（可以叫作上下文状态）用来跟踪和它相关的代码的执行过程。在下图中展示了一个上下文的结构：</p>
<p><img src="/images/page/jsCore/5.png" alt=""></p>
<p>除了这三个必需的属性（一个变量对象（variable objec），一个this值以及一个作用域链（scope chain））之外，执行上下文可以拥有任何附加的状态，这取决于实现。</p>
<p>让我们详细看看上下文中的这些重要的属性。</p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><blockquote>
<p>变量对象是与执行上下文相关的数据作用域。它是一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明。</p>
</blockquote>
<p>注意，函数表达式（与函数声明相对）不包含在变量对象之中。</p>
<p>变量对象是一个抽象概念。对于不同的上下文类型，在物理上，是使用不同的对象。比如，在全局上下文中变量对象就是全局对象本身（这就是为什么我们可以通过全局对象的属性名来关联全局变量）。</p>
<p>让我们在全局执行上下文中考虑下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var foo = 10;</div><div class="line"></div><div class="line">function bar() &#123;&#125; // function declaration, FD</div><div class="line">(function baz() &#123;&#125;); // function expression, FE</div><div class="line"></div><div class="line">console.log(</div><div class="line">  this.foo == foo, // true</div><div class="line">  window.bar == bar // true</div><div class="line">);</div><div class="line"></div><div class="line">console.log(baz); // ReferenceError, &quot;baz&quot; is not defined</div></pre></td></tr></table></figure></p>
<p>之后，全局上下文的变量对象（variable objec，简称VO）将会拥有如下属性：<br><img src="/images/page/jsCore/7.png" alt=""></p>
<p>再看一遍，函数<code>baz</code>是一个函数表达式，没有被包含在变量对象之中。这就是为什么当我们想要在函数自身之外访问它的时候会出现<code>ReferenceError</code>。</p>
<p>注意，与其他语言（比如C/C++）相比，在ECMAScript中只有函数可以创建一个新的作用域。在函数作用域中所定义的变量和内部函数在函数外边是不能直接访问到的，而且并不会污染全局变量对象。</p>
<p>使用<code>eval</code>我们也会进入一个新的（eval类型）执行上下文。无论如何，<code>eval</code>使用全局的变量对象或者使用caller（比如<code>eval</code>被调用时所在的函数）的变量对象。</p>
<p>那么函数和它的变量对象是怎么样的？在函数上下文中，变量对象是以活动对象（activation object）来表示的。</p>
<h2 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h2><p>当一个函数被caller所触发（被调用），一个特殊的对象，叫作活动对象（activation object）将会被创建。这个对象中包含形参和那个特殊的<code>arguments</code>对象（是对形参的一个映射，但是值是通过索引来获取）。活动对象之后会做为函数上下文的变量对象来使用。</p>
<p>换句话说，函数的变量对象也是一个同样简单的变量对象，但是除了变量和函数声明之外，它还存储了形参和<code>arguments</code>对象，并叫作活动对象。</p>
<p>考虑如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo(x, y) &#123;</div><div class="line">  var z = 30;</div><div class="line">  function bar() &#123;&#125; // FD</div><div class="line">  (function baz() &#123;&#125;); // FE</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(10, 20);</div></pre></td></tr></table></figure></p>
<p>我们看下函数<code>foo</code>的上下文中的活动对象（activation object，简称AO）：<br><img src="/images/page/jsCore/8.png" alt=""></p>
<p>并且函数表达式<code>baz</code>还是没有被包含在变量/活动对象中。</p>
<p>关于这个主题所有细节方面（像变量和函数声明的提升问题（hoisting））的完整描述可以在同名的章节<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">第二章 变量对象</a>中找到。</p>
<p>注意，在ES5中变量对象和活动对象被并入了词法环境模型（lexical environments model），详细的描述可以在<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" target="_blank" rel="external">对应的章节</a>找到。</p>
<p>然后我们向下一个部分前进。众所周知，在ECMAScript中我们可以使用<em>内部函数</em>，然后在这些内部函数我们可以引用父函数的变量或者全局上下文中的变量。当我们把变量对象命名为上下文的作用域对象，与上面讨论的原型链相似，这里有一个叫作<em>作用域链</em>的东西。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote>
<p>作用域链是一个对象列表，上下文代码中出现的标识符在这个列表中进行查找。</p>
</blockquote>
<p>这个规则还是与原型链同样简单以及相似：如果一个变量在函数自身的作用域（在自身的变量/活动对象）中没有找到，那么将会查找它父函数（外层函数）的变量对象，以此类推。</p>
<p>就上下文而言，标识符指的是：变量<em>名称</em>，函数声明，形参，等等。当一个函数在其代码中引用一个不是局部变量（或者局部函数或者一个形参）的标识符，那么这个标识符就叫作<em>自由变量</em>。搜索这些<em>自由变量</em>(free variables)正好就要用到作用域链。</p>
<p>在通常情况下，作用域链是一个包含所有父（函数）变量对象_加上（在作用域链头部的）函数自身变量/活动对象的一个列表。但是，这个作用域链也可以包含任何其他对象，比如，在上下文执行过程中动态加入到作用域链中的对象－像_with对象或者特殊的catch从句（catch-clauses）对象。</p>
<p>当解析（查找）一个标识符的时候，会从作用域链中的活动对象开始查找，然后（如果这个标识符在函数自身的活动对象中没有被查找到）向作用域链的上一层查找－重复这个过程，就和原型链一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line"></div><div class="line">(function foo() &#123;</div><div class="line">  var y = 20;</div><div class="line">  (function bar() &#123;</div><div class="line">    var z = 30;</div><div class="line">    // &quot;x&quot; and &quot;y&quot; are &quot;free variables&quot;</div><div class="line">    // and are found in the next (after</div><div class="line">    // bar&apos;s activation object) object</div><div class="line">    // of the bar&apos;s scope chain</div><div class="line">    console.log(x + y + z);</div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>我们可以假设通过隐式的<code>__parent__</code>属性来和作用域链对象进行关联，这个属性指向作用域链中的下一个对象。这个方案可能在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#feature-of-implementations-property-__parent__" target="_blank" rel="external">真实的Rhino代码</a>中经过了测试，并且这个技术很明确得被用于ES5的词法环境中（在那里被叫作outer连接）。作用域链的另一个表现方式可以是一个简单的数组。利用<code>__parent__</code>概念，我们可以用下面的图来表现上面的例子（并且父变量对象存储在函数的<code>[[Scope]]</code>属性中）：<br><img src="/images/page/jsCore/9.png" alt=""></p>
<p>在代码执行过程中，作用域链可以通过使用<code>with</code>语句和<code>catch</code>从句对象来增强。并且由于这些对象是简单的对象，它们可以拥有原型（和原型链）。这个事实导致作用域链查找变为两个维度：（1）首先是作用域链连接，然后（2）在每个作用域链连接上－深入作用域链连接的原型链（如果此连接拥有原型）。</p>
<p>对于这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = 10;</div><div class="line"></div><div class="line">var w = 20;</div><div class="line">var y = 30;</div><div class="line"></div><div class="line">// in SpiderMonkey global object</div><div class="line">// i.e. variable object of the global</div><div class="line">// context inherits from &quot;Object.prototype&quot;,</div><div class="line">// so we may refer &quot;not defined global</div><div class="line">// variable x&quot;, which is found in</div><div class="line">// the prototype chain</div><div class="line"></div><div class="line">console.log(x); // 10</div><div class="line"></div><div class="line">(function foo() &#123;</div><div class="line"></div><div class="line">  // &quot;foo&quot; local variables</div><div class="line">  var w = 40;</div><div class="line">  var x = 100;</div><div class="line"></div><div class="line">  // &quot;x&quot; is found in the</div><div class="line">  // &quot;Object.prototype&quot;, because</div><div class="line">  // &#123;z: 50&#125; inherits from it</div><div class="line"></div><div class="line">  with (&#123;z: 50&#125;) &#123;</div><div class="line">    console.log(w, x, y , z); // 40, 10, 30, 50</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // after &quot;with&quot; object is removed</div><div class="line">  // from the scope chain, &quot;x&quot; is</div><div class="line">  // again found in the AO of &quot;foo&quot; context;</div><div class="line">  // variable &quot;w&quot; is also local</div><div class="line">  console.log(x, w); // 100, 40</div><div class="line"></div><div class="line">  // and that&apos;s how we may refer</div><div class="line">  // shadowed global &quot;w&quot; variable in</div><div class="line">  // the browser host environment</div><div class="line">  console.log(window.w); // 20</div><div class="line"></div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>我们可以给出如下的结构（确切的说，在我们查找<code>__parent__</code>连接之前，首先查找<code>__proto__</code>链）：<br><img src="/images/page/jsCore/10.png" alt=""></p>
<p>注意，不是在所有的实现中全局对象都是继承自<code>Object.prototype</code>。上图中描述的行为（从全局上下文中引用「未定义」的变量<code>x</code>）可以在诸如SpiderMonkey引擎中进行测试。</p>
<p>由于所有父变量对象都存在，所以在内部函数中获取父函数中的数据没有什么特别－我们就是遍历作用域链去解析（搜寻）需要的变量。就像我们上边提及的，在一个上下文结束之后，它所有的状态和它自身都会被销毁。在同一时间父函数可能会返回一个内部函数。而且，这个返回的函数之后可能在另一个上下文中被调用。如果自由变量的上下文已经「消失」了，那么这样的调用将会发生什么？通常来说，有一个概念可以帮助我们解决这个问题，叫作（词法）闭包，其在ECMAScript中就是和作用域链的概念紧密相关的。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在ECMAScript中，函数是第一级（first-class）对象。这个术语意味着函数可以做为参数传递给其他函数（在那种情况下，这些参数叫作「函数类型参数」（funargs，是”functional arguments”的简称））。接收「函数类型参数」的函数叫作高阶函数或者，贴近数学一些，叫作高阶操作符。同样函数也可以从其他函数中返回。返回其他函数的函数叫作以函数为值（function valued）的函数（或者叫作拥有函数类值的函数（functions with functional value））。</p>
<p>这有两个在概念上与「函数类型参数（funargs）」和「函数类型值（functional　values）」相关的问题。并且这两个子问题在”Funarg problem”（或者叫作”functional argument”问题）中很普遍。为了解决整个”funarg problem”，闭包（closure）的概念被创造了出来。我们详细的描述一下这两个子问题（我们将会看到这两个问题在ECMAScript中都是使用图中所提到的函数的<code>[[Scope]]</code>属性来解决的）。</p>
<p>「funarg问题」的第一个子问题是「向上funarg问题」（upward funarg problem）。它会在当一个函数从另一个函数向上返回（到外层）并且使用上面所提到的自由变量的时候出现。为了在即使父函数上下文结束的情况下也能访问其中的变量，内部函数在被创建的时候会在它的<code>[[Scope]]</code>属性中保存父函数的作用域链。所以当函数被调用的时候，它上下文的作用域链会被格式化成活动对象与<code>[[Scope]]</code>属性的和（实际上就是我们刚刚在上图中所看到的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope chain = Activation object + [[Scope]]</div></pre></td></tr></table></figure>
<p>再次注意这个关键点－确切的说在创建时刻－函数会保存父函数的作用域链，因为确切的说这个保存下来的作用域链将会在未来的函数调用时用来查找变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  var x = 10;</div><div class="line">  return function bar() &#123;</div><div class="line">    console.log(x);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// &quot;foo&quot; returns also a function</div><div class="line">// and this returned function uses</div><div class="line">// free variable &quot;x&quot;</div><div class="line"></div><div class="line">var returnedFunction = foo();</div><div class="line"></div><div class="line">// global variable &quot;x&quot;</div><div class="line">var x = 20;</div><div class="line"></div><div class="line">// execution of the returned function</div><div class="line"></div><div class="line">returnedFunction(); // 10, but not 20</div></pre></td></tr></table></figure></p>
<p>这个类型的作用域叫作静态（或者词法）作用域。我们看到变量x在返回的bar函数的[[Scope]]属性中被找到。通常来说，也存在动态作用域，那么上面例子中的变量x将会被解析成20，而不是10。但是，动态作用域在ECMAScript中没有被使用。</p>
<p>「funarg问题」的第二个部分是「向下funarg问题」。这种情况下可能会存在一个父上下文，但是在解析标识符的时候可能会模糊不清。问题是：标识符该使用哪个作用域的值－以静态的方式存储在函数创建时刻的还是在执行过程中以动态方式生成的（比如caller的作用域）？为了避免这种模棱两可的情况并形成闭包，静态作用域被采用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// global &quot;x&quot;</div><div class="line">var x = 10;</div><div class="line"></div><div class="line">// global function</div><div class="line">function foo() &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;</div><div class="line"></div><div class="line">(function (funArg) &#123;</div><div class="line"></div><div class="line">  // local &quot;x&quot;</div><div class="line">  var x = 20;</div><div class="line"></div><div class="line">  // there is no ambiguity,</div><div class="line">  // because we use global &quot;x&quot;,</div><div class="line">  // which was statically saved in</div><div class="line">  // [[Scope]] of the &quot;foo&quot; function,</div><div class="line">  // but not the &quot;x&quot; of the caller&apos;s scope,</div><div class="line">  // which activates the &quot;funArg&quot;</div><div class="line"></div><div class="line">  funArg(); // 10, but not 20</div><div class="line"></div><div class="line">&#125;)(foo); // pass &quot;down&quot; foo as a &quot;funarg&quot;</div></pre></td></tr></table></figure></p>
<p>我们可以断定静态作用域是一门语言拥有闭包的必需条件。但是，一些语言可能会同时提供动态和静态作用域，允许程序员做选择－什么应该包含（closure）在内和什么不应包含在内。由于在ECMAScript中只使用了静态作用域（比如我们对于<code>funarg问题</code>的两个子问题都有解决方案），所以结论是：ECMAScript完全支持闭包，技术上是通过函数的<code>[[Scope]]</code>属性实现的。现在我们可以给闭包下一个准确的定义：</p>
<blockquote>
<p>闭包是一个代码块（在ECMAScript是一个函数）和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。</p>
</blockquote>
<p>注意，由于每个（标准的）函数都在创建的时候保存了<code>[[Scope]]</code>，所以理论上来讲，ECMAScript中的所有函数都是闭包。</p>
<p>另一个需要注意的重要事情是，多个函数可能拥有相同的父作用域（这是很常见的情况，比如当我们拥有两个内部/全局函数的时候）。在这种情况下，<code>[[Scope]]</code>属性中存储的变量是在拥有相同父作用域链的所有函数之间共享的。一个闭包对变量进行的修改会体现在另一个闭包对这些变量的读取上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function baz() &#123;</div><div class="line">  var x = 1;</div><div class="line">  return &#123;</div><div class="line">    foo: function foo() &#123; return ++x; &#125;,</div><div class="line">    bar: function bar() &#123; return --x; &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var closures = baz();</div><div class="line"></div><div class="line">console.log(</div><div class="line">  closures.foo(), // 2</div><div class="line">  closures.bar()  // 1</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>以上代码可以通过下图进行说明：<br><img src="/images/page/jsCore/11.png" alt=""></p>
<p>确切来说这个特性在循环中创建多个函数的时候会使人非常困惑。在创建的函数中使用循环计数器的时候，一些程序员经常会得到非预期的结果，所有函数中的计数器都是同样的值。现在是到了该揭开谜底的时候了－因为所有这些函数拥有同一个<code>[[Scope]]</code>，这个属性中的循环计数器的值是最后一次所赋的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line"></div><div class="line">for (var k = 0; k &amp;lt; 3; k++) &#123;</div><div class="line">  data[k] = function () &#123;</div><div class="line">    alert(k);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">data[0](); // 3, but not 0</div><div class="line">data[1](); // 3, but not 1</div><div class="line">data[2](); // 3, but not 2</div></pre></td></tr></table></figure></p>
<p>这里有几种技术可以解决这个问题。其中一种是在作用域链中提供一个额外的对象－比如，使用额外函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line"></div><div class="line">for (var k = 0; k &amp;lt; 3; k++) &#123;</div><div class="line">  data[k] = (function (x) &#123;</div><div class="line">    return function () &#123;</div><div class="line">      alert(x);</div><div class="line">    &#125;;</div><div class="line">  &#125;)(k); // pass &quot;k&quot; value</div><div class="line">&#125;</div><div class="line"></div><div class="line">// now it is correct</div><div class="line">data[0](); // 0</div><div class="line">data[1](); // 1</div><div class="line">data[2](); // 2</div></pre></td></tr></table></figure></p>
<p>对闭包理论和它们的实际应用感兴趣的同学可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="external">第六章 闭包</a>中找到额外的信息。如果想获取更多关于作用域链的信息，可以看一下同名的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="external">第四章 作用域链</a>。</p>
<p>然后我们移动到下个部分，考虑一下执行上下文的最后一个属性。这就是关于<code>this</code>值的概念。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote>
<p>this是一个与执行上下文相关的特殊对象。因此，它可以叫作上下文对象（也就是用来指明执行上下文是在哪个上下文中被触发的对象）。</p>
</blockquote>
<p>任何对象都可以做为上下文中的<code>this</code>的值。我想再一次澄清，在一些对ECMAScript执行上下文和部分<code>this</code>的描述中的所产生误解。<code>this</code>经常被错误的描述成是变量对象的一个属性。这类错误存在于比如像<a href="http://yuiblog.com/assets/High_Perf_JavaScr_Ch2.pdf" target="_blank" rel="external">这本书</a>中（即<br>使如此，这本书的相关章节还是十分不错的）。再重复一次：</p>
<blockquote>
<p>this是执行上下文的一个属性，而不是变量对象的一个属性</p>
</blockquote>
<p>这个特性非常重要，因为与变量相反，<code>this</code>从不会参与到标识符解析过程。换句话说，在代码中当访问<code>this</code>的时候，它的值是直接从执行上下文中获取的，并不需要任何作用域链查找。<code>this</code>的值只在进入上下文的时候进行一次确定。</p>
<p>顺便说一下，与<code>ECMAScript</code>相反，比如，Python的方法都会拥有一个被当作简单变量的<code>self</code>参数，这个变量的值在各个方法中是相同的的并且在执行过程中可以被更改成其他值。在ECMAScript中，给<code>this</code>赋一个新值是不可能的，因为，再重复一遍，它不是一个变量并且不存在于变量对象中。</p>
<p>在全局上下文中，<code>this</code>就等于全局对象本身（这意味着，这里的this等于变量对象）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line"></div><div class="line">console.log(</div><div class="line">  x, // 10</div><div class="line">  this.x, // 10</div><div class="line">  window.x // 10</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>在函数上下文的情况下，对函数的每次调用，其中的<code>this</code>值可能是不同的。这个<code>this</code>值是通过函数调用表达式（也就是函数被调用的方式）的形式由caller所提供的。举个例子，下面的函数<code>foo</code>是一个<code>callee</code>，在全局上下文中被调用，此上下文为caller。让我们通过例子看一下，对于一个代码相同的函数，<code>this</code>值是如何在不同的调用中（函数触发的不同方式），由caller给出不同的结果的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// the code of the &quot;foo&quot; function</div><div class="line">// never changes, but the &quot;this&quot; value</div><div class="line">// differs in every activation</div><div class="line"></div><div class="line">function foo() &#123;</div><div class="line">  alert(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// caller activates &quot;foo&quot; (callee) and</div><div class="line">// provides &quot;this&quot; for the callee</div><div class="line"></div><div class="line">foo(); // global object</div><div class="line">foo.prototype.constructor(); // foo.prototype</div><div class="line"></div><div class="line">var bar = &#123;</div><div class="line">  baz: foo</div><div class="line">&#125;;</div><div class="line"></div><div class="line">bar.baz(); // bar</div><div class="line"></div><div class="line">(bar.baz)(); // also bar</div><div class="line">(bar.baz = bar.baz)(); // but here is global object</div><div class="line">(bar.baz, bar.baz)(); // also global object</div><div class="line">(false || bar.baz)(); // also global object</div><div class="line"></div><div class="line">var otherFoo = bar.baz;</div><div class="line">otherFoo(); // again global object</div></pre></td></tr></table></figure></p>
<p>为了深入理解<code>this</code>为什么（并且更本质一些－如何）在每个函数调用中可能会发生变化，你可以阅读<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="external">第三章 This</a>。在那里，上面所提到的情况都会有详细的讨论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#对象&quot;&gt;对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#构造函数&quot;&gt;构造函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#执行上下文堆栈&quot;&gt;执行上下文堆栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#执行上下文&quot;&gt;执行上下文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#变量对象&quot;&gt;变量对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#活动对象&quot;&gt;活动对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#作用域链&quot;&gt;作用域链&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#闭包&quot;&gt;闭包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#this&quot;&gt;this&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章是“深入理解ECMA-262-3”的一个总览和概要，每个章节都有对应的详细的链接。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>九个Console命令，让js调试更简单</title>
    <link href="http://html-js.site/2016/08/19/%E4%B9%9D%E4%B8%AAConsole%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%AE%A9js%E8%B0%83%E8%AF%95%E6%9B%B4%E7%AE%80%E5%8D%95/"/>
    <id>http://html-js.site/2016/08/19/九个Console命令，让js调试更简单/</id>
    <published>2016-08-19T04:02:45.000Z</published>
    <updated>2016-10-13T06:32:12.323Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>1.显示信息的命令<br>2.占位符<br>3.信息分组<br>4.查看对象的信息<br>5.显示某个节点的内容<br>6.判断变量是否为真<br>7.追踪函数的调用轨迹<br>8.计时功能<br>9.console.profile()性能分析</p>
</blockquote>
<a id="more"></a>
<h2 id="一、显示信息的命令"><a href="#一、显示信息的命令" class="headerlink" title="一、显示信息的命令"></a><strong>一、显示信息的命令</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;常用console命令&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        console.log(&apos;hello&apos;);</div><div class="line">        console.info(&apos;信息&apos;);</div><div class="line">        console.error(&apos;错误&apos;);</div><div class="line">        console.warn(&apos;警告&apos;);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>最常用的就是console.log了。</p>
<h2 id="二：占位符"><a href="#二：占位符" class="headerlink" title="二：占位符"></a><strong>二：占位符</strong></h2><p>onsole上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">   console.log(&quot;%d年%d月%d日&quot;,2011,3,26);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>效果：<br><img src="/images/page/console/1.png" alt=""></p>
<h2 id="三、信息分组"><a href="#三、信息分组" class="headerlink" title="三、信息分组"></a><strong>三、信息分组</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;常用console命令&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        console.group(&quot;第一组信息&quot;);</div><div class="line"></div><div class="line">    　　　　console.log(&quot;第一组第一条:我的博客(http://www.ido321.com)&quot;);</div><div class="line"></div><div class="line">    　　　　console.log(&quot;第一组第二条:CSDN(http://blog.csdn.net/u011043843)&quot;);</div><div class="line"></div><div class="line">    　　console.groupEnd();</div><div class="line"></div><div class="line">　　    console.group(&quot;第二组信息&quot;);</div><div class="line"></div><div class="line">    　　　　console.log(&quot;第二组第一条:程序爱好者QQ群： 259280570&quot;);</div><div class="line"></div><div class="line">    　　　　console.log(&quot;第二组第二条:欢迎你加入&quot;);</div><div class="line"></div><div class="line">　　    console.groupEnd();</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>效果：<br><img src="/images/page/console/2.png" alt=""></p>
<h2 id="四、查看对象的信息"><a href="#四、查看对象的信息" class="headerlink" title="四、查看对象的信息"></a><strong>四、查看对象的信息</strong></h2><p>console.dir()可以显示一个对象所有的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var info = &#123;</div><div class="line">        blog:&quot;http://www.ido321.com&quot;,</div><div class="line">        QQGroup:259280570,</div><div class="line">        message:&quot;程序爱好者欢迎你的加入&quot;</div><div class="line">    &#125;;</div><div class="line">    console.dir(info);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>效果：<br><img src="/images/page/console/3.png" alt=""></p>
<h2 id="五、显示某个节点的内容"><a href="#五、显示某个节点的内容" class="headerlink" title="五、显示某个节点的内容"></a><strong>五、显示某个节点的内容</strong></h2><p>console.dirxml()用来显示网页的某个节点（node）所包含的html/xml代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;title&gt;常用console命令&lt;/title&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;info&quot;&gt;</div><div class="line">        &lt;h3&gt;我的博客：www.ido321.com&lt;/h3&gt;</div><div class="line">        &lt;p&gt;程序爱好者:259280570,欢迎你的加入&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        var info = document.getElementById(&apos;info&apos;);</div><div class="line">        console.dirxml(info);</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>效果：<br><img src="/images/page/console/4.png" alt=""></p>
<h2 id="六、判断变量是否是真"><a href="#六、判断变量是否是真" class="headerlink" title="六、判断变量是否是真"></a><strong>六、判断变量是否是真</strong></h2><p>console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">　　var result = 1;</div><div class="line">　　console.assert( result );</div><div class="line">　　var year = 2014;</div><div class="line">　　console.assert(year == 2018 );</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>1是非0值，是真；而第二个判断是假，在控制台显示错误信息<br><img src="/images/page/console/5.png" alt=""></p>
<h2 id="七、追踪函数的调用轨迹。"><a href="#七、追踪函数的调用轨迹。" class="headerlink" title="七、追踪函数的调用轨迹。"></a><strong>七、追踪函数的调用轨迹。</strong></h2><p>console.trace()用来追踪函数的调用轨迹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">/*函数是如何被调用的，在其中加入console.trace()方法就可以了*/</div><div class="line">　　function add(a,b)&#123;</div><div class="line">        console.trace();</div><div class="line">　　　　return a+b;</div><div class="line">　　&#125;</div><div class="line">　　var x = add3(1,1);</div><div class="line">　　function add3(a,b)&#123;return add2(a,b);&#125;</div><div class="line">　　function add2(a,b)&#123;return add1(a,b);&#125;</div><div class="line">　　function add1(a,b)&#123;return add(a,b);&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>控制台输出信息：<br><img src="/images/page/console/6.png" alt=""></p>
<h2 id="八、计时功能"><a href="#八、计时功能" class="headerlink" title="八、计时功能"></a><strong>八、计时功能</strong></h2><p>console.time()和console.timeEnd()，用来显示代码的运行时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">　　console.time(&quot;控制台计时器一&quot;);</div><div class="line">　　for(var i=0;i&lt;1000;i++)&#123;</div><div class="line">　　　　for(var j=0;j&lt;1000;j++)&#123;&#125;</div><div class="line">　　&#125;</div><div class="line">　　console.timeEnd(&quot;控制台计时器一&quot;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>运行时间是38.84ms<br><img src="/images/page/console/7.png" alt=""></p>
<h2 id="九、console-profile-的性能分析"><a href="#九、console-profile-的性能分析" class="headerlink" title="九、console.profile()的性能分析"></a><strong>九、console.profile()的性能分析</strong></h2><p>性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在，使用的方法是console.profile()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">　　function All()&#123;</div><div class="line">        alert(11);</div><div class="line">　　　　     for(var i=0;i&lt;10;i++)&#123;</div><div class="line">            funcA(1000);</div><div class="line">         &#125;</div><div class="line">　　　　    funcB(10000);</div><div class="line">　　    &#125;</div><div class="line"></div><div class="line">　　function funcA(count)&#123;</div><div class="line">　　　　for(var i=0;i&lt;count;i++)&#123;&#125;</div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　function funcB(count)&#123;</div><div class="line">　　　　for(var i=0;i&lt;count;i++)&#123;&#125;</div><div class="line">　　&#125;</div><div class="line"></div><div class="line">　　console.profile(&apos;性能分析器&apos;);</div><div class="line">　　All();</div><div class="line">　　console.profileEnd();</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>输出如图：<br><img src="/images/page/console/8.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;1.显示信息的命令&lt;br&gt;2.占位符&lt;br&gt;3.信息分组&lt;br&gt;4.查看对象的信息&lt;br&gt;5.显示某个节点的内容&lt;br&gt;6.判断变量是否为真&lt;br&gt;7.追踪函数的调用轨迹&lt;br&gt;8.计时功能&lt;br&gt;9.console.profile()性能分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何优雅的使用Sublime Text</title>
    <link href="http://html-js.site/2016/08/18/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Sublime%20Text/"/>
    <id>http://html-js.site/2016/08/18/如何优雅地使用Sublime Text/</id>
    <published>2016-08-18T01:41:08.000Z</published>
    <updated>2016-10-13T06:27:45.113Z</updated>
    
    <content type="html"><![CDATA[<p><strong>工欲善其事，必先利其器！</strong><br>Sublime Text：一款具有代码高亮、语法提示、自<br>动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。</p>
<h2 id="Sublime-Text-3安装插件"><a href="#Sublime-Text-3安装插件" class="headerlink" title="Sublime Text 3安装插件"></a><strong>Sublime Text 3安装插件</strong></h2><p>Sublime Text的强大就是她拥有强大的课可扩展性。您可根据自己的需要安装不同的插件；这使得她变的无比强大的同时又不失轻便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">安装Sublime text 3插件很方便</div><div class="line">打开Package Control：菜单-&gt;Perferences-&gt;Package Control 或者 ctrl+shift+p</div><div class="line">选择install Package,然后选择要安装的插件即可</div></pre></td></tr></table></figure></p>
<p><img src="/images/page/sublimetext/1.jpg"><br><a id="more"></a></p>
<p>PS：国内使用SublimeText3，经常可能遇到无法安装可用插件问题，可remove掉<b>Package Control</b>重新安装下；如遇到连Package Control也无法安装，则可以在别处拷贝一份关于Package Control的文件－(Package Control.sublime-package)存放于<code>Installed Packages</code>目录之下即可。</p>
<h2 id="Sublime-Text-3插件推荐"><a href="#Sublime-Text-3插件推荐" class="headerlink" title="Sublime Text 3插件推荐"></a><strong>Sublime Text 3插件推荐</strong></h2><p>无插件，不神器！根据自己的需要定制属于自己的强大插件集；下面是一些常用的推荐。</p>
<p><a href="http://www.jianshu.com/p/5905f927d01b" target="_blank" rel="external">Sublime Text3插件：增强篇</a></p>
<p><a href="http://www.open-open.com/news/view/26d731" target="_blank" rel="external">20个强大的SublimeText插件</a></p>
<p>墙裂推荐以下这么几款插件：</p>
<p><strong><a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="external">MarkDown Editing</a></strong><br>SublimeText不仅仅是能够查看和编辑 Markdown 文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。</p>
<p><strong><a href="https://github.com/titoBouzout/SideBarFolders" target="_blank" rel="external">SideBarFolders</a></strong><br>打开的文件夹都太多了? 来用这个来管理文件夹，世界原来也可以这么美好。<br><img src="/images/page/sublimetext/2.jpg"></p>
<p><strong><a href="http://wbond.net/sublime_packages/terminal" target="_blank" rel="external">Sublime Terminal</a></strong><br>这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。</p>
<p><strong><a href="https://github.com/SublimeLinter" target="_blank" rel="external">SublimeLinter插件</a></strong><br>SublimeLinter 是前端编码利器——<code>Sublime Text</code> 的一款插件，用于高亮提示用户编写的代码中存在的不规范和错误的写法，支持 JavaScript、CSS、HTML、Java、PHP、Python、Ruby 等十多种开发语言。这篇文章介绍如何在 Windows 中配置 SublimeLinter 进行 JS &amp; CSS 校验。<br>比如写例如像lua这样的弱语言脚本代码，有这个可以规避掉很多不该有的低级错误吧？当然这也需要你SublimeLinter安装完毕之后再安装一个<code>SublimeLinter-lua</code>即可。具体的使用可以参见：<br><a href="http://www.cnblogs.com/lhb25/archive/2013/05/02/sublimelinter-for-js-css-coding.html" target="_blank" rel="external">借助 SublimeLinter 编写高质量的 JavaScript &amp; CSS 代码</a></p>
<p><strong><a href="https://github.com/victorporof/Sublime-HTMLPrettify" target="_blank" rel="external">HTML-CSS-JS Prettify</a></strong><br>一款集成了格式化（美化）html、css、js三种文件类型的插件，即便html,js写在PHP文件之内。插件依赖于nodejs，因此需要事先安装nodejs，然后才可以正常运行。插件安装完成后，快捷键ctrl+shift+H完成当前文件的美化操作。插件对html、css文件的美化不是非常满意，但还可以，后面将说明如何修改css美化脚本。本人用起来超级爽的，鉴于篇幅，就不赘述，可以参见<br><a href="http://frontenddev.org/article/sublime-does-text-three-plug-ins-html-and-css-js-prettify.html" target="_blank" rel="external">这篇</a></p>
<p><strong><a href="https://github.com/csscomb/CSScomb-for-Sublime" target="_blank" rel="external">CSScomb CSS属性排序</a>:</strong>有时候看看自己写的CSS文件，会不会觉得属性很乱查找不易维护难？CSScomb可以按照一定的CSS属性排序规则，将杂乱无章的CSS属性进行重新排序。选中要排序的CSS代码，按Ctrl+Shift+C，即可对CSS属性重新排序了，代码从此简洁有序易维护，如果不款选代码则插件将排序文件中所有的CSS属性。当然，可以自己自定义CSS属性排序规则，打开插件目录里的CSScomb.sublime-settings文件，更改里面的CSS属性顺序就行了。因为这个插件使用PHP写的，要使他工作需要在环境变量中添加PHP的路径，具体请看github上的说明。</p>

<p></p><p>剩下些许其他的可以按需安装的插件，比如：</p><p></p>
<ul><br><li><strong>ConvertToUTF8</strong>  支持 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的插件</li><br><li><strong>Bracket Highlighter</strong> 用于匹配括号，引号和html标签。对于很长的代码很有用。安装好之后，不需要设置插件会自动生效</li><br><li><strong>DocBlockr</strong> 可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++</li><br><li><strong><font color="purple">Emmet(Zen Coding)</font></strong>快速生成HTML代码段的插件，强大到无与伦比:可以超快速编写HTML/CSS/JS，当然这个插件还支持多种编译环境，如常见的：Eclipse/Aptana、Coda、Notepad++、Adobe Dreamweaver、TextMate等，<strong>web开发必备！！！</strong>。</li><br><li><strong>jsFormat</strong> 格式化js代码，懂者自懂；强迫症Coder必备！默认快捷键Ctrl+Alt+F。</li><br><li><strong>phpFormat</strong> 格式化php代码，懂者自懂；强迫症Coder必备！</li><br><li><strong>CSS Compact Expand CSS属性展开收缩:</strong>写CSS的盆友，喜欢将其写多行还是一行(个人喜欢将其格式化为多行)？如果阅读别人的代码不符合自己的习惯，可以用CSS Compact Expand这个插件将CSS格式化一下，按 Ctrl+Alt+[ 收缩CSS代码为一行显示，按 Ctrl+Alt+] 展开CSS代码为多行显示；强迫症Coder必备！。</li><br><li><strong>Autoprefixer插件</strong>：这是一款CSS3私有前缀自动补全插件；该插件使用CanIUse资料库（当然，SublimeText自然也有<font color="purple">CanIUse</font>这个插件咯），能精准判断哪些属性需要什么前缀，与CssComb插件一样，该插件也需要系统已安装Node.js环境；使用方法：在输入CSS3属性后（冒号前）按Tab键即可。</li><br><li><strong>YUI Compressor</strong>：压缩JS和CSS文件，按F7键后，若压缩当前文件（demo.js），则压缩后的文件（demo.min.js）保存在该文件的同级目录，需要安装java的JDK。使用方法：<a href="http://frontenddev.org/article/sublime-does-text-3-plug-in-yui-compressor.html" target="_blank" rel="external">YUI Compressor</a></li><br><li><strong>ClickableURLs：可点击的URL</strong>使用小插件<a href="https://github.com/leonid-shevtsov/ClickableUrls_SublimeText" target="_blank" rel="external">ClickableURLs</a>可以让文件中的URL能够点击。</li><br><li><strong>终极王道</strong>：自己编写专用的Sublime Text插件。虽然说各个方面比如移动端，Web前段，服务器端，非Coder的Writer所需要的方便已经被集成在了不同的插件中。但譬如，需要快捷打开PC端的某个模拟器，便捷的进行某些校验，只要你想的到的基本都可以将其在插件内，以快捷键处理之。至于如何编写SublimeText插件，请参看这里<a href="http://www.360doc.com/content/15/0417/22/19342630_463999403.shtml" target="_blank" rel="external">编写自己的Sublime Text2 插件</a></li><br></ul>



<h2 id="自定义代码片段"><a href="#自定义代码片段" class="headerlink" title="自定义代码片段"></a><strong>自定义代码片段</strong></h2><p>我们在开发中有很多代码是需要重复编写的，每一次都去复制粘贴显然是一件效率极其低下的事情，sublime的自定义代码片段功能就很好的解决了这个问题。下面就来看一下如何在sublime中自定义代码片段</p>
<p></p><p>首先在菜单栏选择：Tools -&gt;developer -&gt; New Snippet可以看到新建一个<code>xml</code>类型的描述文件，如下：</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;snippet&gt;</div><div class="line">    &lt;content&gt;&lt;![CDATA[</div><div class="line">Hello, $&#123;1:this&#125; is a $&#123;2:snippet&#125;.</div><div class="line">]]&gt;&lt;/content&gt;</div><div class="line">    &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;</div><div class="line">    &lt;!-- &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; --&gt;</div><div class="line">    &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;</div><div class="line">    &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</div><div class="line">&lt;/snippet&gt;</div></pre></td></tr></table></figure><p></p>
<p></p><p>注释已经非常详细了，<code>content</code> 里面就是代码模版：<code>${序号：默认值}</code> ，序号相同的地方光标会同时停在那可以多处同时编辑。序号大小就是 <code>tabindex</code>。在实际使用代码的时候，可以使用 <code>tab</code> 切换光标位置。</p><br>例子：Tatami.module<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">&lt;snippet&gt;</div><div class="line">	&lt;content&gt;&lt;![CDATA[</div><div class="line">/**</div><div class="line"> * Created by wangyang on $&#123;1:16/8/1&#125;.</div><div class="line"> */</div><div class="line">(function (rc) &#123;</div><div class="line">  	rc.modules.define(&#123;</div><div class="line">	    name: &apos;$&#123;2:name&#125;&apos;,</div><div class="line">	    depend: &apos;$&#123;3:depend&#125;&apos;,</div><div class="line">	    viewName: &apos;view.$&#123;2:name&#125;&apos;,</div><div class="line">	    type: &apos;&apos;, //basic/normal/sub</div><div class="line">	    ctrlsMap: &#123;&#125;,</div><div class="line">	    statusMap: &#123;&#125;,</div><div class="line">	    dataMap: &#123;&#125;,</div><div class="line">	    methodsMap: &#123;</div><div class="line">	    &#125;,</div><div class="line">	    events: &#123;&#125;,</div><div class="line">	    activation: function()&#123;&#125;,</div><div class="line">	    init: function () &#123;</div><div class="line">	    &#125;,</div><div class="line">	    update: function (hashs, isSelf) &#123;</div><div class="line"></div><div class="line">	    &#125;,</div><div class="line">	    destory: function () &#123;&#125;,</div><div class="line">	    disabled: function () &#123;&#125;</div><div class="line">  	&#125;)</div><div class="line">&#125;)(window.Tatami);</div><div class="line">]]&gt;&lt;/content&gt;</div><div class="line">	&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;</div><div class="line">	&lt;!-- 可选：快捷键，利用Tab自动补全代码的功能 --&gt;</div><div class="line">	&lt;tabTrigger&gt;ttmModule&lt;/tabTrigger&gt;</div><div class="line">	&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;</div><div class="line">	&lt;!-- 可选：使用范围，不填写代表对所有文件有效。附：source.css和test.html分别对应不同文件。 --&gt;</div><div class="line">	&lt;scope&gt;source.js&lt;/scope&gt;</div><div class="line">	&lt;!-- 可选：在snippet菜单中的显示说明（支持中文）。如果不定义，菜单则显示当前文件的文件名。 --&gt;</div><div class="line">	&lt;description&gt;Tatami Module&lt;/description&gt;</div><div class="line">&lt;/snippet&gt;</div></pre></td></tr></table></figure><p></p>
<p>结束语：如果你还在一行一行的手动敲代码，是时候改变了</p>
<p><strong>工欲善其事，必先利其器！</strong><br><strong>工欲善其事，必先利其器！</strong><br><strong>工欲善其事，必先利其器！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;工欲善其事，必先利其器！&lt;/strong&gt;&lt;br&gt;Sublime Text：一款具有代码高亮、语法提示、自&lt;br&gt;动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。&lt;/p&gt;
&lt;h2 id=&quot;Sublime-Text-3安装插件&quot;&gt;&lt;a href=&quot;#Sublime-Text-3安装插件&quot; class=&quot;headerlink&quot; title=&quot;Sublime Text 3安装插件&quot;&gt;&lt;/a&gt;&lt;strong&gt;Sublime Text 3安装插件&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Sublime Text的强大就是她拥有强大的课可扩展性。您可根据自己的需要安装不同的插件；这使得她变的无比强大的同时又不失轻便。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;安装Sublime text 3插件很方便&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;打开Package Control：菜单-&amp;gt;Perferences-&amp;gt;Package Control 或者 ctrl+shift+p&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;选择install Package,然后选择要安装的插件即可&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/page/sublimetext/1.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="sublime text" scheme="http://html-js.site/tags/sublime-text/"/>
    
  </entry>
  
  <entry>
    <title>一些jquery小技巧</title>
    <link href="http://html-js.site/2016/07/14/%E4%B8%80%E4%BA%9Bjquery%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://html-js.site/2016/07/14/一些jquery小技巧/</id>
    <published>2016-07-14T08:27:08.000Z</published>
    <updated>2016-10-13T06:28:10.551Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章总结了一些个人的jquery小知识</p>
<h3 id="回到顶部的按钮"><a href="#回到顶部的按钮" class="headerlink" title="回到顶部的按钮"></a>回到顶部的按钮</h3><p>通过使用jQuery中的<code>animate</code> 与 <code>scrollTop</code> 方法可以创建一个非常简易的带有平滑滚动的回到顶部的按钮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Back to top</div><div class="line">$(&apos;a.top&apos;).click(function (e) &#123;</div><div class="line">  e.preventDefault();</div><div class="line">  $(document.body).animate(&#123;scrollTop: 0&#125;, 800);</div><div class="line">&#125;);</div><div class="line">&lt;!-- Create an anchor tag --&gt;</div><div class="line">&lt;a class=&quot;top&quot; href=&quot;#&quot;&gt;Back to top&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p>通过修改 <code>scrollTop</code>的值可以设置滚动最终停止的位置，最终的效果就是在800毫秒的时间内文档会被滚动到指定的地方。</p>
<a id="more"></a>
<h3 id="checkbox和radio的相关操作"><a href="#checkbox和radio的相关操作" class="headerlink" title="checkbox和radio的相关操作"></a>checkbox和radio的相关操作</h3><p>判断是否选中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;input.class&apos;).is(&apos;:checked&apos;);// true/false</div></pre></td></tr></table></figure></p>
<p>让某个选中,使用 <code>prop</code> 而不是 <code>attr</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;input.class&apos;).prop(&apos;checked&apos;,true/false);</div></pre></td></tr></table></figure></p>
<p>取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;input[name=name]:checked&apos;).val();</div></pre></td></tr></table></figure></p>
<h3 id="js-replaceAll实现"><a href="#js-replaceAll实现" class="headerlink" title="js replaceAll实现"></a>js replaceAll实现</h3><p><code>js</code> 没有 <code>java</code> 的 <code>replaceAll</code> 方法，这边有个方便的实现方法，利用正则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var aa = &apos;1212121212&apos;</div><div class="line">aa.replace(/1/g,&apos;2&apos;)</div><div class="line">//&quot;2222222222&quot;</div></pre></td></tr></table></figure></p>
<h3 id="检查图片是否加载完成"><a href="#检查图片是否加载完成" class="headerlink" title="检查图片是否加载完成"></a>检查图片是否加载完成</h3><p>有时候需要检查某个图片是否加载完成从而继续下面的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;img&apos;).load(function () &#123;</div><div class="line">  console.log(&apos;image load successful&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>同样的，可以使用ID或者类选择器来判断某个特定的图片是否加载完成。</p>
<h3 id="图片加载失败的处理"><a href="#图片加载失败的处理" class="headerlink" title="图片加载失败的处理"></a>图片加载失败的处理</h3><p>在页面上如果发生某些图片加载失败是一个非常常见并且恶心的事情，如下的一小段代码可以在某种程度上解决这个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;img&apos;).on(&apos;error&apos;, function () &#123;</div><div class="line">  $(this).prop(&apos;src&apos;, &apos;img/broken.png&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>即使没有发现任何的坏链的情况，也是建议将这段代码添加到页面中。</p>
<h3 id="使用Toggle"><a href="#使用Toggle" class="headerlink" title="使用Toggle"></a>使用Toggle</h3><p>很多时候需要的响应是在用户悬浮在某个元素上时改变其的可见性或者状态，换言之，即是在用户将鼠标悬浮在某个元素上时修改其的类属性，而在用户停止悬浮时移除该类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&apos;.btn&apos;).hover(function () &#123;</div><div class="line">  $(this).addClass(&apos;hover&apos;);</div><div class="line">  &#125;, function () &#123;</div><div class="line">    $(this).removeClass(&apos;hover&apos;);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<p>当然，更简单的就是利用 <code>toggleClass</code> 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;.btn&apos;).hover(function () &#123;</div><div class="line">  $(this).toggleClass(&apos;hover&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p><b>Note</b>: CSS的hover伪类可能是更方便的做法，不过知晓这种用法也是值得的。</p>
<h3 id="禁用输入框"><a href="#禁用输入框" class="headerlink" title="禁用输入框"></a>禁用输入框</h3><p>很多情况下我们希望提交按钮能够在部分文本框未填入的情况下处于禁用状态直到用户执行了某个动作，此时我们就需要为这个按钮添加disabled属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;input[type=&quot;submit&quot;]&apos;).prop(&apos;disabled&apos;, true);</div></pre></td></tr></table></figure></p>
<p>如果需要回复输入框的状态，那么就要再次使用 <code>prop</code>方法, 不过将 <code>disabled</code> 的值设置为<code>false</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;input[type=&quot;submit&quot;]&apos;).prop(&apos;disabled&apos;, false);</div></pre></td></tr></table></figure></p>
<h3 id="阻止链接的加载"><a href="#阻止链接的加载" class="headerlink" title="阻止链接的加载"></a>阻止链接的加载</h3><p>有时候你不希望用户在点击了某个链接之后跳转到新的页面或者重载当前页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&apos;a.no-link&apos;).click(function (e) &#123;</div><div class="line">  e.preventDefault();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<h3 id="触发渐隐-滑动"><a href="#触发渐隐-滑动" class="headerlink" title="触发渐隐/滑动"></a>触发渐隐/滑动</h3><p>滑动与渐隐是jQuery种最常见的动画之一，很多时候我们希望能在用户点击某个元素之后将其渐隐渐出或者滑动出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// Fade</div><div class="line">$(&apos;.btn&apos;).click(function () &#123;</div><div class="line">  $(&apos;.element&apos;).fadeToggle(&apos;slow&apos;);</div><div class="line">&#125;);</div><div class="line">// Toggle</div><div class="line">$(&apos;.btn&apos;).click(function () &#123;</div><div class="line">  $(&apos;.element&apos;).slideToggle(&apos;slow&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="将两个DIV设置为统一高度"><a href="#将两个DIV设置为统一高度" class="headerlink" title="将两个DIV设置为统一高度"></a>将两个DIV设置为统一高度</h3><p>有时候希望无论两个DIV种包含怎样的内容都能保持统一高度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;.div&apos;).css(&apos;min-height&apos;, $(&apos;.main-div&apos;).height());</div></pre></td></tr></table></figure></p>
<h3 id="根据文本选择元素"><a href="#根据文本选择元素" class="headerlink" title="根据文本选择元素"></a>根据文本选择元素</h3><p>通过使用 <code>contains()</code> 选择器可以根据内容搜索对应的元素，下述代码的作用就是在文本不存在的时候隐藏元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var search = $(&apos;#search&apos;).val();</div><div class="line">$(&apos;div:not(:contains(&quot;&apos;+search+&apos;&quot;))&apos;).hide();</div></pre></td></tr></table></figure></p>
<h3 id="可见性变化时候的触发"><a href="#可见性变化时候的触发" class="headerlink" title="可见性变化时候的触发"></a>可见性变化时候的触发</h3><p>在某个Tab获得焦点或者失去焦点的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(document).on(&apos;visibilitychange&apos;, function(e)&#123;</div><div class="line">  if (e.target.visibilityState === &quot;visible&quot;) &#123;</div><div class="line">    console.log(&apos;Tab is now in view!&apos;);</div><div class="line">  &#125; else if (e.target.visibilityState === &quot;hidden&quot;) &#123;</div><div class="line">    console.log(&apos;Tab is now hidden!&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章总结了一些个人的jquery小知识&lt;/p&gt;
&lt;h3 id=&quot;回到顶部的按钮&quot;&gt;&lt;a href=&quot;#回到顶部的按钮&quot; class=&quot;headerlink&quot; title=&quot;回到顶部的按钮&quot;&gt;&lt;/a&gt;回到顶部的按钮&lt;/h3&gt;&lt;p&gt;通过使用jQuery中的&lt;code&gt;animate&lt;/code&gt; 与 &lt;code&gt;scrollTop&lt;/code&gt; 方法可以创建一个非常简易的带有平滑滚动的回到顶部的按钮：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// Back to top&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$(&amp;apos;a.top&amp;apos;).click(function (e) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  e.preventDefault();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  $(document.body).animate(&amp;#123;scrollTop: 0&amp;#125;, 800);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;!-- Create an anchor tag --&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;a class=&amp;quot;top&amp;quot; href=&amp;quot;#&amp;quot;&amp;gt;Back to top&amp;lt;/a&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过修改 &lt;code&gt;scrollTop&lt;/code&gt;的值可以设置滚动最终停止的位置，最终的效果就是在800毫秒的时间内文档会被滚动到指定的地方。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript中创建对象的模式汇总</title>
    <link href="http://html-js.site/2016/07/05/JavaScript%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB/"/>
    <id>http://html-js.site/2016/07/05/JavaScript中创建对象的模式汇总/</id>
    <published>2016-07-05T06:19:25.000Z</published>
    <updated>2016-10-13T06:29:44.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为超级营销无线装修用到了很多创建对象的方法，而不同的方法对于对象的设计，功能的实现会有很大的不同，所以最近在看代码的时候特意查了下<b>创建对象</b>的各种方法，在这里记录一下</p>
<blockquote>
<p>1.对象字面量<br>2.工厂模式<br>3.构造函数模式<br>4.原型模式<br>5.结合构造函数和原型模式<br>6.原型动态模式</p>
</blockquote>
<a id="more"></a>
<h3 id="1、对象字面量"><a href="#1、对象字面量" class="headerlink" title="1、对象字面量"></a>1、对象字面量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    name : &apos;Nicholas&apos;;</div><div class="line">    age : &apos;22&apos;;</div><div class="line">    job :&quot;software Engineer&quot;</div><div class="line">    sayName: function() &#123;</div><div class="line">      alter(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>例子中创建一个名为person的对象，并为它添加了三个属性（name,age,job）和一个方法（sayName()），其中，sayName()方法用于显示this.name(被解析为person.name)的值。</p>
<p><b>对象字面量可以用来创建单个对象，但这个方法有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复的代码。</b></p>
<h3 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h3><p>工厂模式是软件工程领域中一种广为人知的设计模式，工厂模式抽象了创建具体对象的过程，用函数来封装以特定的接口创建对象的细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function createPerson(name,age,job)&#123;</div><div class="line">  var o = new object&#123;&#125;;</div><div class="line">  o.name=name;</div><div class="line">  o.age=age;</div><div class="line">  o.job=job;</div><div class="line">  o.sayName=function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">  &#125;;</div><div class="line">  return o;</div><div class="line">&#125;</div><div class="line">var person1=creatPerson(&quot;Nicholas&quot;,22,&quot;software Engineer&quot;);</div><div class="line">var person2=creatPerson(&quot;Greg&quot;,24,&quot;student&quot;);</div></pre></td></tr></table></figure>
<p>函数creatPerson{}能够根据接受的参数构建一个包含所有必要信息的Person对象。可以无数次的调用这个函数，每次都会返回一个包含三个属性一个方法的对象。</p>
<p><b>工厂模型虽然解决了创建多个相似对象的问题，却没有解决对象识别的问题（即怎么知道一个对象的类型）。 </b></p>
<h3 id="3、构造函数模式"><a href="#3、构造函数模式" class="headerlink" title="3、构造函数模式"></a>3、构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.age = age;</div><div class="line">  this.job = job;</div><div class="line">  this.sayName = function() &#123;</div><div class="line">    alert(this.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">//通过new操作符创建Person的实例</div><div class="line">var person1 = new Person(&quot;Nicholas&quot;,22,&quot;software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;,24,&quot;student&quot;);</div><div class="line">person1.sayName(); //Nicholas</div><div class="line">person2.sayName(); //Greg</div></pre></td></tr></table></figure>
<p><b>与工厂模式不同的是</b><br>没有显示的创建对象</p>
<p>直接将属性和方法赋给了this对象</p>
<p>没有return语句</p>
<p>创建Person的新实例，必须使用new操作符。调用构造函数的4个步骤：</p>
<p>创建一个新对象</p>
<p>将构造函数的作用域赋给新对象（this指向了这个新对象）</p>
<p>执行构造函数中的代码</p>
<p>返回新对象</p>
<p>这个例子中创建的所有对象既是Object的实例，也是Person实例。可以通过instanceof操作符验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person1 instanceof Object);//true</div></pre></td></tr></table></figure>
<p>构造函数模式也有自己的问题，实际上，sayName方法在每个实例上都会被重新创建一次，需要注意的是，通过实例化创建的方法并不相等，以下代码可以证明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person1.sayName == person2.sayName);//false</div></pre></td></tr></table></figure></p>
<p>可以将方法移到构造器的外部作为全局函数来解决这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.age = age;</div><div class="line">  this.job = job;</div><div class="line">&#125;</div><div class="line">function sayName() &#123;</div><div class="line">  alert(this.name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在全局下创建的全局函数实际上只能被经由Person创建的实例调用，这就有点名不副实了；如果对象需要定义很对方法，那么就要定义很多个全局函数，缺少封装性。</p>
<h3 id="4、原型模式"><a href="#4、原型模式" class="headerlink" title="4、原型模式"></a>4、原型模式</h3><p>JavaScript中创建的每个函数都有一个prototype（原型）属性，它是一个指针，指向一个对象，包含了可以由特定类型的所有实例共享的属性和方法（让所有的对象实例共享它的属性和方法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line">  Person.prototype.name =&quot;Nicholas&quot;;</div><div class="line">  Person.prototype.age = 22;</div><div class="line">  Person.prototype.job = &quot;software Engineer&quot;;</div><div class="line">  Person.prototype.sayName()&#123;</div><div class="line">    alert(this.name);</div><div class="line">  &#125;;</div><div class="line"> var person1 = new Person();</div><div class="line"> person1.sayName(); //Nicholas</div><div class="line">alert(person1.sayName == person2.sayName);//true</div></pre></td></tr></table></figure></p>
<p>以上代码做了这几件事情：</p>
<p>定义了一个构造函数Person，Person函数自动获得一个prototype属性，该属性默认只包含一个指向Person的constructor属性</p>
<p>通过Person.prototype添加三个属性，和一个方法</p>
<p>创建一个Person的实例，随后在实例上调用了sayName()方法</p>
<p>使用Person构造函数和Person.prototype创建实例的代码为例，展示个对象之间的关系</p>
<p><img src="/images/page/createObject/1.png"></p>
<p>图中展示了Person构造函数、Person的原型属性以及Person的两个实例，之间的关系。Person.prototype指向了原型对象，Person.prototype.constructor有指回了Person。原型对象中除了包含constructor属性，还包含后来添加的其他属性和方法，Person的两个实例person1和person2都包含一个内部属性，该属性仅指向Person.prototype。</p>
<p><b>sayName()方法的调用过程：</b></p>
<p>在person1实例上查找sayame()方法，发现没有这个方法，于是追溯到person1的原型</p>
<p>在person1的原型上查找sayame()方法，有这个方法，于是调用该方法</p>
<p>基于这样一个查找过程，我们可以通过在实例上定义原型中的同名属性，来阻止该实例访问原型上的同名属性，需要注意的是，这样做并不会删除原型上的同名属性，仅仅是阻止实例访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line">  Person.prototype.name =&quot;Nicholas&quot;;</div><div class="line">  Person.prototype.age = 22;</div><div class="line">  Person.prototype.job = &quot;software Engineer&quot;;</div><div class="line">  Person.prototype.sayName()&#123;</div><div class="line">    alert(this.name);</div><div class="line">  &#125;;</div><div class="line"> var person1 = new Person();</div><div class="line"> var person2 = new Person();</div><div class="line"> person1.name=&quot;Greg&quot;</div><div class="line">alert(person1.name) //Greg 来自实例</div><div class="line">alert(person2.name) //Nicholas 来自原型</div></pre></td></tr></table></figure>
<p>使用delete操作符可以完全删除实例属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">delete person1.name;</div><div class="line">alert(person1.name) //Nicholas 来自原型</div></pre></td></tr></table></figure></p>
<p>使用hasOwnProperty()方法可以检测一个属性是存在于实例还是原型中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line">  Person.prototype.name =&quot;Nicholas&quot;;</div><div class="line">  Person.prototype.age = 22;</div><div class="line">  Person.prototype.job = &quot;software Engineer&quot;;</div><div class="line">  Person.prototype.sayName()&#123;</div><div class="line">    alert(this.name);</div><div class="line">  &#125;;</div><div class="line"> var person1 = new Person();</div><div class="line"> var person2 = new Person();</div><div class="line"> alert(person1,hasOwnProperty(&quot;name&quot;));//false</div><div class="line"> person1.name=&quot;Greg&quot;</div><div class="line">alert(person1.name) //Greg 来自实例</div><div class="line"> alert(person1,hasOwnProperty(&quot;name&quot;));//true</div><div class="line">alert(person2.name) //Nicholas 来自原型</div><div class="line"> alert(person2,hasOwnProperty(&quot;name&quot;));//false</div><div class="line"> delete person1.name;</div><div class="line">alert(person1.name) //Nicholas 来自原型</div><div class="line"> alert(person1,hasOwnProperty(&quot;name&quot;));//false</div></pre></td></tr></table></figure></p>
<p>下图展示了在不同情况下实例与原型之间的关系<br><img src="/images/page/createObject/2.png"></p>
<h3 id="5、简单的原型语法"><a href="#5、简单的原型语法" class="headerlink" title="5、简单的原型语法"></a>5、简单的原型语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"> Person.prototype=&#123;</div><div class="line"> name ：&quot;Nicholas&quot;,</div><div class="line"> age ： 22,</div><div class="line"> job ： &quot;software Engineer&quot;,</div><div class="line"> sayName：function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>在上面的代码中constructor属性不再指向Person了，通过constructor无法确定对象的类型了。可以像下面这样特意将他设置回适当的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"> Person.prototype=&#123;</div><div class="line"> constructor:Person,</div><div class="line"> name ：&quot;Nicholas&quot;,</div><div class="line"> age ： 22,</div><div class="line"> job ： &quot;software Engineer&quot;,</div><div class="line"> sayName：function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure></p>
<p>重设constructor属性会导致它的[[Enumerable]]特性被设置为true，默认情况，原生的constructor属性是不可枚举的，可以使用Object.defineProperty()方法来改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object.defineProperty(Person.prototype,&quot;constructor&quot;,&#123;</div><div class="line">  enumerable:false,</div><div class="line">  value:Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>原型中查找值的过程是一次搜索，原型对象所做的任何修改都能从实例上立即反应出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var friend=new Person();</div><div class="line">Person.prototype.sayHi=function()&#123;</div><div class="line">  alert(&quot;hi);</div><div class="line">&#125;</div><div class="line">friend,sayHi();//&quot;hi&quot;(没有问题)</div></pre></td></tr></table></figure></p>
<p>person实例是在添加新方法之前创建的，但仍可以访问新添加的方法，原因是实例与原型之间的松散连接关系</p>
<p>重写原型对象后的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line">var friend=new Person();</div><div class="line"> Person.prototype=&#123;</div><div class="line"> name ：&quot;Nicholas&quot;,</div><div class="line"> age ： 22,</div><div class="line"> job ： &quot;software Engineer&quot;,</div><div class="line"> sayName：function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  friend.sayName();//error</div></pre></td></tr></table></figure></p>
<p>调用friend.sayName()时发生错误的原因是，friend指向的原型中不包含以该字段命名的属性，如下图。<br><img src="/images/page/createObject/3.png"></p>
<p><b>原型对象的问题</b><br>原型对象省略了为构造函数传递初始化参数这一环节，所有势力在默认情况下都取得相同的属性值。原型模型最大的问题是有其共享本性所导致的。当原型模型包含引用类型的属性来说，问题就比较严重了。来看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Person() &#123;&#125;</div><div class="line"> Person.prototype=&#123;</div><div class="line"> constructor:Person,</div><div class="line"> name ：&quot;Nicholas&quot;,</div><div class="line"> age ： 22,</div><div class="line"> job ： &quot;software Engineer&quot;,</div><div class="line"> friends:[&quot;Shelby&quot;,&quot;Court&quot;],</div><div class="line"> sayName：function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  var person1=new Person();</div><div class="line">  var person2=new Person();</div><div class="line">  person1.friend.push(&quot;Van&quot;);</div><div class="line">  alert(person1.friends);//&quot;Shelby,Court,Van&quot;</div><div class="line">  alert(person2.friends);//&quot;Shelby,Court,Van&quot;</div><div class="line"> alert(person1.friends==person2.friends);//true</div></pre></td></tr></table></figure></p>
<h3 id="5、组合使用构造函数模式和原型模式"><a href="#5、组合使用构造函数模式和原型模式" class="headerlink" title="5、组合使用构造函数模式和原型模式"></a>5、组合使用构造函数模式和原型模式</h3><p>组合使用构造函数模式和原型模式中，构造函数用于定义实例属性，原型模型用于定义方法和共享的属性。这样每个实例都会有自己的一份实例属性的副本，同时也可以共享对方法的引用，最大限度的节省了内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Person(name,age,job) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.age = age;</div><div class="line">  this.job = job;</div><div class="line">  this.friends=[&quot;Shelby&quot;,&quot;Court&quot;];</div><div class="line">&#125;</div><div class="line">Person.prototype=&#123;</div><div class="line"> constructor：Person，</div><div class="line"> sayName：function()&#123;</div><div class="line">    alert(this.name);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">var person1=new Person(&quot;Nicholas&quot;,22,&quot;software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;,24,&quot;student&quot;);</div><div class="line">person1.friend.push(&quot;Van&quot;);</div><div class="line">  alert(person1.friends);//&quot;Shelby,Court,Van&quot;</div><div class="line">  alert(person2.friends);//&quot;Shelby,Court&quot;</div><div class="line"> alert(person1.friends==person2.friends);//false</div><div class="line"> alert(person1.sayName==person2.sayName);//true</div></pre></td></tr></table></figure>
<h3 id="6、动态原型模式"><a href="#6、动态原型模式" class="headerlink" title="6、动态原型模式"></a>6、动态原型模式</h3><p>原型动态模式将需要的所有信息都封装到构造函数中，通过if语句判断原型中的某个属性是否存在，若不存在（在第一次调用这个构造函数的时候），执行if语句内部的原型初始化代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name,age) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.age = age;</div><div class="line">  this.job =job;</div><div class="line">//方法</div><div class="line">  if(typeof this.sayName != &apos;function&apos;) &#123;</div><div class="line">  Person.prototype.sayName = function() &#123;</div><div class="line">      alert(this.name);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var friend = new Person(&apos;Nicholas&apos;,&apos;22&apos;,&apos;Software Engineer&apos;);//初次调用构造函数，此时修改了原型</div><div class="line">var person2 = new Person(&apos;amy&apos;,&apos;21&apos;);//此时sayName()方法已经存在，不会再修改原型</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;因为超级营销无线装修用到了很多创建对象的方法，而不同的方法对于对象的设计，功能的实现会有很大的不同，所以最近在看代码的时候特意查了下&lt;b&gt;创建对象&lt;/b&gt;的各种方法，在这里记录一下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.对象字面量&lt;br&gt;2.工厂模式&lt;br&gt;3.构造函数模式&lt;br&gt;4.原型模式&lt;br&gt;5.结合构造函数和原型模式&lt;br&gt;6.原型动态模式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
      <category term="对象" scheme="http://html-js.site/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>自己实现lazyload</title>
    <link href="http://html-js.site/2016/06/28/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0lazyload/"/>
    <id>http://html-js.site/2016/06/28/自己实现lazyload/</id>
    <published>2016-06-28T01:31:12.000Z</published>
    <updated>2016-10-13T06:33:03.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>心血来潮，自己花了一个小时实现了一个简易版的lazyload插件。</p>
<p><a href="/file/lazyload/index.html" target="_blank">例子</a>，<br><a href="https://github.com/WangYang-Rex/lazyload" target="_blank">源代码</a></p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>插件初始化时对匹配的img元素进行遍历，如果在可是区域之内，那么就赋值src，然后监听scroll事件，直到匹配的img数组为空。</p>
<p>主要用到了getBoundingClientRect()函数，兼容ie，作用是获取元素距离视窗上下左右的距离<br><img src="/images/page/lazyload/1.jpg"></p>
<a id="more"></a>
<p><a href="/file/lazyload/index.html" target="_blank">例子</a>，<br><a href="https://github.com/WangYang-Rex/lazyload" target="_blank">源代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;心血来潮，自己花了一个小时实现了一个简易版的lazyload插件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/file/lazyload/index.html&quot; target=&quot;_blank&quot;&gt;例子&lt;/a&gt;，&lt;br&gt;&lt;a href=&quot;https://github.com/WangYang-Rex/lazyload&quot; target=&quot;_blank&quot;&gt;源代码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;设计思路&quot;&gt;&lt;a href=&quot;#设计思路&quot; class=&quot;headerlink&quot; title=&quot;设计思路&quot;&gt;&lt;/a&gt;设计思路&lt;/h3&gt;&lt;p&gt;插件初始化时对匹配的img元素进行遍历，如果在可是区域之内，那么就赋值src，然后监听scroll事件，直到匹配的img数组为空。&lt;/p&gt;
&lt;p&gt;主要用到了getBoundingClientRect()函数，兼容ie，作用是获取元素距离视窗上下左右的距离&lt;br&gt;&lt;img src=&quot;/images/page/lazyload/1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="lazyload" scheme="http://html-js.site/tags/lazyload/"/>
    
      <category term="js" scheme="http://html-js.site/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>window.location hash和search 掐架</title>
    <link href="http://html-js.site/2016/06/17/window-location-hash%E5%92%8Csearch-%E6%8E%90%E6%9E%B6/"/>
    <id>http://html-js.site/2016/06/17/window-location-hash和search-掐架/</id>
    <published>2016-06-17T03:01:03.000Z</published>
    <updated>2016-10-13T06:33:32.903Z</updated>
    
    <content type="html"><![CDATA[<h3 id="发现问题的由来"><a href="#发现问题的由来" class="headerlink" title="发现问题的由来"></a>发现问题的由来</h3><p>首先有个需求，就是获取浏览器参数，也就是 window.location.href问号后面的参数值，就google了一个在江湖中流传的号称最好用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function GetQueryString(name)</div><div class="line">&#123;</div><div class="line">     var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);</div><div class="line">     var r = window.location.search.substr(1).match(reg);</div><div class="line">     if(r!=null)return  unescape(r[2]); return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 调用方法</div><div class="line">alert(GetQueryString(&quot;参数名1&quot;));</div></pre></td></tr></table></figure></p>
<p>设置了一个全局方法，成功了，立马各个项目用起来~</p>
<p>这次有个需求，在页面加载时去获取参数时发现怎么都获取不到，于是去看代码，发现用到了window.location.search，调试发现window.location.search是空字符串。</p>
<a id="more"></a>
<h3 id="科普window-location"><a href="#科普window-location" class="headerlink" title="科普window.location"></a>科普window.location</h3><p>这段内容是W3C上找的，高手请跳过~<br><img src="/images/page/location/2.jpg"></p>
<h4 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h4><p>Location 对象包含有关当前 URL 的信息。</p>
<p>Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。<br><img src="/images/page/location/1.jpg"></p>
<h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>search:设置或返回从问号 (?) 开始的 URL（查询部分）。<br>感觉没问题啊，可是为什么window.location.search是空字符串？</p>
<p>请看下图调试结果：<br><img src="/images/page/location/3.jpg"></p>
<p><b>?id=1出现在了hash中，而没有出现在search中</b>，汗！！！</p>
<h3 id="找到答案"><a href="#找到答案" class="headerlink" title="找到答案"></a>找到答案</h3><p>继续google，在<a href="http://stackoverflow.com/questions/23789587/why-is-window-location-search-empty" target="_blick">stackoverflow</a>找到了解答：<br><img src="/images/page/location/4.jpg"></p>
<p>window.location在解析url时，#后面的全都识别成了hash；</p>
<p>个人猜测url解析时,即使遇到?，后面也会去解析#;</p>
<p>相反，如解析时遇到#，后面却不会再去解析? 得找个相关的资料看下了~</p>
<p>一句话，慎用#,慎用#,慎用#，重要的话说三遍！</p>
<p>最后修改了获取浏览器参数的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function GetQueryString(name)</div><div class="line">&#123;</div><div class="line">     var search = window.location.search;</div><div class="line">     if(!search)&#123;</div><div class="line">        var hash = location.hash;</div><div class="line">        search = hash?hash.substring(hash.indexOf(&apos;?&apos;)):&apos;&apos;;</div><div class="line">     &#125;</div><div class="line">     var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);</div><div class="line">     var r = search.substr(1).match(reg);</div><div class="line">     if(r!=null)return  unescape(r[2]); return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>另外，根据我们的项目特征，可以把参数设置放在#之前<br>比如：<br><img src="/images/page/location/5.jpg"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://taeyxbak1.superboss.cc/index.html?id=18511#/zx/zdy/</div></pre></td></tr></table></figure></p>
<p>当然这个场景设定在我们的框架初始化之前就要拿url参数，如果是框架初始化之后，那么可以用我们框架的方法，相应方法可以在pages里面找到~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;发现问题的由来&quot;&gt;&lt;a href=&quot;#发现问题的由来&quot; class=&quot;headerlink&quot; title=&quot;发现问题的由来&quot;&gt;&lt;/a&gt;发现问题的由来&lt;/h3&gt;&lt;p&gt;首先有个需求，就是获取浏览器参数，也就是 window.location.href问号后面的参数值，就google了一个在江湖中流传的号称最好用的方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function GetQueryString(name)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     var reg = new RegExp(&amp;quot;(^|&amp;amp;)&amp;quot;+ name +&amp;quot;=([^&amp;amp;]*)(&amp;amp;|$)&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     var r = window.location.search.substr(1).match(reg);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     if(r!=null)return  unescape(r[2]); return null;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// 调用方法&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;alert(GetQueryString(&amp;quot;参数名1&amp;quot;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;设置了一个全局方法，成功了，立马各个项目用起来~&lt;/p&gt;
&lt;p&gt;这次有个需求，在页面加载时去获取参数时发现怎么都获取不到，于是去看代码，发现用到了window.location.search，调试发现window.location.search是空字符串。&lt;/p&gt;
    
    </summary>
    
    
      <category term="window.location" scheme="http://html-js.site/tags/window-location/"/>
    
      <category term="search" scheme="http://html-js.site/tags/search/"/>
    
      <category term="hash" scheme="http://html-js.site/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>mobile reset.css</title>
    <link href="http://html-js.site/2016/06/08/mobile-reset-css/"/>
    <id>http://html-js.site/2016/06/08/mobile-reset-css/</id>
    <published>2016-06-08T07:15:32.000Z</published>
    <updated>2016-10-13T06:34:04.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>手机端页面开发有很多未知的问题，android和ios又有所不同，所以有个reset.css会避免掉很多的问题、bug</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">/* css reset author wangyang */</div><div class="line">*&#123;</div><div class="line">	cursor: pointer; //为所有dom添加手势，解决IOS下不能点击的对象上绑定点击事件失效的问题</div><div class="line">&#125;</div><div class="line">html &#123;</div><div class="line">  font-family: &quot;Helvetica Neue&quot;, Helvetica, STHeiTi, sans-serif;//设置通用字体</div><div class="line">  -webkit-text-size-adjust: 100%;//chrome字体禁止缩放</div><div class="line">  font-size: 20px;//设置初始rem基准值</div><div class="line">  overflow-y: scroll;</div><div class="line">&#125;</div><div class="line">body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;</div><div class="line">body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;</div><div class="line">td,th,caption &#123; font-size:14px; &#125;</div><div class="line">h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;</div><div class="line">address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;</div><div class="line">a,input,textarea,select,button&#123;</div><div class="line">  outline: 0;//去除外框</div><div class="line">  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);//去除聚焦时的阴影</div><div class="line">  -webkit-tap-highlight-color: transparent;</div><div class="line">&#125;</div><div class="line">a &#123;text-decoration:none;&#125; //去除下划线</div><div class="line">a:hover &#123; text-decoration:underline; &#125;</div><div class="line">a:active&#123;</div><div class="line">	outline: 0;</div><div class="line">    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);</div><div class="line">    -webkit-tap-highlight-color: transparent;</div><div class="line">&#125;</div><div class="line">img, input, button &#123; border:none; &#125;//去除边框</div><div class="line">ol,ul,li &#123; list-style:none; &#125; //去除默认圆点</div><div class="line">input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif;border-radius: 0; &#125;</div><div class="line">table &#123;</div><div class="line">	border-collapse:collapse;  //把表格边框显示为一条单独的边框</div><div class="line">	border-spacing: 0; //设置相邻单元格的边框间的距离为0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;手机端页面开发有很多未知的问题，android和ios又有所不同，所以有个reset.css会避免掉很多的问题、bug&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;34&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/* css reset author wangyang */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	cursor: pointer; //为所有dom添加手势，解决IOS下不能点击的对象上绑定点击事件失效的问题&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;html &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, STHeiTi, sans-serif;//设置通用字体&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  -webkit-text-size-adjust: 100%;//chrome字体禁止缩放&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  font-size: 20px;//设置初始rem基准值&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  overflow-y: scroll;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &amp;#123; margin:0; padding:0; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;body &amp;#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;td,th,caption &amp;#123; font-size:14px; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;h1, h2, h3, h4, h5, h6 &amp;#123; font-weight:normal; font-size:100%; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;address, caption, cite, code, dfn, em, strong, th, var &amp;#123; font-style:normal; font-weight:normal;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a,input,textarea,select,button&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  outline: 0;//去除外框&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);//去除聚焦时的阴影&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  -webkit-tap-highlight-color: transparent;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a &amp;#123;text-decoration:none;&amp;#125; //去除下划线&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a:hover &amp;#123; text-decoration:underline; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;a:active&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	outline: 0;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    -webkit-tap-highlight-color: transparent;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;img, input, button &amp;#123; border:none; &amp;#125;//去除边框&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ol,ul,li &amp;#123; list-style:none; &amp;#125; //去除默认圆点&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;input, textarea, select, button &amp;#123; font:14px Verdana,Helvetica,Arial,sans-serif;border-radius: 0; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;table &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	border-collapse:collapse;  //把表格边框显示为一条单独的边框&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	border-spacing: 0; //设置相邻单元格的边框间的距离为0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://html-js.site/tags/css/"/>
    
      <category term="reset.css" scheme="http://html-js.site/tags/reset-css/"/>
    
  </entry>
  
  <entry>
    <title>GitHub/GitLab 代码结构浏览插件-Octotree</title>
    <link href="http://html-js.site/2016/06/03/GitHub-GitLab-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E6%B5%8F%E8%A7%88%E6%8F%92%E4%BB%B6-Octotree/"/>
    <id>http://html-js.site/2016/06/03/GitHub-GitLab-代码结构浏览插件-Octotree/</id>
    <published>2016-06-03T02:50:46.000Z</published>
    <updated>2016-10-13T06:35:08.650Z</updated>
    
    <content type="html"><![CDATA[<p>Octotree 是一个浏览器扩展（Chrome，Firefox，Opera和Safari），用以显示GitHub/GitLab 代码结构(代码树)。可以非常方便的浏览项目源代码，这样不必把每个项目拉取到你的机器。浏览器浏览时就像使用IDE目录结构，也不必来回的前进后退。</p>
<p>项目地址：<a href="https://github.com/buunguyen/octotree" target="_blank" rel="external">https://github.com/buunguyen/octotree</a></p>
<p><img src="/images/page/Octotree/1.png"><br><a id="more"></a><br><img src="/images/page/Octotree/2.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Octotree 是一个浏览器扩展（Chrome，Firefox，Opera和Safari），用以显示GitHub/GitLab 代码结构(代码树)。可以非常方便的浏览项目源代码，这样不必把每个项目拉取到你的机器。浏览器浏览时就像使用IDE目录结构，也不必来回的前进后退。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/buunguyen/octotree&quot;&gt;https://github.com/buunguyen/octotree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/page/Octotree/1.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Octotree" scheme="http://html-js.site/tags/Octotree/"/>
    
  </entry>
  
  <entry>
    <title>webpack前端模块加载工具</title>
    <link href="http://html-js.site/2016/05/30/webpack%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%B7%A5%E5%85%B7/"/>
    <id>http://html-js.site/2016/05/30/webpack前端模块加载工具/</id>
    <published>2016-05-30T11:34:21.000Z</published>
    <updated>2016-10-13T06:35:28.998Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看许多React的资料，发现了大部分的项目都是用webpack行模块化管理的工具。这次也是借着写了一个React-Todos的小应用，对webPack最基本实用的功能体验了一番，顺带做个小记录。</p>
<h3 id="为什么用webpack"><a href="#为什么用webpack" class="headerlink" title="为什么用webpack"></a>为什么用webpack</h3><h3 id="CommonJs与AMD"><a href="#CommonJs与AMD" class="headerlink" title="CommonJs与AMD"></a>CommonJs与AMD</h3><p>在一开始，我们先讲一下它和以往我们所用的模块管理工具有什么不一样。在最开始的阶段，Js并没有这些模块机制，各种Js到处飞，得不到有效妥善的管理。后来前端圈开始制定规范，最耳熟能详的是CommonJs和AMD。</p>
<p>CommonJs是应用在NodeJs，是一种同步的模块机制。它的写法大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var firstModule = require(&quot;firstModule&quot;);</div><div class="line"></div><div class="line">//your code...</div><div class="line"></div><div class="line">module.export = anotherModule</div></pre></td></tr></table></figure></p>
<p>AMD的应用场景则是浏览器，异步加载的模块机制。require.js的写法大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">define([&apos;firstModule&apos;], function(module)&#123;</div><div class="line"></div><div class="line">  //your code...</div><div class="line">  return anotherModule</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>其实我们单比较写法，就知道CommonJs是更为优秀的。它是一种同步的写法，对Human友好，而且代码也不会繁琐臃肿。但更重要的原因是， 随着npm成为主流的JavaScript组件发布平台，越来越多的前端项目也依赖于npm上的项目，或者自身就会发布到npm平台。 所以我们对如何可以使用npm包中的模块是我们的一大需求。所以browserify工具就出现了，它支持我们直接使用 require() 的同步语法去加载npm模块。</p>
<p>当然我们这里不得不说的是，ES2015（ES6）里也有了自己的模块机制，也就是说ES6的模块机制是官方规定的，我们通过 <a href="https://babeljs.io/" rel="external" target="_blank">babel</a> （一种6to5的编译器）可以使用比较多的新特性了，包括我们提到的模块机制，而它的写法大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import &#123;someModule&#125; from &quot;someModule&quot;;</div><div class="line"></div><div class="line">// your codes...</div><div class="line"></div><div class="line">export anotherModule;</div></pre></td></tr></table></figure></p>
<p>当然上面的写法只是最基本的，还有其他的不同加载模块的写法，可以看一下阮一峰老师的 <a href="http://es6.ruanyifeng.com/#docs/class" rel="external" target="_blank">ECMAScript 6 入门</a> 或者babel的相关文档 <a href="https://babeljs.io/docs/learn-es2015/#modules" rel="external" target="_blank">Learn ES2015</a> 。</p>
<h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><h4 id="browserify的出现非常棒，但webpack更胜一筹"><a href="#browserify的出现非常棒，但webpack更胜一筹" class="headerlink" title="browserify的出现非常棒，但webpack更胜一筹"></a>browserify的出现非常棒，但webpack更胜一筹</h4><p>我们来看看webpack支持哪些功能特性：</p>
<ul>
<li>支持CommonJs和AMD模块，意思也就是我们基本可以无痛迁移旧项目。</li>
<li>支持模块加载器和插件机制，可对模块灵活定制。特别是我最爱的babel-loader，有效支持ES6。</li>
<li>可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。</li>
<li>将样式文件和图片等静态资源也可视为模块进行打包。配合loader加载器，可以支持sass，less等CSS预处理器。</li>
<li>内置有source map，即使打包在一起依旧方便调试。</li>
</ul>
<p>看完上面这些，可以想象它就是一个前端工具，可以让我们进行各种模块加载，预处理后，再打包。之前我们对这些的处理是放在grunt或gulp等前端自动化工具中。有了webpack，我们无需借助自动化工具对模块进行各种处理，让我们工具的任务分的更加清晰。</p>
<p>我们看一下官方对webpack理解的图。<br><img src="/images/page/webpack/1.jpg"><br>任何静态资源都可以视作模块，然后模块之间也可以相互依赖，通过webpack对模块进行处理后，可以打包成我们想要的静态资源。</p>
<p>既然已经大致知道为什么我们要使用webpack了，我们接下来就开始使用webpack吧！</p>
<h3 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h3><p>首先新建一个webpack101的项目，我们将在webpack101这里开展我们接下来的各项学习<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ npm init // 用于初始化项目的package.json</div><div class="line"></div><div class="line">//初始化文件目录：</div><div class="line">webpack101</div><div class="line">  --- src</div><div class="line">    --- entry.js</div><div class="line">    --- module1.js</div><div class="line">  --- index.html</div><div class="line">  --- package.json</div><div class="line">  --- webpack.config.js</div></pre></td></tr></table></figure></p>
<h3 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h3><p>我们通过npm来将webpack安装到全局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install webpack -g</div></pre></td></tr></table></figure></p>
<h3 id="一个最简单的webpack"><a href="#一个最简单的webpack" class="headerlink" title="一个最简单的webpack"></a>一个最简单的webpack</h3><h4 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h4><p>webpack是需要进行配置的，我们在使用webpack的时候，会默认 webpack.config.js 为我们的配置文件。所以接下来，我们新建这个js文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line">var path = require(&quot;path&quot;);</div><div class="line">module.exports = &#123;</div><div class="line">  entry: &apos;../src/entry.js&apos;, //演示单入口文件</div><div class="line">  output: &#123;</div><div class="line">    path: path.join(__dirname, &apos;out&apos;),  //打包输出的路径</div><div class="line">    filename: &apos;bundle.js&apos;,			  //打包后的名字</div><div class="line">    publicPath: &quot;./out/&quot;				//html引用路径，在这里是本地地址。</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="编写入口文件"><a href="#编写入口文件" class="headerlink" title="编写入口文件"></a>编写入口文件</h3><p>接下来就编写我们的入口文件 entry.js 和第一个模块文件 module1.js 。我们一切从简，里面只用来加载一个Js模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// entry.js</div><div class="line">require(&quot;./module1&quot;); // 使用CommonJs来加载模块</div></pre></td></tr></table></figure></p>
<p>下一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// module1.js</div><div class="line">console.log(&quot;Hello Webpack!&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="启动webpack"><a href="#启动webpack" class="headerlink" title="启动webpack"></a>启动webpack</h3><p>一切准备好后，我们仅需要在项目根目录下，用命令行 webpack 执行一下即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// webpack 命令行的几种基本命令</div><div class="line"></div><div class="line">$ webpack // 最基本的启动webpack方法</div><div class="line">$ webpack -w // 提供watch方法，实时进行打包更新</div><div class="line">$ webpack -p // 对打包后的文件进行压缩，提供production</div><div class="line">$ webpack -d // 提供source map，方便调试。</div></pre></td></tr></table></figure></p>
<p>webpack成功运行后，我们就可以看到根目录出现了out文件夹，里面有我们打包生成的 bundle.js 。我们最后通过在 index.html 里对这个文件引入就可以了。我们可以在控制台看到我们想要的结果， <b>Hello Webpack !</b></p>
<h3 id="多模块依赖"><a href="#多模块依赖" class="headerlink" title="多模块依赖"></a>多模块依赖</h3><p>刚才的例子，我们仅仅是跑通了webpack通过 entry.js 入口文件进行打包的例子。下面我们就来看一下它是否真的支持CommonJs和AMD两种模块机制呢？下面我们新建多几个js文件吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 修改module1.js</div><div class="line">require([&quot;./module3&quot;], function()&#123;</div><div class="line">  console.log(&quot;Hello Webpack!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>下一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// module2.js，使用的是CommonJs机制导出包</div><div class="line">module.exports = function(a, b)&#123;</div><div class="line">  return a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// module3.js，使用AMD模块机制</div><div class="line">define([&apos;./module2.js&apos;], function(sum)&#123;</div><div class="line">  return console.log(&quot;1 + 2 = &quot; + sum(1, 2));</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>其实像上面这样混用两种不同机制非常不好，这里仅仅是展示用的，在开发新项目时还是推荐CommonJs或ES2015的Module。当然我个人更倾向于ES2015的模块机制的～</p>
<h3 id="loader加载器"><a href="#loader加载器" class="headerlink" title="loader加载器"></a>loader加载器</h3><p>到了我最喜欢也是最激动人心的功能了！我们先想想应用场景，前端社区有许多预处理器供我们使用。我们可以使用这些预处理器做一些强大的事情，大家都听过的就是 CoffeeScript 和 Sass 了。我们以前要编译这些预处理器，就是用 gulp 进行编译。但是我们对这些文件处理其实也挺繁琐的，webpack可以一次性解决！</p>
<p>在这里我们用Sass和babel编译ES2015为例子，看一下loader是如何使用的。</p>
<h3 id="安装loader"><a href="#安装loader" class="headerlink" title="安装loader"></a>安装loader</h3><p>我们第一步就是先要安装好各个必须的loader，我们直接看看需要通过npm安装什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install style-loader css-loader url-loader babel-loader sass-loader file-loader --save-dev</div></pre></td></tr></table></figure></p>
<h3 id="配置loader"><a href="#配置loader" class="headerlink" title="配置loader"></a>配置loader</h3><p>安装完各个loader后，我们就需要配置一下我们的 webpack.config.js ，载入我们的loader。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line">module.exports = &#123;</div><div class="line">  entry: path.join(__dirname, &apos;src/entry.js&apos;),</div><div class="line">  output: &#123;</div><div class="line">    path: path.join(__dirname, &apos;out&apos;),</div><div class="line">    publicPath: &quot;./out/&quot;,</div><div class="line">    filename: &apos;bundle.js&apos;</div><div class="line">  &#125;,</div><div class="line">  // 新添加的module属性</div><div class="line">  module: &#123;</div><div class="line">    loaders: [</div><div class="line">      &#123;test: /\.js$/, loader: &quot;babel&quot;&#125;,</div><div class="line">      &#123;test: /\.css$/, loader: &quot;style!css&quot;&#125;,</div><div class="line">      &#123;test: /\.(jpg|png)$/, loader: &quot;url?limit=8192&quot;&#125;,</div><div class="line">      &#123;test: /\.scss$/, loader: &quot;style!css!sass&quot;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们主要看看module的loaders。loaders是一个数组，里面的每一个对象都用正则表达式，对应着一种配对方案。比如匹配到js后缀名就用babel-loader，匹配到scss后缀名的就先用sass，再用css，最后用style处理，不同的处理器通过 ! 分隔并串联起来。这里的loader是可以省略掉 -loader 这样的，也就是原本应该写成 style-loader!css-loader!sass-loader ，当然我们必须惜字如金，所以都去掉后面的东东。</p>
<p>我们仅仅是配置一下，已经是可以直接用ES2015和SASS去写我们的前端代码了。在此之前，我们对src文件夹里再细分成js，css，image三个文件夹，处理好分层。话不多说，赶紧试试。</p>
<h3 id="稍微复杂的webpack项目"><a href="#稍微复杂的webpack项目" class="headerlink" title="稍微复杂的webpack项目"></a>稍微复杂的webpack项目</h3><h3 id="bebel-loader"><a href="#bebel-loader" class="headerlink" title="bebel-loader"></a>bebel-loader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// js/es6-module.js</div><div class="line">class People&#123;</div><div class="line">  constructor(name)&#123;</div><div class="line">    this.name = name;</div><div class="line">  &#125;</div><div class="line">  sayhi()&#123;</div><div class="line">    console.log(`hi $&#123;this.name&#125; !`);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">exports.module = People;</div></pre></td></tr></table></figure>
<p>写好模块后，我们直接在 entry.js 入口文件中引入该模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// entry.js</div><div class="line"></div><div class="line">// javascript</div><div class="line">require(&apos;./js/module1&apos;);</div><div class="line">let People = require(&apos;./js/es6-module&apos;);</div><div class="line">let p = new People(&quot;Yika&quot;);</div><div class="line">p.sayHi();</div><div class="line"></div><div class="line">// css</div><div class="line">require(&apos;./css/main.scss&apos;);</div></pre></td></tr></table></figure></p>
<p>哈哈哈，不能再爽！这下子我们可以使用很多优秀的ES6特性去构建大型的web了</p>
<h3 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h3><p>大家或许注意到了下方的css的require，那就是用来加载Sass样式的。我们通过启动style-loader会将css代码转化到 style 标签内，我们看一下里面的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// css/main.scss</div><div class="line">html, body&#123;</div><div class="line">  background: #dfdfdf;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后我们打开 index.html 观察我们所有的结果，首先背景已经是淡灰色的，并且控制台也有我们想要的内容。我们通过查看DOM结构，可以发现 head 标签里多出了 style 标签，里面正是我们想要定制的样式</p>
<h3 id="关于对图片的打包"><a href="#关于对图片的打包" class="headerlink" title="关于对图片的打包"></a>关于对图片的打包</h3><p>我们之前也说，webpack对与静态资源来说，也是看作模块来加载的。CSS我们是已经看过了，那图片是怎么作为模块打包加载进来呢？这里我们可以想到，图片我们是用url-loader加载的。我们在css文件里的url属性，其实就是一种封装处理过require操作。当然我们还有一种方式就是直接对元素的src属性进行require赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">div.img&#123;</div><div class="line">  background: url(../image/xxx.jpg)</div><div class="line">&#125;</div><div class="line"></div><div class="line">//或者</div><div class="line">var img = document.createElement(&quot;img&quot;);</div><div class="line">img.src = require(&quot;../image/xxx.jpg&quot;);</div><div class="line">document.body.appendChild(img);</div></pre></td></tr></table></figure>
<p>上述两种方法都会对符合要求的图片进行处理。而要求就是在url-loader后面通过query参数的方式实现的，这里就是说只有不大于8kb的图片才会打包处理成Base64的图片。关于query，请看文档： <a href="http://webpack.github.io/docs/using-loaders.html#query-parameters" rel="external" target="_blank">Query parameters</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;test: /\.(jpg|png)$/, loader: &quot;url?limit=8192&quot;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="打包成多个资源文件"><a href="#打包成多个资源文件" class="headerlink" title="打包成多个资源文件"></a>打包成多个资源文件</h3><p>我们在开发多页面的站点的时候，还是需要希望能有多个资源文件的。这样我们就可以有效利用缓存提升性能，做到文件按需加载。如何写入口文件，这里就不再赘述了，我们直接看如何对 webpack.config.js 进行修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// webpack.config.js</div><div class="line"></div><div class="line">entry: &#123;</div><div class="line">  page1: &quot;entry.js&quot;,</div><div class="line">  page2: &quot;entry2.js&quot;</div><div class="line">&#125;,</div><div class="line">output: &#123;</div><div class="line">  path: path.join(__dirname, &apos;out&apos;),</div><div class="line">    publicPath: &quot;./out/&quot;,</div><div class="line">    filename: &apos;[name].js&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里重点关注两个地方，entry属性可以是一个对象，而对象名也就是key会作为下面output的filename属性的 [name] 。当然entry也可以是一个数组，更多用法都可以去webpack的 <a href="https://webpack.github.io/docs/" rel="external" target="_blank">官方文档</a> 进行查看。</p>
<p>当然webpack也考虑到公共模块的利用，我们利用插件就可以智能提取公共部分，以提供我们浏览器的缓存复用。我们只需要在 webpack.config.js 添加下面的代码即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 修改添加，webpack.config.js</div><div class="line">var webpack = require(&apos;webpack&apos;);</div><div class="line">module.exports = &#123;</div><div class="line">  // ....省略各种代码</div><div class="line">      plugins: [</div><div class="line">        new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;)</div><div class="line">      ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们做个小测试，让第二个入口文件也加载我们之前的 es6-module.js 。然后我们用webpack进行打包，就发现生成的 common.js 里是有相应代码的。我们需要手动在html上去加载 common.js ，并且是<b> 必须要最先加载</b> 。</p>
<h3 id="独立出css样式"><a href="#独立出css样式" class="headerlink" title="独立出css样式"></a>独立出css样式</h3><p>如果我们希望样式通过 <link> 引入，而不是放在 style 标签内呢，即使这样做会多一个请求。这个时候我们就要配合插件一起使用啦，我们一起来看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install extract-text-webpack-plugin --save-dev</div></pre></td></tr></table></figure></p>
<p>安装完插件就要配置 webpack.config.js 了。我们添加以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</div><div class="line">module.exports = &#123;</div><div class="line">  // ...省略各种代码</div><div class="line">  module: &#123;</div><div class="line">    loaders: [</div><div class="line">      &#123;test: /\.js$/, loader: &quot;babel&quot;&#125;,</div><div class="line">      &#123;test: /\.css$/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;)&#125;,</div><div class="line">      &#123;test: /\.(jpg|png|svg)$/, loader: &quot;url?limit=8192&quot;&#125;,</div><div class="line">      &#123;test: /\.scss$/, loader: &quot;style!css!sass&quot;&#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  plugins: [</div><div class="line">    new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;),</div><div class="line">    new ExtractTextPlugin(&quot;[name].css&quot;)</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了区分开用 <link> 链接和用 style ，我们这里以CSS后缀结尾的模块用插件。我们重点关注一下使用了ExtractTextPlugin的模块，在ExtractTextPlugin的extract方法有两个参数，第一个参数是经过编译后通过style-loader单独提取出文件来，而第二个参数就是用来编译代码的loader。</p>
<p>当然，插件也支持所有独立样式打包成一个css文件。增加多一个参数即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ExtractTextPlugin(&quot;style.css&quot;, &#123;allChunks: true&#125;)</div></pre></td></tr></table></figure></p>
<p>至于怎样加载样式是最佳实践，这个就要自己平时多思考了。多站点多样式的时候，是做到一次性打包加载呢，还是按需加载呢？我这里就建议一项，主页尽量做到最精简，毕竟决定用户存留时间。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前端社区不断发展，越来越趋向于组件化的发展。通过webpack，我们就能体验到 one component one module 的开发感觉。当然如何更好的使用webpack还是要通过不断的思考总结，才能找到最优的方案。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://webpackdoc.com/development.html" target="_blank" rel="external">http://webpackdoc.com/development.html</a><br><a href="https://github.com/webpack/worker-loader" target="_blank" rel="external">https://github.com/webpack/worker-loader</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看许多React的资料，发现了大部分的项目都是用webpack行模块化管理的工具。这次也是借着写了一个React-Todos的小应用，对webPack最基本实用的功能体验了一番，顺带做个小记录。&lt;/p&gt;
&lt;h3 id=&quot;为什么用webpack&quot;&gt;&lt;a href=&quot;#为什么用webpack&quot; class=&quot;headerlink&quot; title=&quot;为什么用webpack&quot;&gt;&lt;/a&gt;为什么用webpack&lt;/h3&gt;&lt;h3 id=&quot;CommonJs与AMD&quot;&gt;&lt;a href=&quot;#CommonJs与AMD&quot; class=&quot;headerlink&quot; title=&quot;CommonJs与AMD&quot;&gt;&lt;/a&gt;CommonJs与AMD&lt;/h3&gt;&lt;p&gt;在一开始，我们先讲一下它和以往我们所用的模块管理工具有什么不一样。在最开始的阶段，Js并没有这些模块机制，各种Js到处飞，得不到有效妥善的管理。后来前端圈开始制定规范，最耳熟能详的是CommonJs和AMD。&lt;/p&gt;
&lt;p&gt;CommonJs是应用在NodeJs，是一种同步的模块机制。它的写法大致如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var firstModule = require(&amp;quot;firstModule&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//your code...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;module.export = anotherModule&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;AMD的应用场景则是浏览器，异步加载的模块机制。require.js的写法大致如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;define([&amp;apos;firstModule&amp;apos;], function(module)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  //your code...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  return anotherModule&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
      <category term="打包工具" scheme="http://html-js.site/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大洋</title>
  
  <subtitle>专注于前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.html-js.site/"/>
  <updated>2022-10-31T07:14:51.924Z</updated>
  <id>http://blog.html-js.site/</id>
  
  <author>
    <name>大洋</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手把手教你如何配置SSL证书开启https</title>
    <link href="http://blog.html-js.site/2022/10/28/https%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
    <id>http://blog.html-js.site/2022/10/28/https证书配置教程/</id>
    <published>2022-10-28T03:31:31.000Z</published>
    <updated>2022-10-31T07:14:51.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="申请-SSL-证书"><a href="#申请-SSL-证书" class="headerlink" title="申请 SSL 证书"></a>申请 SSL 证书</h2><p><img src="/images/page/20221031/ssl2.png" alt></p><p>自2021年01月01日起，每个实名认证的阿里云主账号可以在一个自然年内，通过数字证书管理服务一次性领取20张免费DV单域名试用证书（以下简称免费证书）。获取免费证书后，您需要通过数字证书管理服务控制台提交证书申请。CA中心审核通过证书申请后，将为您签发免费证书。</p><h3 id="步骤一：领取免费证书额度"><a href="#步骤一：领取免费证书额度" class="headerlink" title="步骤一：领取免费证书额度"></a>步骤一：领取免费证书额度</h3><p>每个自然年内，您都可以使用已完成实名认证的阿里云账号，通过数字证书管理服务一次性申领20张免费证书。如果一个自然年内20张免费证书的额度已用完，您可以付费购买和免费证书同类型的证书。</p><ol><li><a href="https://common-buy.aliyun.com/?spm=a2c4g.11186623.0.0.40cf4724805YgY&amp;commodityCode=cas_dv_public_cn&amp;request=%7B%22product%22%3A%22free_product%22%7D" target="_blank" rel="noopener">访问免费证书购买页</a>。</li><li>选择您需要的购买数量，单击<strong>立即购买</strong>并完成支付。<br>阿里云账号只有在一个自然年内首次购买<strong>数量</strong>为<strong>20</strong>的<strong>DV单域名证书（免费试用）</strong>时，可以免费领取。<br>如果您的阿里云账号在当前自然年内已经领取过20张免费证书，则再次选购<strong>DV单域名证书（免费试用）</strong>时，需要支付对应的费用。</li></ol><h3 id="步骤二：提交免费证书申请"><a href="#步骤二：提交免费证书申请" class="headerlink" title="步骤二：提交免费证书申请"></a>步骤二：提交免费证书申请</h3><p>参考：<a href="https://help.aliyun.com/document_detail/156645.htm?spm=5176.smartservice_service_robot_chat_new.0.0.46493f1bVjZpqO#section-z1b-xa0-5tj" target="_blank" rel="noopener">申请免费DV单域名试用证书</a></p><h2 id="部署-SSL-证书"><a href="#部署-SSL-证书" class="headerlink" title="部署 SSL 证书"></a>部署 SSL 证书</h2><h3 id="SSL证书安装指南"><a href="#SSL证书安装指南" class="headerlink" title="SSL证书安装指南"></a>SSL证书安装指南</h3><p>参考文档：<br><a href="https://help.aliyun.com/document_detail/109827.htm?spm=a2c4g.11186623.0.0.40cf4724805YgY#concept-95505-zh" target="_blank" rel="noopener">SSL证书安装指南</a><br><a href="https://help.aliyun.com/document_detail/98575.htm?spm=a2c4g.11186623.0.0.d13b4724180SLs#task-2512206" target="_blank" rel="noopener">部署证书到阿里云产品</a></p><h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p>1、安全组添加443端口</p><h3 id="nginx配置添加ssl相关配置"><a href="#nginx配置添加ssl相关配置" class="headerlink" title="nginx配置添加ssl相关配置"></a>nginx配置添加ssl相关配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#以下属性中，以ssl开头的属性表示与证书配置有关。</span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">443</span> ssl;</span><br><span class="line">    #配置HTTPS的默认访问端口为443。</span><br><span class="line">    #如果未在此处配置HTTPS的默认访问端口，可能会造成Nginx无法启动。</span><br><span class="line">    #如果您使用Nginx 1.15.0及以上版本，请使用listen 443 ssl代替listen 443和ssl on。</span><br><span class="line">    server_name yourdomain;</span><br><span class="line">    root html;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    ssl_certificate cert/cert-file-name.pem;  </span><br><span class="line">    ssl_certificate_key cert/cert-file-name.key; </span><br><span class="line">    ssl_session_timeout <span class="number">5</span>m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    #表示使用的加密套件的类型。</span><br><span class="line">    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root html;  #Web网站程序存放目录。</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><img src="/images/page/20221031/ssl1.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;申请-SSL-证书&quot;&gt;&lt;a href=&quot;#申请-SSL-证书&quot; class=&quot;headerlink&quot; title=&quot;申请 SSL 证书&quot;&gt;&lt;/a&gt;申请 SSL 证书&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/page/20221031/ssl2.png&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何在大型代码仓库中删掉废弃的文件和 exports</title>
    <link href="http://blog.html-js.site/2022/09/07/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%A4%A7%E5%9E%8B%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E4%B8%AD%E5%88%A0%E6%8E%89%E5%BA%9F%E5%BC%83%E7%9A%84%E6%96%87%E4%BB%B6%E5%92%8C-exports/"/>
    <id>http://blog.html-js.site/2022/09/07/如何在大型代码仓库中删掉废弃的文件和-exports/</id>
    <published>2022-09-07T08:28:09.000Z</published>
    <updated>2022-09-07T08:34:48.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>CRM项目历史悠久，其中很多 文件或是 export 出去的变量 已经不再使用，非常影响维护迭代。举个例子来说，后端问你：“某某接口统计一下某接口是否还有使用？”你在项目里一搜，好家伙，还有好几处使用呢，结果那些定义或文件是从未被引入的，这就会误导你们去继续维护这个文件或接口，影响迭代效率。</p></blockquote><h2 id="unimported"><a href="#unimported" class="headerlink" title="unimported"></a>unimported</h2><p><a href="https://github.com/smeijer/unimported" target="_blank" rel="noopener">unimported</a> ： Find unused source files in javascript / typescript projects.</p><h3 id="原理解析："><a href="#原理解析：" class="headerlink" title="原理解析："></a>原理解析：</h3><p>思路1：</p><ul><li>与webpack打包类似，遍历整个项目的所有文件，找出所有的文件目录及依赖关系</li><li>找出没有被其他文件所引用的文件，就表示是unused source files</li></ul><p>思路2：</p><ul><li>与webpack打包类似，遍历整个项目的所有文件，找出所有的文件目录及依赖关系 treeA</li><li>通过入口文件 index.tsx 开始查找所有用到的文件及依赖关系 treeB</li><li>比较treeA 与 treeB，找出 unused source files</li></ul><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><img src="/images/page/2022/0927/1.png" alt></p><p>1、当前文件是否被 imported，同理 引用当前文件的文件是否 被 imported<br>2、当前文件中 import 的文件 是否需要同时被 注释/删除？<br>3、确认当前文件 及 相关联的文件都处理完成之后，决定是否需要注释/删除</p><h2 id="deadfile"><a href="#deadfile" class="headerlink" title="deadfile"></a>deadfile</h2><p><a href="https://www.npmjs.com/package/deadfile" target="_blank" rel="noopener">deadfile</a>   Simple util to find deadcode and unused files in any JavaScript project (ES5, ES6, React, Vue, …)</p><p>实际使用感受：没有正确找出 deadcode and unused files，可能是使用的姿势不对…有待研究…</p><h2 id="ts-unused-exports"><a href="#ts-unused-exports" class="headerlink" title="ts-unused-exports"></a>ts-unused-exports</h2><p><a href="https://www.npmjs.com/package/ts-unused-exports" target="_blank" rel="noopener">ts-unused-exports</a>   finds unused exported symbols in your Typescript project.</p><h2 id="no-unused-export"><a href="#no-unused-export" class="headerlink" title="no-unused-export"></a>no-unused-export</h2><p><a href="https://www.npmjs.com/package/no-unused-export" target="_blank" rel="noopener">no-unused-export</a>  A CLI tool to check whether exported things in a module is used by other modules.</p><h2 id="ts-prune"><a href="#ts-prune" class="headerlink" title="ts-prune"></a>ts-prune</h2><p><a href="https://github.com/nadeesha/ts-prune#readme" target="_blank" rel="noopener">ts-prune</a>  Find potentially unused exports in your Typescript project with zero configuration.</p><h2 id="depcheck"><a href="#depcheck" class="headerlink" title="depcheck"></a>depcheck</h2><p><a href="https://www.npmjs.com/package/depcheck" target="_blank" rel="noopener">depcheck</a> Depcheck is a tool for analyzing the dependencies in a project to see: how each dependency is used, which dependencies are useless, and which dependencies are missing from package.json.</p><h2 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h2><p>写一个工具，能够自动甄别 unused source files 并进行注释 或者 删除</p><p>参考：<a href="https://juejin.cn/post/6995371411019710500#comment" target="_blank" rel="noopener">如何在大型代码仓库中删掉 6w 行废弃的文件和 exports？</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;CRM项目历史悠久，其中很多 文件或是 export 出去的变量 已经不再使用，非常影响维护迭代。举个例子来说，后
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>应用性能-前端监控</title>
    <link href="http://blog.html-js.site/2022/08/23/%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD-%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7/"/>
    <id>http://blog.html-js.site/2022/08/23/应用性能-前端监控/</id>
    <published>2022-08-23T03:40:44.000Z</published>
    <updated>2022-08-23T03:41:31.712Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7010647775880708133" target="_blank" rel="noopener">应用性能前端监控，字节跳动这些年经验都在这了</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7010647775880708133&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;应用性能前端监控，字节跳动这些年经验都在这了&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://blog.html-js.site/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端工程化</title>
    <link href="http://blog.html-js.site/2022/08/18/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://blog.html-js.site/2022/08/18/浅谈前端工程化/</id>
    <published>2022-08-18T08:07:58.000Z</published>
    <updated>2022-08-19T02:24:34.489Z</updated>
    
    <content type="html"><![CDATA[<p>前端工程化每个人都有不一样的理解，也没有一个权威和标准的定义，只要我们清楚为什么要工程化和工程化的意义那么具体的定义就变得不那么重要了。</p><p><img src="/images/page/20220818/1.jpeg" alt></p><p>首先前端工程化是把软件工程相关的方法和思想应用到前端开发中。</p><p><strong>狭义上的理解</strong>：将开发阶段的代码发布到生产环境，包含：构建，分支管理，自动化测试，部署</p><p><strong>广义上理解</strong>：前端工程化应该包含从编码开始到发布，运行和维护阶段</p><p>也有人把 <strong>前端工程化</strong> 等同于 <strong>效率工程</strong></p><p>认为一切能提升前端开发效率、提高前端应用质量的方法和工具都是前端工程化，我觉得这么理解也是没有问题的，提升开发效率、提升产品质量、降低开发难度、降低企业成本应该是工程化的意义所在。</p><a id="more"></a><p><img src="/images/page/20220818/2.jpeg" alt></p><p>另外一个就是前端工程化不是具体的某项技术和方法，公司的组织架构、产品形态、所处的阶段不同可能工程化具体的方法和实践完全不一样，那么从我的角度，简单把工程化划分了5部分：开发、构建、部署、性能、规范化， 对于分类和具体包含的项或许你不一定认同，但是如果所有的知识点你都很熟悉和掌握，那么你的前端工程化水平绝对是中高级的。</p><p><img src="/images/page/20220818/3.jpeg" alt></p><p><img src="/images/page/20220818/4.jpeg" alt></p><p><img src="/images/page/20220818/5.jpeg" alt></p><p>那么再次回到什么是前端工程化？</p><p>只要我们引入的方法、技术方案、工具可以提升开发效率、提高前端应用质量，那么都属于前端工程化，上面我列举的一些分类和项并不能完全把前端工程化内容都包含。</p><p>回到前端构建中，目前引入构建工具绝对是前端工程化的起点，大家基本都是采用 Hash 增量更新，增量更新后缓存策略就可以选择强制缓存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端工程化每个人都有不一样的理解，也没有一个权威和标准的定义，只要我们清楚为什么要工程化和工程化的意义那么具体的定义就变得不那么重要了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/page/20220818/1.jpeg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;首先前端工程化是把软件工程相关的方法和思想应用到前端开发中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;狭义上的理解&lt;/strong&gt;：将开发阶段的代码发布到生产环境，包含：构建，分支管理，自动化测试，部署&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;广义上理解&lt;/strong&gt;：前端工程化应该包含从编码开始到发布，运行和维护阶段&lt;/p&gt;
&lt;p&gt;也有人把 &lt;strong&gt;前端工程化&lt;/strong&gt; 等同于 &lt;strong&gt;效率工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;认为一切能提升前端开发效率、提高前端应用质量的方法和工具都是前端工程化，我觉得这么理解也是没有问题的，提升开发效率、提升产品质量、降低开发难度、降低企业成本应该是工程化的意义所在。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://blog.html-js.site/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JS数据&amp;对象遍历</title>
    <link href="http://blog.html-js.site/2022/08/18/JS%E6%95%B0%E6%8D%AE-%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86/"/>
    <id>http://blog.html-js.site/2022/08/18/JS数据-对象遍历/</id>
    <published>2022-08-18T06:24:29.000Z</published>
    <updated>2022-08-19T03:07:10.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS数组遍历"><a href="#JS数组遍历" class="headerlink" title="JS数组遍历"></a>JS数组遍历</h3><p>JS的数组的遍历方式有很多，每个的功能又不尽相同，因此想好好地整理一下它们之间的区别。这里只列举数组自带的API，主要有forEach、filter、map、reduce、some、every.</p><h4 id="1-循环遍历"><a href="#1-循环遍历" class="headerlink" title="1.循环遍历"></a>1.循环遍历</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  onsole.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-for-of-方法"><a href="#2-for-of-方法" class="headerlink" title="2.for of 方法"></a>2.for of 方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  item 遍历的数组的元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-forEach"><a href="#3-forEach" class="headerlink" title="3.forEach"></a>3.forEach</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,self</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(element);</span><br><span class="line">  item 遍历出的每一个元素</span><br><span class="line">  index 元素对应的下标</span><br><span class="line">  self 数组本身</span><br><span class="line">  无返回值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>forEach几乎是最常用的遍历数组的方法了，forEach()被调用时不会直接改变原数组，没有返回值，也无法终止或者跳出。</p><h4 id="4-map"><a href="#4-map" class="headerlink" title="4.map"></a>4.map</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> arrMap = arr.map(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element)</span><br><span class="line">    <span class="keyword">return</span> element * <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(arrMap);</span><br></pre></td></tr></table></figure><p>map和forEach类似，被调用时不修改数组本身，但是会返回一个新数组。</p><h4 id="5-filter"><a href="#5-filter" class="headerlink" title="5.filter"></a>5.filter</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> arrFilter = arr.filter(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> element &gt; <span class="number">3</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arrFilter);</span><br></pre></td></tr></table></figure><p>filter顾名思义就是过滤，因此数组的filter用来筛选符合条件的值。filter 不会直接改变原数组，它返回过滤后的新数组。</p><h4 id="6-reduce"><a href="#6-reduce" class="headerlink" title="6.reduce"></a>6.reduce</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> arrReduce = arr.reduce(<span class="function">(<span class="params">accumulator, currentValue, currentIndex, array</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"accumulator:"</span>+accumulator);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"currentValue:"</span>+currentValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"currentIndex:"</span>+currentIndex);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"array:"</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(array);</span><br><span class="line">    <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"arrReduce:"</span>+arrReduce);</span><br></pre></td></tr></table></figure><p>reduce和前面的3个循环不同，它的参数里有一个累加器的概念，并且有没有initialValue执行的次数也会有差别。为此整理了一个reduce的执行记录。<br>首先是没有initialValue的情况：<br><img src="/images/page/2022/0819/1.png" alt></p><p>如果有initialValue，那如上的函数这样改写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> arrReduce = arr.reduce(<span class="function">(<span class="params">accumulator, currentValue, currentIndex, array</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"accumulator:"</span>+accumulator);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"currentValue:"</span>+currentValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"currentIndex:"</span>+currentIndex);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"array:"</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(array);</span><br><span class="line">    <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"arrReduce:"</span>+arrReduce);</span><br></pre></td></tr></table></figure><p><img src="/images/page/2022/0819/2.png" alt></p><p>理解了reduce的执行过程就知道reduce的具体功用是什么了，MDN官方给出了如下几个场景:求和、计算单元素次数、按顺序执行promise、功能性管道等。</p><h4 id="7-some"><a href="#7-some" class="headerlink" title="7.some"></a>7.some</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> arrSome = arr.some(<span class="function">(<span class="params">element,index,array</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> element&gt;<span class="number">4</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arrSome);</span><br></pre></td></tr></table></figure><p>some遍历数组找寻符合条件的，找到了返回true，遍历完毕没有找到返回false。</p><h4 id="8-every"><a href="#8-every" class="headerlink" title="8.every"></a>8.every</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> arrEvery = arr.every(<span class="function">(<span class="params">element,index,array</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> element&lt;<span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arrEvery);</span><br></pre></td></tr></table></figure><p>every遍历数组检查符合条件的，有不符合立即返回false，遍历完毕全符合才返回true。</p><p>以上所列举的方法都不会改变原数组，遍历范围在第一次执行之后就已经确定，在callback中如果改变了数组，也不会生效。每一个API背后的运用场景MDN上都有详细的举例，如果想要有更高阶的运用就需要工作积累了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JS数组遍历&quot;&gt;&lt;a href=&quot;#JS数组遍历&quot; class=&quot;headerlink&quot; title=&quot;JS数组遍历&quot;&gt;&lt;/a&gt;JS数组遍历&lt;/h3&gt;&lt;p&gt;JS的数组的遍历方式有很多，每个的功能又不尽相同，因此想好好地整理一下它们之间的区别。这里只列举数组自带的A
      
    
    </summary>
    
    
      <category term="js" scheme="http://blog.html-js.site/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>JS高阶编程</title>
    <link href="http://blog.html-js.site/2022/03/22/JS%E9%AB%98%E9%98%B6%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.html-js.site/2022/03/22/JS高阶编程/</id>
    <published>2022-03-22T09:50:34.000Z</published>
    <updated>2022-08-19T02:24:34.478Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>微前端 乾坤</title>
    <link href="http://blog.html-js.site/2022/03/06/%E5%BE%AE%E5%89%8D%E7%AB%AF-%E4%B9%BE%E5%9D%A4/"/>
    <id>http://blog.html-js.site/2022/03/06/微前端-乾坤/</id>
    <published>2022-03-06T08:06:09.000Z</published>
    <updated>2022-08-19T02:24:34.488Z</updated>
    
    <content type="html"><![CDATA[<p>微前端 乾坤 </p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p><a href="https://qiankun.umijs.org/zh/guide/getting-started" target="_blank" rel="noopener">乾坤官网</a></p><h3 id="registerMicroApps源码"><a href="#registerMicroApps源码" class="headerlink" title="registerMicroApps源码"></a>registerMicroApps源码</h3><h3 id="loadMicroApp源码"><a href="#loadMicroApp源码" class="headerlink" title="loadMicroApp源码"></a>loadMicroApp源码</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微前端 乾坤 &lt;/p&gt;
&lt;h3 id=&quot;原理：&quot;&gt;&lt;a href=&quot;#原理：&quot; class=&quot;headerlink&quot; title=&quot;原理：&quot;&gt;&lt;/a&gt;原理：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://qiankun.umijs.org/zh/guide/getting
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Ts高手篇：22个示例深入讲解Ts最晦涩难懂的高级类型工具</title>
    <link href="http://blog.html-js.site/2022/02/25/Ts%E9%AB%98%E6%89%8B%E7%AF%87%EF%BC%9A22%E4%B8%AA%E7%A4%BA%E4%BE%8B%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3Ts%E6%9C%80%E6%99%A6%E6%B6%A9%E9%9A%BE%E6%87%82%E7%9A%84%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/"/>
    <id>http://blog.html-js.site/2022/02/25/Ts高手篇：22个示例深入讲解Ts最晦涩难懂的高级类型工具/</id>
    <published>2022-02-25T04:32:06.000Z</published>
    <updated>2022-08-19T02:24:34.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文基本分为三部分："><a href="#本文基本分为三部分：" class="headerlink" title="本文基本分为三部分："></a>本文基本分为三部分：</h2><p>第一部分讲解一些基本的关键词的特性（比如索引查询、索引访问、映射、extends等），但是该部分更多的讲解小伙伴们不清晰的一些特性，而基本功能则不再赘述。更多的关键词及技巧将包含在后续的例子演示中再具体讲述；</p><p>第二部分讲解Ts内置的类型工具以及实现原理，比如Pick、Omit等；</p><p>第三部分讲解自定义的工具类型，该部分也是最难的部分，将通过一些复杂的类型工具示例进行逐步剖析，对于其中的晦涩的地方以及涉及的知识点逐步讲解。此部分也会包含大量Ts类型工具的编程技巧，也希望通过此部分的讲解，小伙伴的Ts功底可以进一步提升！</p><h2 id="第一部分-前置内容"><a href="#第一部分-前置内容" class="headerlink" title="第一部分 前置内容"></a>第一部分 前置内容</h2><ul><li><code>keyof</code> 索引查询</li></ul><p>对应任何类型<code>T</code>,<code>keyof T</code>的结果为该类型上所有共有属性key的联合：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Eg1 &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  readonly age: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// T1的类型实则是name | age</span></span><br><span class="line"><span class="keyword">type</span> T1 = keyof Eg1</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Eg2 &#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> readonly age: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">protected</span> home: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// T2实则被约束为 age</span></span><br><span class="line"><span class="comment">// 而name和home不是公有属性，所以不能被keyof获取到</span></span><br><span class="line"><span class="keyword">type</span> T2 = keyof Eg2</span><br></pre></td></tr></table></figure><ul><li><code>T[K]</code> 索引访问</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Eg1 &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  readonly age: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> V1 = Eg1[<span class="string">'name'</span>]</span><br><span class="line"><span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> V2 = Eg1[<span class="string">'name'</span> | <span class="string">'age'</span>]</span><br><span class="line"><span class="comment">// any</span></span><br><span class="line"><span class="keyword">type</span> V2 = Eg1[<span class="string">'name'</span> | <span class="string">'age2222'</span>]</span><br><span class="line"><span class="comment">// string | number</span></span><br><span class="line"><span class="keyword">type</span> V3 = Eg1[keyof Eg1]</span><br></pre></td></tr></table></figure><p><code>T[keyof T]</code>的方式，可以获取到T所有key的类型组成的联合类型；<br><code>T[keyof K]</code>的方式，获取到的是T中的key且同时存在于K时的类型组成的联合类型；<br>注意：如果[]中的key有不存在T中的，则是any；因为ts也不知道该key最终是什么类型，所以是any；且也会报错；</p><ul><li><code>&amp;</code> 交叉类型注意点<br>交叉类型取的多个类型的并集，但是如果相同<code>key</code>但是类型不同，则该<code>key</code>为<code>never</code>。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Eg1 &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Eg2 &#123;</span><br><span class="line">  color: <span class="built_in">string</span>,</span><br><span class="line">  age: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * T的类型为 &#123;name: string; age: number; age: never&#125;</span></span><br><span class="line"><span class="comment"> * 注意，age因为Eg1和Eg2中的类型不一致，所以交叉后age的类型是never</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> T = Eg1 &amp; Eg2</span><br><span class="line"><span class="comment">// 可通过如下示例验证</span></span><br><span class="line"><span class="keyword">const</span> val: T = &#123;</span><br><span class="line">  name: <span class="string">''</span>,</span><br><span class="line">  color: <span class="string">''</span>,</span><br><span class="line">  age: (<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125;)(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extends关键词特性（重点）"><a href="#extends关键词特性（重点）" class="headerlink" title="extends关键词特性（重点）"></a>extends关键词特性（重点）</h3><ul><li>用于接口，表示继承</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> T1 &#123;</span><br><span class="line">  name: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> T2 &#123;</span><br><span class="line">  sex: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * T3 = &#123;name: string, sex: number, age: number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> T3 <span class="keyword">extends</span> T1, T2 &#123;</span><br><span class="line">  age: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，接口支持多重继承，语法为逗号隔开。如果是type实现继承，则可以使用交叉类型<code>type A = B &amp; C &amp; D</code>。</p><ul><li>表示条件类型，可用于条件判断<br>表示条件判断，如果前面的条件满足，则返回问号后的第一个参数，否则第二个。类似于js的三元运算。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type A1 = 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> A1 = <span class="string">'x'</span> <span class="keyword">extends</span> <span class="string">'x'</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type A2 = 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> A2 = <span class="string">'x'</span> | <span class="string">'y'</span> <span class="keyword">extends</span> <span class="string">'x'</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type A3 = 1 | 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> P&lt;T&gt; = T <span class="keyword">extends</span> <span class="string">'x'</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"><span class="keyword">type</span> A3 = P&lt;<span class="string">'x'</span> | <span class="string">'y'</span>&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>提问：为什么A2和A3的值不一样？</strong></p><ul><li>如果用于简单的条件判断，则是直接判断前面的类型是否可分配给后面的类型</li><li>若extends前面的类型是泛型，且泛型传入的是联合类型时，则会依次判断该联合类型的所有子类型是否可分配给extends后面的类型（是一个分发的过程）。</li></ul><p><strong>总结，就是extends前面的参数为联合类型时则会分解（依次遍历所有的子类型进行条件判断）联合类型进行判断。然后将最终的结果组成新的联合类型。</strong></p><p><strong>阻止extends关键词对于联合类型的分发特性</strong><br>如果不想被分解（分发），做法也很简单，可以通过简单的元组类型包裹以下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P&lt;T&gt; = [T] <span class="keyword">extends</span> [<span class="string">'x'</span>] ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type A4 = 2;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> A4 = P&lt;<span class="string">'x'</span> | <span class="string">'y'</span>&gt;</span><br></pre></td></tr></table></figure><p><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types" target="_blank" rel="noopener">条件类型的分布式特性文档</a></p><h3 id="类型兼容性-重要！重要！重要"><a href="#类型兼容性-重要！重要！重要" class="headerlink" title="类型兼容性 重要！重要！重要"></a>类型兼容性 重要！重要！重要</h3><blockquote><p>集合论中，如果一个集合的所有元素在集合B中都存在，则A是B的子集；<br>类型系统中，如果一个类型的属性更具体，则该类型是子类型。（因为属性更少则说明该类型约束的更宽泛，是父类型）</p></blockquote><p><strong>因此，我们可以得出基本的结论：子类型比父类型更加具体,父类型比子类型更宽泛。</strong> 下面我们也将基于类型的可复制性（可分配性）、协变、逆变、双向协变等进行进一步的讲解。</p><ul><li>可赋值性</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">break</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal;</span><br><span class="line"><span class="keyword">let</span> b: Dog;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以赋值，子类型更佳具体，可以赋值给更佳宽泛的父类型</span></span><br><span class="line">a = b;</span><br><span class="line"><span class="comment">// 反过来不行</span></span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure><ul><li>可赋值性在联合类型中的特性</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line"><span class="keyword">type</span> B = <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> a: A;</span><br><span class="line"><span class="keyword">let</span> b: B;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可赋值</span></span><br><span class="line">b = a;</span><br><span class="line"><span class="comment">// 可以赋值</span></span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><p>是不是A的类型更多，A就是子类型呢？恰恰相反，A此处类型更多但是其表达的类型更宽泛，所以A是父类型，B是子类型。</p><p>因此b = a不成立（父类型不能赋值给子类型），而a = b成立（子类型可以赋值给父类型）</p><ul><li>协变</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">break</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Eg1: Animal;</span><br><span class="line"><span class="keyword">let</span> Eg2: Dog;</span><br><span class="line"><span class="comment">// 兼容，可以赋值</span></span><br><span class="line">Eg1 = Eg2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Eg3: <span class="built_in">Array</span>&lt;Animal&gt;</span><br><span class="line"><span class="keyword">let</span> Eg4: <span class="built_in">Array</span>&lt;Dog&gt;</span><br><span class="line"><span class="comment">// 兼容，可以赋值</span></span><br><span class="line">Eg3 = Eg4</span><br></pre></td></tr></table></figure><p>通过Eg3和Eg4来看，在Animal和Dog在变成数组后，Array<dog>依旧可以赋值给Array<animal>，因此对于type MakeArray = Array<any>来说就是协变的。</any></animal></dog></p><p>最后引用维基百科中的定义：</p><blockquote><p>协变与逆变(Covariance and contravariance )是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p></blockquote><p>简单说就是，具有父子关系的多个类型，在通过某种构造关系构造成的新的类型，如果还具有父子关系则是协变的，而关系逆转了（子变父，父变子）就是逆变的。可能听起来有些抽象，下面我们将用更具体的例子进行演示说明：</p><ul><li>逆变</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">  <span class="keyword">break</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AnimalFn = <span class="function">(<span class="params">arg: Animal</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">type</span> DogFn = <span class="function">(<span class="params">arg: Dog</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Eg1: AnimalFn;</span><br><span class="line"><span class="keyword">let</span> Eg2: DogFn;</span><br><span class="line"><span class="comment">// 不再可以赋值了，</span></span><br><span class="line"><span class="comment">// AnimalFn = DogFn不可以赋值了, Animal = Dog是可以的</span></span><br><span class="line">Eg1 = Eg2;</span><br><span class="line"><span class="comment">// 反过来可以</span></span><br><span class="line">Eg2 = Eg1;</span><br></pre></td></tr></table></figure><p>理论上，<code>Animal = Dog</code>是类型安全的，那么<code>AnimalFn = DogFn</code>也应该类型安全才对，为什么Ts认为不安全呢？看下面的例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> animal: AnimalFn = <span class="function">(<span class="params">arg: Animal</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> dog: DogFn = <span class="function">(<span class="params">arg: Dog</span>) =&gt;</span> &#123;</span><br><span class="line">  arg.break();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设类型安全可以赋值</span></span><br><span class="line">animal = dog;</span><br><span class="line"><span class="comment">// 那么animal在调用时约束的参数，缺少dog所需的参数，此时会导致错误</span></span><br><span class="line">animal(&#123;name: <span class="string">'cat'</span>&#125;);</span><br></pre></td></tr></table></figure><p>从这个例子看到，如果dog函数赋值给animal函数，那么animal函数在调用时，约束的是参数必须要为Animal类型（而不是Dog），但是animal实际为dog的调用，此时就会出现错误。<br>因此，<code>Animal</code>和<code>Dog</code>在进行<code>type Fn&lt;T&gt; = (arg: T) =&gt; void</code>构造器构造后，父子关系逆转了，此时成为“逆变”。</p><ul><li>双向协变</li></ul><p>Ts在函数参数的比较中实际上默认采取的策略是双向协变：只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。</p><p>这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息（典型的就是上述的逆变）。 但是实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.dom.d.ts中EventListener的接口定义</span></span><br><span class="line"><span class="keyword">interface</span> EventListener &#123;</span><br><span class="line">  (evt: Event): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简化后的Event</span></span><br><span class="line"><span class="keyword">interface</span> Event &#123;</span><br><span class="line">  readonly target: EventTarget | <span class="literal">null</span>;</span><br><span class="line">  preventDefault(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简化合并后的MouseEvent</span></span><br><span class="line"><span class="keyword">interface</span> MouseEvent <span class="keyword">extends</span> Event &#123;</span><br><span class="line">  readonly x: <span class="built_in">number</span>;</span><br><span class="line">  readonly y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化后的Window接口</span></span><br><span class="line"><span class="keyword">interface</span> Window &#123;</span><br><span class="line">  <span class="comment">// 简化后的addEventListener</span></span><br><span class="line">  addEventListener(<span class="keyword">type</span>: <span class="built_in">string</span>, listener: EventListener)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日常使用</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'mouseover'</span>, <span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>可以看到<code>Window</code>的<code>listener</code>函数要求参数是<code>Event</code>，但是日常使用时更多时候传入的是<code>Event</code>子类型。但是这里可以正常使用，正是其默认行为是双向协变的原因。可以通过<code>tsconfig.js</code>中修改<code>strictFunctionType</code>属性来严格控制协变和逆变。</p><h4 id="infer-关键词-敲重点！！！敲重点！！！敲重点！！！"><a href="#infer-关键词-敲重点！！！敲重点！！！敲重点！！！" class="headerlink" title="infer 关键词 敲重点！！！敲重点！！！敲重点！！！"></a>infer 关键词 <strong>敲重点！！！敲重点！！！敲重点！！！</strong></h4><p><code>infer</code>关键词的功能暂时先不做太详细的说明了，主要是用于<code>extends</code>的条件类型中让Ts自己推导类型，具体的可以查阅官网。但是关于<code>infer</code>的一些容易让人忽略但是非常重要的特性，这里必须要提及一下：</p><ul><li><code>infer</code>推导的名称相同并且都处于逆变的位置，则推导的结果将会是交叉类型。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bar&lt;T&gt; = T <span class="keyword">extends</span> &#123;</span><br><span class="line">  a: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">  b: <span class="function">(<span class="params">x: infer U</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125; ? U : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T1 = string</span></span><br><span class="line"><span class="keyword">type</span> T1 = Bar&lt;&#123; a: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>; b: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T2 = never</span></span><br><span class="line"><span class="keyword">type</span> T2 = Bar&lt;&#123; a: <span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>; b: <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span> &#125;&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>infer</code>推导的名称相同并且都处于协变的位置，则推导的结果将会是联合类型。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo&lt;T&gt; = T <span class="keyword">extends</span> &#123;</span><br><span class="line">  a: infer U;</span><br><span class="line">  b: infer U;</span><br><span class="line">&#125; ? U : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T1 = string</span></span><br><span class="line"><span class="keyword">type</span> T1 = Foo&lt;&#123; a: <span class="built_in">string</span>; b: <span class="built_in">string</span> &#125;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type T2 = string | number</span></span><br><span class="line"><span class="keyword">type</span> T2 = Foo&lt;&#123; a: <span class="built_in">string</span>; b: <span class="built_in">number</span> &#125;&gt;;</span><br></pre></td></tr></table></figure><p><a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html#type-inference-in-conditional-types" target="_blank" rel="noopener">inter与协变逆变的参考文档点击这里</a></p><h2 id="第二部分-Ts内置类型工具原理解析"><a href="#第二部分-Ts内置类型工具原理解析" class="headerlink" title="第二部分 Ts内置类型工具原理解析"></a>第二部分 Ts内置类型工具原理解析</h2><h3 id="Partial实现原理解析"><a href="#Partial实现原理解析" class="headerlink" title="Partial实现原理解析"></a>Partial实现原理解析</h3><p><code>Partial&lt;T&gt;</code>将<code>T</code>的所有属性变成可选的。<br><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心实现就是通过映射类型遍历T上所有的属性，</span></span><br><span class="line"><span class="comment"> * 然后将每个属性设置为可选属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>[P in keyof T]</code>通过映射类型，遍历T上的所有属性</li><li><code>?:</code>设置为属性为可选的</li><li><code>T[P]</code>设置类型为原来的类型</li></ul><p>扩展一下，将制定的key变成可选类型:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要通过K extends keyof T约束K必须为keyof T的子类型</span></span><br><span class="line"><span class="comment"> * keyof T得到的是T的所有key组成的联合类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> PartialOptional&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]?: T[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> *     type Eg1 = &#123; key1?: string; key2?: number &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg1 = PartialOptional&lt;&#123;</span><br><span class="line">  key1: <span class="built_in">string</span>,</span><br><span class="line">  key2: <span class="built_in">number</span>,</span><br><span class="line">  key3: <span class="string">''</span></span><br><span class="line">&#125;, <span class="string">'key1'</span> | <span class="string">'key2'</span>&gt;;</span><br></pre></td></tr></table></figure><h3 id="Readonly原理解析"><a href="#Readonly原理解析" class="headerlink" title="Readonly原理解析"></a>Readonly原理解析</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要实现是通过映射遍历所有key，</span></span><br><span class="line"><span class="comment"> * 然后给每个key增加一个readonly修饰符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">  readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg = &#123;</span></span><br><span class="line"><span class="comment"> *   readonly key1: string;</span></span><br><span class="line"><span class="comment"> *   readonly key2: number;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg = Readonly&lt;&#123;</span><br><span class="line">  key1: <span class="built_in">string</span>,</span><br><span class="line">  key2: <span class="built_in">number</span>,</span><br><span class="line">&#125;&gt;</span><br></pre></td></tr></table></figure><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a>Pick</h3><p>挑选一组属性并组成一个新的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h3><p>构造一个<code>type</code>，<code>key</code>为联合类型中的每个子类型，类型为<code>T</code>。文字不好理解，先看例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg1 = &#123;</span></span><br><span class="line"><span class="comment"> *   a: &#123; key1: string; &#125;;</span></span><br><span class="line"><span class="comment"> *   b: &#123; key1: string; &#125;;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * @desc 就是遍历第一个参数'a' | 'b'的每个子类型，然后将值设置为第二参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg1 = Record&lt;<span class="string">'a'</span> | <span class="string">'b'</span>, &#123;key1: <span class="built_in">string</span>&#125;&gt;</span><br></pre></td></tr></table></figure><p>Record具体实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心实现就是遍历K，将值设置为T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> K]: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg2 = &#123;a: B, b: B&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  a: <span class="built_in">string</span>,</span><br><span class="line">  b: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  key1: <span class="built_in">number</span>,</span><br><span class="line">  key2: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Eg2 = Record&lt;keyof A, B&gt;</span><br></pre></td></tr></table></figure><ul><li>值得注意的是<code>keyof any</code>得到的是<code>string | number | symbol</code></li><li>原因在于类型<code>key</code>的类型只能为<code>string | number | symbol</code></li></ul><h3 id="扩展-同态与非同态。划重点！！！-划重点！！！-划重点！！！"><a href="#扩展-同态与非同态。划重点！！！-划重点！！！-划重点！！！" class="headerlink" title="扩展: 同态与非同态。划重点！！！ 划重点！！！ 划重点！！！"></a>扩展: 同态与非同态。划重点！！！ 划重点！！！ 划重点！！！</h3><ul><li>Partial、Readonly和Pick都属于同态的，即其实现需要输入类型T来拷贝属性，因此属性修饰符（例如readonly、?:）都会被拷贝。可从下面例子验证：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg = &#123;readonly a?: string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg = Pick&lt;&#123;readonly a?: <span class="built_in">string</span>&#125;, <span class="string">'a'</span>&gt;</span><br></pre></td></tr></table></figure><p>从Eg的结果可以看到，<code>Pick</code>在拷贝属性时，连带拷贝了<code>readonly</code>和<code>?:</code>的修饰符。</p><ul><li><code>Record</code>是非同态的，不需要拷贝属性，因此不会拷贝属性修饰符</li></ul><p>可以看到<code>Pick</code>的实现中，注意<code>P in K</code>（本质是<code>P in keyof T</code>），<code>T</code>为输入的类型，而<code>keyof T</code>则遍历了输入类型；而<code>Record</code>的实现中，并没有遍历所有输入的类型，<code>K</code>只是约束为<code>keyof any</code>的子类型即可。<br>最后再类比一下<code>Pick</code>、<code>Partial</code>、<code>readonly</code>这几个类型工具，无一例外，都是使用到了<code>keyof T</code>来辅助拷贝传入类型的属性。</p><h3 id="Exclude原理解析"><a href="#Exclude原理解析" class="headerlink" title="Exclude原理解析"></a>Exclude原理解析</h3><p>Exclude&lt;T, U&gt;提取存在于T，但不存在于U的类型组成的联合类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 遍历T中的所有子类型，如果该子类型约束于U（存在于U、兼容于U），</span></span><br><span class="line"><span class="comment"> * 则返回never类型，否则返回该子类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Exclude&lt;T, U&gt; = T <span class="keyword">extends</span> U ? never : T;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg = 'key1'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg = Exclude&lt;<span class="string">'key1'</span> | <span class="string">'key2'</span>, <span class="string">'key2'</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="never敲重点！！！"><a href="#never敲重点！！！" class="headerlink" title="never敲重点！！！"></a>never敲重点！！！</h4><ul><li>never表示一个不存在的类型</li><li>never与其他类型的联合后，是没有never的</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg2 = string | number</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg2 = <span class="built_in">string</span> | <span class="built_in">number</span> | never</span><br></pre></td></tr></table></figure><p>因此上述<code>Eg</code>其实就等于<code>key1 | never</code>,也就是<code>type Eg = key1</code></p><h3 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h3><p>Extract&lt;T, U&gt;提取联合类型T和联合类型U的所有交集。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Extract&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> *  type Eg = 'key1'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg = Extract&lt;<span class="string">'key1'</span> | <span class="string">'key2'</span>, <span class="string">'key1'</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="Omit原理解析"><a href="#Omit原理解析" class="headerlink" title="Omit原理解析"></a>Omit原理解析</h3><p><code>Omit&lt;T, K&gt;</code>从类型T中剔除K中的所有属性。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用Pick实现Omit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Omit = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br></pre></td></tr></table></figure><ul><li>换种思路想一下，其实现可以是利用<code>Pick</code>提取我们需要的<code>keys</code>组成的类型</li><li>因此也就是 <code>Omit = Pick&lt;T, 我们需要的属性联合&gt;</code></li><li>而我们需要的属性联合就是，从<code>T</code>的属性联合中排出存在于联合类型K中的</li><li>因此也就是<code>Exclude&lt;keyof T, K&gt;</code>;</li></ul><p>如果不利用Pick实现呢?</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用映射类型Omit</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Omit2&lt;T, K <span class="keyword">extends</span> keyof <span class="built_in">any</span>&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> Exclude&lt;keyof T, K&gt;]: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实现类似于<code>Pick</code>的原理实现</li><li>区别在于是遍历的我们需要的属性不一样</li><li>我们需要的属性和上面的例子一样，就是<code>Exclude&lt;keyof T, K&gt;</code></li><li>因此，遍历就是<code>[P in Exclude&lt;keyof T, K&gt;]</code></li></ul><h3 id="Parameters-和-ReturnType"><a href="#Parameters-和-ReturnType" class="headerlink" title="Parameters 和 ReturnType"></a>Parameters 和 ReturnType</h3><p>Parameters 获取函数的参数类型，将每个参数类型放在一个元组中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 具体实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Parameters&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (...args: infer P) =&gt; <span class="built_in">any</span> ? P : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg = [arg1: string, arg2: number];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg = Parameters&lt;<span class="function">(<span class="params">arg1: <span class="built_in">string</span>, arg2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;;</span><br></pre></td></tr></table></figure><ul><li><code>Parameters</code>首先约束参数<code>T</code>必须是个函数类型，所以<code>(...args: any) =&gt; any&gt;</code>替换成<code>Function</code>也是可以的</li><li>具体实现就是，判断<code>T</code>是否是函数类型，如果是则使用<code>inter P让ts</code>自己推导出函数的参数类型，并将推导的结果存到类型<code>P</code>上，否则就返回<code>never</code>；</li></ul><h4 id="敲重点！！！敲重点！！！敲重点！！！"><a href="#敲重点！！！敲重点！！！敲重点！！！" class="headerlink" title="敲重点！！！敲重点！！！敲重点！！！"></a>敲重点！！！敲重点！！！敲重点！！！</h4><ul><li><code>infer</code>关键词作用是让<code>Ts</code>自己推导类型，并将推导结果存储在其参数绑定的类型上。<code>Eg:infer P</code> 就是将结果存在类型<code>P</code>上，供使用。</li><li><code>infer</code>关键词只能在<code>extends</code>条件类型上使用，不能在其他地方使用。</li></ul><h4 id="再敲重点！！！再敲重点！！！再敲重点！！！"><a href="#再敲重点！！！再敲重点！！！再敲重点！！！" class="headerlink" title="再敲重点！！！再敲重点！！！再敲重点！！！"></a>再敲重点！！！再敲重点！！！再敲重点！！！</h4><ul><li><p><code>type Eg = [arg1: string, arg2: number]</code>这是一个元组，但是和我们常见的元组<code>type tuple = [string, number]</code>。官网未提到该部分文档说明，其实可以把这个作为类似命名元组，或者具名元组的意思去理解。实质上没有什么特殊的作用，比如无法通过这个具名去取值不行的。但是从语义化的角度，个人觉得多了语义化的表达罢了。</p></li><li><p>定义元祖的可选项，只能是最后的选项</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Tuple1 = [<span class="built_in">string</span>, <span class="built_in">number</span>?];</span><br><span class="line"><span class="keyword">const</span> a: Tuple1 = [<span class="string">'aa'</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">const</span> a2: Tuple1 = [<span class="string">'aa'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具名方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Tuple2 = [name: <span class="built_in">string</span>, age?: <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">const</span> b: Tuple2 = [<span class="string">'aa'</span>, <span class="number">11</span>];</span><br><span class="line"><span class="keyword">const</span> b2: Tuple2 = [<span class="string">'aa'</span>];</span><br></pre></td></tr></table></figure></li></ul><p>扩展：<code>infer</code>实现一个推导数组所有元素的类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约束参数T为数组类型，</span></span><br><span class="line"><span class="comment"> * 判断T是否为数组，如果是数组类型则推导数组元素的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> FalttenArray&lt;T <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;&gt; = T <span class="keyword">extends</span> <span class="built_in">Array</span>&lt;infer P&gt; ? P : never;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type Eg1 = number | string;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg1 = FalttenArray&lt;[<span class="built_in">number</span>, <span class="built_in">string</span>]&gt;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * type Eg2 = 1 | 'asd';</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg2 = FalttenArray&lt;[<span class="number">1</span>, <span class="string">'asd'</span>]&gt;</span><br></pre></td></tr></table></figure><h3 id="ReturnType-获取函数的返回值类型。"><a href="#ReturnType-获取函数的返回值类型。" class="headerlink" title="ReturnType 获取函数的返回值类型。"></a>ReturnType 获取函数的返回值类型。</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc ReturnType的实现其实和Parameters的基本一样</span></span><br><span class="line"><span class="comment"> * 无非是使用infer R的位置不一样。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> ReturnType&lt;T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> (</span><br><span class="line">  ...args: <span class="built_in">any</span></span><br><span class="line">) =&gt; infer R</span><br><span class="line">  ? R</span><br><span class="line">  : <span class="built_in">any</span>;</span><br></pre></td></tr></table></figure><h3 id="Ts-compiler内部实现的类型"><a href="#Ts-compiler内部实现的类型" class="headerlink" title="Ts compiler内部实现的类型"></a>Ts compiler内部实现的类型</h3><h4 id="Uppercase"><a href="#Uppercase" class="headerlink" title="Uppercase"></a>Uppercase</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 构造一个将字符串转大写的类型</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg1 = 'ABCD';</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg1 = Uppercase&lt;<span class="string">'abcd'</span>&gt;;</span><br></pre></td></tr></table></figure><h4 id="Lowercase"><a href="#Lowercase" class="headerlink" title="Lowercase"></a>Lowercase</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 构造一个将字符串转小大写的类型</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg2 = 'abcd';</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg2 = Lowercase&lt;<span class="string">'ABCD'</span>&gt;;</span><br></pre></td></tr></table></figure><h4 id="Capitalize"><a href="#Capitalize" class="headerlink" title="Capitalize"></a>Capitalize</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 构造一个将字符串首字符转大写的类型</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg3 = 'Abcd';</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg3 = Capitalize&lt;<span class="string">'abcd'</span>&gt;;</span><br></pre></td></tr></table></figure><h4 id="Uncapitalize"><a href="#Uncapitalize" class="headerlink" title="Uncapitalize"></a>Uncapitalize</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 构造一个将字符串首字符转小写的类型</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg3 = 'aBCD';</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg3 = Uncapitalize&lt;<span class="string">'ABCD'</span>&gt;;</span><br></pre></td></tr></table></figure><p>这些类型工具，在lib.es5.d.ts文件中是看不到具体定义的：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Uppercase&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br><span class="line"><span class="keyword">type</span> Lowercase&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br><span class="line"><span class="keyword">type</span> Capitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br><span class="line"><span class="keyword">type</span> Uncapitalize&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = intrinsic;</span><br></pre></td></tr></table></figure><h2 id="第三部分-自定义Ts高级类型工具及类型编程技巧"><a href="#第三部分-自定义Ts高级类型工具及类型编程技巧" class="headerlink" title="第三部分 自定义Ts高级类型工具及类型编程技巧"></a>第三部分 自定义Ts高级类型工具及类型编程技巧</h2><h3 id="SymmetricDifference"><a href="#SymmetricDifference" class="headerlink" title="SymmetricDifference"></a>SymmetricDifference</h3><p><code>SymmetricDifference&lt;T, U&gt;</code>获取没有同时存在于<code>T</code>和<code>U</code>内的类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> SymmetricDifference&lt;A, B&gt; = SetDifference&lt;A | B, A &amp; B&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SetDifference的实现和Exclude一样</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> SymmetricDifference&lt;T, U&gt; = Exclude&lt;T | U, T &amp; U&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg = '1' | '4';</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg = SymmetricDifference&lt;<span class="string">'1'</span> | <span class="string">'2'</span> | <span class="string">'3'</span>, <span class="string">'2'</span> | <span class="string">'3'</span> | <span class="string">'4'</span>&gt;</span><br></pre></td></tr></table></figure><p>其核心实现利用了3点：分发式联合类型、交叉类型和<code>Exclude</code>。</p><ul><li>首先利用Exclude从获取存在于第一个参数但是不存在于第二个参数的类型</li><li>Exclude第2个参数是T &amp; U获取的是所有类型的交叉类型</li><li>Exclude第一个参数则是T | U，这是利用在联合类型在extends中的分发特性，可以理解为Exclude&lt;T, T &amp; U&gt; | Exclude&lt;U, T &amp; U&gt;;</li></ul><p>总结一下就是，提取存在于<code>T</code>但不存在于<code>T &amp; U</code>的类型，然后再提取存在于<code>U</code>但不存在于<code>T &amp; U</code>的，最后进行联合。</p><h3 id="FunctionKeys"><a href="#FunctionKeys" class="headerlink" title="FunctionKeys"></a>FunctionKeys</h3><p>获取T中所有类型为函数的key组成的联合类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc NonUndefined判断T是否为undefined</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> NonUndefined&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">undefined</span> ? never : T;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @desc 核心实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> FunctionKeys&lt;T <span class="keyword">extends</span> object&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]: NonUndefined&lt;T[K]&gt; <span class="keyword">extends</span> <span class="built_in">Function</span> ? K : never;</span><br><span class="line">&#125;[keyof T];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg = 'key2' | 'key3';</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> AType = &#123;</span><br><span class="line">    key1: <span class="built_in">string</span>,</span><br><span class="line">    key2: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">    key3: <span class="built_in">Function</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> Eg = FunctionKeys&lt;AType&gt;;</span><br></pre></td></tr></table></figure><ul><li>首先约束参数T类型为<code>object</code></li><li>通过映射类型<code>K in keyof T</code>遍历所有的<code>key</code>，先通过<code>NonUndefined&lt;T[K]&gt;</code>过滤<code>T[K]</code>为<code>undefined | null</code>的类型，不符合的返回<code>never</code></li><li>若<code>T[K]</code>为有效类型，则判断是否为<code>Function</code>类型，是的话返回<code>K</code>,否则<code>never</code>；此时可以得到的类型，例如：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上述的Eg在此时应该是如下类型，伪代码：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> TempType = &#123;</span><br><span class="line">    key1: never,</span><br><span class="line">    key2: <span class="string">'key2'</span>,</span><br><span class="line">    key3: <span class="string">'key3'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后经过<code>{省略}[keyof T]</code>索引访问，取到的为值类型的联合类型<code>never | key2 | key3</code>,计算后就是<code>key2 | key3</code>;</p><p>#### </p><ul><li><code>T[]</code>是索引访问操作，可以取到值的类型</li><li><code>T[&#39;a&#39; | &#39;b&#39;]</code>若<code>[]</code>内参数是联合类型，则也是分发索引的特性，依次取到值的类型进行联合</li><li><code>T[keyof T]</code>则是获取T所有值的类型类型；</li><li><code>never</code>和其他类型进行联合时，<code>never</code>是不存在的。例如：<code>never | number | string</code>等同于<code>number | string</code></li></ul><h4 id="再敲重点！！！再敲重点！！！再敲重点！！！-1"><a href="#再敲重点！！！再敲重点！！！再敲重点！！！-1" class="headerlink" title="再敲重点！！！再敲重点！！！再敲重点！！！"></a>再敲重点！！！再敲重点！！！再敲重点！！！</h4><ul><li>null和undefined可以赋值给其他类型（开始该类型的严格赋值检测除外）,所以上述实现中需要使用`NonUndefined先行判断。</li><li>NonUndefined中的实现，只判断了T extends undefined，其实也是因为两者可以互相兼容的。所以你换成T extends null或者T extends null | undefined都是可以的。</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A = 1</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="literal">undefined</span> <span class="keyword">extends</span> <span class="literal">null</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"><span class="comment">// B = 1</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="literal">null</span> <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="number">1</span> : <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="增强Pick"><a href="#增强Pick" class="headerlink" title="增强Pick"></a>增强Pick</h3><p>PickByValue提取指定值的类型</p><p>// 辅助函数，用于获取T中类型不为never的类型组成的联合类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TypeKeys&lt;T&gt; = T[keyof T];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> PickByValue&lt;T, V&gt; = Pick&lt;T,</span><br><span class="line">  TypeKeys&lt;&#123;[P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> V ? P : never&#125;&gt;</span><br><span class="line">&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> *  type Eg = &#123;</span></span><br><span class="line"><span class="comment"> *    key1: number;</span></span><br><span class="line"><span class="comment"> *    key3: number;</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg = PickByValue&lt;&#123;key1: <span class="built_in">number</span>, key2: <span class="built_in">string</span>, key3: <span class="built_in">number</span>&#125;, <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure><p>Ts的类型兼容特性，所以类似string是可以分配给string | number的，因此上述并不是精准的提取方式。如果实现精准的方式，则可以考虑下面个这个类型工具。</p><p>PickByValueExact精准的提取指定值的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> PickByValueExact&lt;T, V&gt; = Pick&lt;T,</span><br><span class="line">  TypeKeys&lt;&#123;[P <span class="keyword">in</span> keyof T]: [T[P]] <span class="keyword">extends</span> [V]</span><br><span class="line">    ? ([V] <span class="keyword">extends</span> [T[P]] ? P : never)</span><br><span class="line">    : never;</span><br><span class="line">  &#125;&gt;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Eg1 = &#123; b: number &#125;;</span></span><br><span class="line"><span class="keyword">type</span> Eg1 = PickByValueExact&lt;&#123;a: <span class="built_in">string</span>, b: <span class="built_in">number</span>&#125;, <span class="built_in">number</span>&gt;</span><br><span class="line"><span class="comment">// type Eg2 = &#123; b: number; c: number | undefined &#125;</span></span><br><span class="line"><span class="keyword">type</span> Eg2 = PickByValueExact&lt;&#123;a: <span class="built_in">string</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span> | <span class="literal">undefined</span>&#125;, <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure><p>PickByValueExact的核心实现主要有三点：<br>一是利用Pick提取我们需要的key对应的类型<br>二是利用给泛型套一层元组规避extends的分发式联合类型的特性<br>三是利用两个类型互相兼容的方式判断是否相同。<br>具体可以看下下面例子：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Eq1&lt;X, Y&gt; = X <span class="keyword">extends</span> Y ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> Eq2&lt;X, Y&gt; = [X] <span class="keyword">extends</span> [Y] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">type</span> Eq3&lt;X, Y&gt; = [X] <span class="keyword">extends</span> [Y]</span><br><span class="line">  ? ([Y] <span class="keyword">extends</span> [X] ? <span class="literal">true</span> : <span class="literal">false</span>)</span><br><span class="line">  : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// boolean, 期望是false</span></span><br><span class="line"><span class="keyword">type</span> Eg1 = Eq1&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> Eg2 = Eq2&lt;<span class="built_in">string</span> | <span class="built_in">number</span>, <span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true，期望是false</span></span><br><span class="line"><span class="keyword">type</span> Eg3 = Eq2&lt;<span class="built_in">string</span>, <span class="built_in">string</span> | <span class="built_in">number</span>&gt;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">type</span> Eg4 = Eq3&lt;<span class="built_in">string</span>, <span class="built_in">string</span> | <span class="built_in">number</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// true，非strictNullChecks模式下的结果</span></span><br><span class="line"><span class="keyword">type</span> Eg5 = Eq3&lt;<span class="built_in">number</span> | <span class="literal">undefined</span>, <span class="built_in">number</span>&gt;</span><br><span class="line"><span class="comment">// false，strictNullChecks模式下的结果</span></span><br><span class="line"><span class="keyword">type</span> Eg6 = Eq3&lt;<span class="built_in">number</span> | <span class="literal">undefined</span>, <span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure><ul><li>从Eg1和Eg2对比可以看出，给extends参数套上元组可以避免分发的特性，从而得到期望的结果；</li><li>从Eg3和Eg4对比可以看出，通过判断两个类型互相是否兼容的方式，可以得到从属类型的正确相等判断。</li><li>从Eg5和Eg6对比可以看出，非strictNullChecks模式下，undefined和null可以赋值给其他类型的特性，导致number | undefined, number是兼容的，因为是非strictNullChecks模式，所以有这个结果也是符合预期。如果不需要此兼容结果，完全可以开启strictNullChecks模式。</li></ul><p>最后，同理想得到OmitByValue和OmitByValueExact基本一样的思路就不多说了，大家可以自己思考实现。</p><h3 id="Overwrite-和-Assign"><a href="#Overwrite-和-Assign" class="headerlink" title="Overwrite 和 Assign"></a>Overwrite 和 Assign</h3><p><code>Overwrite&lt;T, U&gt;</code>从U中的同名属性的类型覆盖T中的同名属性类型。(后者中的同名属性覆盖前者)</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Overwrite实现</span></span><br><span class="line"><span class="comment"> * 获取前者独有的key和类型，再取两者共有的key和该key在后者中的类型，最后合并。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Overwrite&lt;</span><br><span class="line">  T <span class="keyword">extends</span> object,</span><br><span class="line">  U <span class="keyword">extends</span> object,</span><br><span class="line">  I = Diff&lt;T, U&gt; &amp; Intersection&lt;U, T&gt;</span><br><span class="line">&gt; = Pick&lt;I, keyof I&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg1 = &#123; key1: number; &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg1 = Overwrite&lt;&#123;key1: <span class="built_in">string</span>&#125;, &#123;key1: <span class="built_in">number</span>, other: <span class="built_in">boolean</span>&#125;&gt;</span><br></pre></td></tr></table></figure><ul><li>首先约束T和U这两个参数都是object</li><li>借助一个参数I的默认值作为实现过程，使用的时候不需要传递I参数（只是辅助实现的）</li><li>通过Diff&lt;T, U&gt;获取到存在于T但是不存在于U中的key和其类型。（即获取T自己特有key和类型）。</li><li>通过Intersection&lt;U, T&gt;获取U和T共有的key已经该key在U中的类型。即获取后者同名key已经类型。</li><li>最后通过交叉类型进行合并，从而曲线救国实现了覆盖操作。</li></ul><p>扩展：如何实现一个Assign&lt;T, U&gt;（类似于Object.assign()）用于合并呢？</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="keyword">type</span> Assign&lt;</span><br><span class="line">  T <span class="keyword">extends</span> object,</span><br><span class="line">  U <span class="keyword">extends</span> object,</span><br><span class="line">  I = Diff&lt;T, U&gt; &amp; U</span><br><span class="line">&gt; = Pick&lt;I, keyof I&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @example</span></span><br><span class="line"><span class="comment"> * type Eg = &#123;</span></span><br><span class="line"><span class="comment"> *   name: string;</span></span><br><span class="line"><span class="comment"> *   age: string;</span></span><br><span class="line"><span class="comment"> *   other: string;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">type</span> Eg = Assign&lt;</span><br><span class="line">  &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span>; &#125;,</span><br><span class="line">  &#123; age: <span class="built_in">string</span>; other: <span class="built_in">string</span>; &#125;</span><br><span class="line">&gt;;</span><br></pre></td></tr></table></figure><p>想一下，是不是就是先找到前者独有的key和类型，再和U交叉。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本文基本分为三部分：&quot;&gt;&lt;a href=&quot;#本文基本分为三部分：&quot; class=&quot;headerlink&quot; title=&quot;本文基本分为三部分：&quot;&gt;&lt;/a&gt;本文基本分为三部分：&lt;/h2&gt;&lt;p&gt;第一部分讲解一些基本的关键词的特性（比如索引查询、索引访问、映射、extends等），但是该部分更多的讲解小伙伴们不清晰的一些特性，而基本功能则不再赘述。更多的关键词及技巧将包含在后续的例子演示中再具体讲述；&lt;/p&gt;
&lt;p&gt;第二部分讲解Ts内置的类型工具以及实现原理，比如Pick、Omit等；&lt;/p&gt;
&lt;p&gt;第三部分讲解自定义的工具类型，该部分也是最难的部分，将通过一些复杂的类型工具示例进行逐步剖析，对于其中的晦涩的地方以及涉及的知识点逐步讲解。此部分也会包含大量Ts类型工具的编程技巧，也希望通过此部分的讲解，小伙伴的Ts功底可以进一步提升！&lt;/p&gt;
&lt;h2 id=&quot;第一部分-前置内容&quot;&gt;&lt;a href=&quot;#第一部分-前置内容&quot; class=&quot;headerlink&quot; title=&quot;第一部分 前置内容&quot;&gt;&lt;/a&gt;第一部分 前置内容&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;keyof&lt;/code&gt; 索引查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对应任何类型&lt;code&gt;T&lt;/code&gt;,&lt;code&gt;keyof T&lt;/code&gt;的结果为该类型上所有共有属性key的联合：&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; Eg1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  readonly age: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// T1的类型实则是name | age&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; T1 = keyof Eg1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Eg2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; readonly age: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; home: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// T2实则被约束为 age&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 而name和home不是公有属性，所以不能被keyof获取到&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; T2 = keyof Eg2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T[K]&lt;/code&gt; 索引访问&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; Eg1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  readonly age: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; V1 = Eg1[&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// string | number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; V2 = Eg1[&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&#39;age&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// any&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; V2 = Eg1[&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&#39;age2222&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// string | number&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; V3 = Eg1[keyof Eg1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;T[keyof T]&lt;/code&gt;的方式，可以获取到T所有key的类型组成的联合类型；&lt;br&gt;&lt;code&gt;T[keyof K]&lt;/code&gt;的方式，获取到的是T中的key且同时存在于K时的类型组成的联合类型；&lt;br&gt;注意：如果[]中的key有不存在T中的，则是any；因为ts也不知道该key最终是什么类型，所以是any；且也会报错；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 交叉类型注意点&lt;br&gt;交叉类型取的多个类型的并集，但是如果相同&lt;code&gt;key&lt;/code&gt;但是类型不同，则该&lt;code&gt;key&lt;/code&gt;为&lt;code&gt;never&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; Eg1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  age: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; Eg2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  color: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  age: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * T的类型为 &amp;#123;name: string; age: number; age: never&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 注意，age因为Eg1和Eg2中的类型不一致，所以交叉后age的类型是never&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; T = Eg1 &amp;amp; Eg2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 可通过如下示例验证&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; val: T = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  color: &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  age: (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Error&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;extends关键词特性（重点）&quot;&gt;&lt;a href=&quot;#extends关键词特性（重点）&quot; class=&quot;headerlink&quot; title=&quot;extends关键词特性（重点）&quot;&gt;&lt;/a&gt;extends关键词特性（重点）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;用于接口，表示继承&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; T1 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; T2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  sex: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @example&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * T3 = &amp;#123;name: string, sex: number, age: number&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; T3 &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; T1, T2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  age: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意，接口支持多重继承，语法为逗号隔开。如果是type实现继承，则可以使用交叉类型&lt;code&gt;type A = B &amp;amp; C &amp;amp; D&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示条件类型，可用于条件判断&lt;br&gt;表示条件判断，如果前面的条件满足，则返回问号后的第一个参数，否则第二个。类似于js的三元运算。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @example&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * type A1 = 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; A1 = &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @example&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * type A2 = 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; A2 = &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&#39;y&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * @example&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * type A3 = 1 | 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; P&amp;lt;T&amp;gt; = T &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt; ? &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; A3 = P&amp;lt;&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt; | &lt;span class=&quot;string&quot;&gt;&#39;y&#39;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ts" scheme="http://blog.html-js.site/tags/ts/"/>
    
      <category term="typescript" scheme="http://blog.html-js.site/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>前端知识点-前端基础</title>
    <link href="http://blog.html-js.site/2022/01/17/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9-%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.html-js.site/2022/01/17/前端知识点-前端基础/</id>
    <published>2022-01-17T07:27:40.000Z</published>
    <updated>2022-08-19T02:24:34.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、列举你所了解的计算机存储设备类型？"><a href="#1、列举你所了解的计算机存储设备类型？" class="headerlink" title="1、列举你所了解的计算机存储设备类型？"></a>1、列举你所了解的计算机存储设备类型？</h2><p>现代计算机以<code>存储器为中心</code>，主要由 <code>CPU</code>、<code>I / O 设备</code>以及<code>主存储器</code>三大部分组成。各个部分之间通过<code>总线</code>进行连接通信，具体如下图所示：<br><img src="/images/page/knowledge/1.png" alt></p><p>线结构的示意图，CPU、主存以及 I / O 设备之间的所有数据都是通过总线进行并行传输，使用局部总线是为了提高 CPU 的吞吐量（CPU 不需要直接跟 I / O 设备通信），而使用高速总线（更贴近 CPU）和 DMA 总线则是为了提升高速 I / O 设备（外设存储器、局域网以及多媒体等）的执行效率。</p><h2 id="2、一般代码存储在计算机的哪个设备中？代码在-CPU-中是如何运行的？"><a href="#2、一般代码存储在计算机的哪个设备中？代码在-CPU-中是如何运行的？" class="headerlink" title="2、一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？"></a>2、一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？</h2><p>高级程序设计语言不能直接被计算机理解并执行，需要通过翻译程序将其转换成特定处理器上可执行的指令，计算机 CPU 的简单工作原理如下所示：<br><img src="/images/page/knowledge/2.png" alt></p><p><code>CPU 主要由控制单元、运算单元和存储单元组成</code>（注意忽略了中断系统），各自的作用如下：</p><ul><li><code>控制单元</code>：在节拍脉冲的作用下，将程序计数器（Program Counter，PC）指向的主存或者多级高速缓存中的指令地址送到地址总线，接着获取指令地址所对应的指令并放入指令寄存器 （Instruction Register，IR）中，然后通过指令译码器（Instruction Decoder，ID）分析指令需要进行的操作，最后通过操作控制器（Operation Controller，OC）向其他设备发出微操作控制信号。</li><li><code>运算单元</code>：如果控制单元发出的控制信号存在算术运算（加、减、乘、除、增 1、减 1、取反等）或者逻辑运算（与、或、非、异或），那么需要通过运算单元获取存储单元的计算数据进行处理。</li><li><code>存储单元</code>：包括片内缓存和寄存器组，是 CPU 中临时数据的存储地方。CPU 直接访问主存数据大概需要花费数百个机器周期，而访问寄存器或者片内缓存只需要若干个或者几十个机器周期，因此会使用内部寄存器或缓存来存储和获取临时数据（即将被运算或者运算之后的数据），从而提高 CPU 的运行效率。</li></ul><h2 id="3、什么是指令和指令集？"><a href="#3、什么是指令和指令集？" class="headerlink" title="3、什么是指令和指令集？"></a>3、什么是指令和指令集？</h2><p>上图右侧主存中的指令是 <code>CPU 可以支持的处理命令</code>，一般包含<code>算术指令</code>（加和减）、<code>逻辑指令</code>（与、或和非）、<code>数据指令</code>（移动、输入、删除、加载和存储）、<code>流程控制指令</code>以及<code>程序结束指令</code>等，由于 CPU 只能识别二进制码，因此指令是由二进制码组成。除此之外，指令的集合称为指令集（例如汇编语言就是指令集的一种表现形式），常见的指令集有精简指令集（ARM）和复杂指令集（Inter X86）。一般指令集决定了 CPU 处理器的硬件架构，规定了处理器的相应操作。</p><h2 id="5、JavaScript-是如何运行的？解释型语言和编译型语言的差异是什么？"><a href="#5、JavaScript-是如何运行的？解释型语言和编译型语言的差异是什么？" class="headerlink" title="5、JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？"></a>5、JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？</h2><p>解释器和编译器有很多相似之处，都需要对源程序进行分析，并转换成目标机器可识别的机器语言进行执行。<br><code>编译器</code>：先把源程序全部转换成机器语言并产生目标文件，然后将目标文件写入相应的程序存储器进行执行（转换和执行的过程分离）<br><code>解释器</code>：在转换源程序的同时立马执行对应的机器语言（转换和执行的过程不分离）<br>①JS代码-&gt;解析成 AST (期间伴随词法分析、语法分析)-&gt;生成字节码（V8）-&gt;生成机器码（编译器）</p><p>电脑：CPU+I/O设备+主存储器组成，通过总线进行连接并行传输<br>CPU：控制单元+存储单元+运算单元<br>主存：指令，CPU可以支持的处理命令，一般包含算数指令(加减)、逻辑指令(与、或和非)、数据指令(移动、输入、删除、加载和存储)、流程控制指令、程序结束指令等</p><h2 id="5-简单描述一下-Babel-的编译过程？"><a href="#5-简单描述一下-Babel-的编译过程？" class="headerlink" title="5.简单描述一下 Babel 的编译过程？"></a>5.简单描述一下 Babel 的编译过程？</h2><p>答： 首先，Babel的作用是 从一种源码到另一种源码，充当转换编译器的作用，可以简述为 解析（解析JS代码）-&gt;转换（解析和修改AST）-&gt;重建（将修改后的AST转换成另一种JS代码）</p><h2 id="7-浏览器和-Node-js-中的事件循环机制有什么区别？"><a href="#7-浏览器和-Node-js-中的事件循环机制有什么区别？" class="headerlink" title="7.浏览器和 Node.js 中的事件循环机制有什么区别？"></a>7.浏览器和 Node.js 中的事件循环机制有什么区别？</h2><p>在浏览器里，每当一个被监听的事件发生时，事件监听器绑定的相关任务就会被添加进回调队列。通过事件产生的任务是异步任务，常见的事件任务包括：</p><ul><li>用户交互事件产生的事件任务，比如输入操作</li><li>计时器产生的事件任务，比如setTimeout；</li><li>异步请求产生的事件任务，比如 HTTP 请求。<br>主线程运行的时候，会产生堆（heap）和栈（stack），其中堆为内存、栈为函数调用栈。我们能看到，Event Loop 负责执行代码、收集和处理事件以及执行队列中的子任务，具体包括以下过程。</li><li>JavaScript 有一个主线程和调用栈，所有的任务最终都会被放到调用栈等待主线程执行。</li><li>同步任务会被放在调用栈中，按照顺序等待主线程依次执行。</li><li>主线程之外存在一个回调队列，回调队列中的异步任务最终会在主线程中以调用栈的方式运行。</li><li>同步任务都在主线程上执行，栈中代码在执行的时候会调用浏览器的 API，此时会产生一些异步任务。</li><li>异步任务会在有了结果（比如被监听的事件发生时）后，将异步任务以及关联的回调函数放入回调队列中。</li><li>调用栈中任务执行完毕后，此时主线程处于空闲状态，会从回调队列中获取任务进行处理。</li><li>上述过程会不断重复，这就是 JavaScript 的运行机制，称为事件循环机制（Event Loop）</li></ul><p><a href="https://juejin.cn/post/6987549240436195364#heading-0" target="_blank" rel="noopener">https://juejin.cn/post/6987549240436195364#heading-0</a><br><a href="https://juejin.cn/post/6987070062490288165?share_token=3904e7be-48e7-44bf-a27c-66ab95dd598c#heading-65" target="_blank" rel="noopener">https://juejin.cn/post/6987070062490288165?share_token=3904e7be-48e7-44bf-a27c-66ab95dd598c#heading-65</a><br><a href="https://juejin.cn/post/6844903843197616136#heading-3" target="_blank" rel="noopener">https://juejin.cn/post/6844903843197616136#heading-3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、列举你所了解的计算机存储设备类型？&quot;&gt;&lt;a href=&quot;#1、列举你所了解的计算机存储设备类型？&quot; class=&quot;headerlink&quot; title=&quot;1、列举你所了解的计算机存储设备类型？&quot;&gt;&lt;/a&gt;1、列举你所了解的计算机存储设备类型？&lt;/h2&gt;&lt;p&gt;现代
      
    
    </summary>
    
    
      <category term="前端" scheme="http://blog.html-js.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>手写Promise源码</title>
    <link href="http://blog.html-js.site/2021/12/20/%E6%89%8B%E5%86%99Promise%E6%BA%90%E7%A0%81/"/>
    <id>http://blog.html-js.site/2021/12/20/手写Promise源码/</id>
    <published>2021-12-20T13:05:44.000Z</published>
    <updated>2022-08-19T02:24:34.488Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6994594642280857630" target="_blank" rel="noopener">https://juejin.cn/post/6994594642280857630</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.PromiseResult = <span class="literal">null</span>; <span class="comment">// 终值</span></span><br><span class="line">    <span class="keyword">this</span>.PromiseState = <span class="string">'pending'</span>; <span class="comment">// 状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.onFulfiledCallbacks = []; <span class="comment">// 保存成功回调</span></span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks = []; <span class="comment">// 保存失败回调</span></span><br><span class="line">    <span class="comment">// 绑定this</span></span><br><span class="line">    <span class="keyword">this</span>.resolve = <span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.reject = <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resolve (value) &#123;</span><br><span class="line">    <span class="comment">// 状态不可变</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseState !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>.PromiseState = <span class="string">'fulfiled'</span>;</span><br><span class="line">    <span class="keyword">this</span>.PromiseResult = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.onFulfiledCallbacks.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onFulfilledCallbacks.shift()(<span class="keyword">this</span>.PromiseResult)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reject (reason) &#123;</span><br><span class="line">    <span class="comment">// 状态不可变</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseState !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">this</span>.PromiseState = <span class="string">'rejected'</span>;</span><br><span class="line">    <span class="keyword">this</span>.PromiseResult = reason;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.onRejectedCallbacks.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.shift()(<span class="keyword">this</span>.PromiseResult)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接受两个参数</span></span><br><span class="line">  <span class="comment">// 1、then方法本身会返回一个新的Promise对象</span></span><br><span class="line">  <span class="comment">// 2、如果返回值是promise对象，返回值为成功，新promise就是成功</span></span><br><span class="line">  <span class="comment">// 3、如果返回值是promise对象，返回值为失败，新promise就是失败</span></span><br><span class="line">  <span class="comment">// 4、如果返回值非promise对象，新promise对象就是成功，值为此返回值</span></span><br><span class="line">  then (onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 返回 Promise 对象</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">val</span> =&gt;</span> val;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> thenPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> resolvePromise = <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = cb(<span class="keyword">this</span>.PromiseResult);</span><br><span class="line">            <span class="keyword">if</span>(x === thenPromise) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能返回自身'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果返回值是Promise</span></span><br><span class="line">              <span class="comment">// 如果返回值是promise对象，返回值为成功，新promise就是成功</span></span><br><span class="line">              <span class="comment">// 如果返回值是promise对象，返回值为失败，新promise就是失败</span></span><br><span class="line">              <span class="comment">// 谁知道返回的promise是失败成功？只有then知道</span></span><br><span class="line">              x.then(resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 非Promise就直接成功</span></span><br><span class="line">              resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseState == <span class="string">'fulfiled'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前为成功状态，执行第一个回调</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// let x = onFulfilled(this.PromiseResult);</span></span><br><span class="line">        <span class="comment">// if(x instanceof MyPromise) &#123;</span></span><br><span class="line">        <span class="comment">//   x.then(resolve, reject);</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//   resolve(x)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        resolvePromise(onFulfilled)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseState == <span class="string">'rejected'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前为失败状态，执行第二个回调</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// let x = onRejected(this.PromiseResult);</span></span><br><span class="line">        <span class="comment">// if(x instanceof MyPromise) &#123;</span></span><br><span class="line">        <span class="comment">//   x.then(reject, reject)</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//   reject(x);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        resolvePromise(onRejected)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.PromiseState == <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果状态为待定状态，暂时保存两个回调</span></span><br><span class="line">        <span class="comment">// this.onFulfilledCallbacks.push(onFulfilled.bind(this))</span></span><br><span class="line">        <span class="comment">// this.onRejectedCallbacks.push(onRejected.bind(this))</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.push(resolvePromise.bind(<span class="keyword">this</span>, onFulfilled))</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(resolvePromise.bind(<span class="keyword">this</span>, onRejected))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> thenPromise;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6994594642280857630&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.cn/post/6994594642280857630&lt;/a&gt;&lt;/p&gt;
&lt;f
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.html-js.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>阿里云服务器搭建前端服务流程</title>
    <link href="http://blog.html-js.site/2021/11/15/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E5%89%8D%E7%AB%AF%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B/"/>
    <id>http://blog.html-js.site/2021/11/15/阿里云服务器搭建前端服务流程/</id>
    <published>2021-11-15T08:04:14.000Z</published>
    <updated>2022-08-19T02:24:34.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="重置实例密码"><a href="#重置实例密码" class="headerlink" title="重置实例密码"></a>重置实例密码</h3><p><img src="/images/page/aliyun/1.png" alt></p><p>重置实例密码之后可以在阿里云后台进行远程连接Workbench，或者试用ssh进行远程连接</p><p>这里也可以重置VPC连接，这样就可以在阿里云后台进行远程连接VPC</p><h3 id="安装git-和-node"><a href="#安装git-和-node" class="headerlink" title="安装git 和 node"></a>安装git 和 node</h3><p><a href="https://help.aliyun.com/document_detail/50775.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/50775.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install git</span><br></pre></td></tr></table></figure><p>注意：使用yum安装的git在/usr/bin/git下</p><h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><p><a href="https://help.aliyun.com/document_detail/173042.html?spm=5176.21213303.J_6028563670.7.572a3edaz0dICA&amp;scm=20140722.S_help%40%40%E6%96%87%E6%A1%A3%40%40173042.S_hot%2Bos0.ID_173042-RL_centos%E5%AE%89%E8%A3%85nginx-OR_helpmain-V_2-P0_0" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/173042.html?spm=5176.21213303.J_6028563670.7.572a3edaz0dICA&amp;scm=20140722.S_help%40%40%E6%96%87%E6%A1%A3%40%40173042.S_hot%2Bos0.ID_173042-RL_centos%E5%AE%89%E8%A3%85nginx-OR_helpmain-V_2-P0_0</a></p><h3 id="绑定域名，进行访问"><a href="#绑定域名，进行访问" class="headerlink" title="绑定域名，进行访问"></a>绑定域名，进行访问</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;重置实例密码&quot;&gt;&lt;a href=&quot;#重置实例密码&quot; class=&quot;headerlink&quot; title=&quot;重置实例密码&quot;&gt;&lt;/a&gt;重置实例密码&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/page/aliyun/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;重置实例密
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</title>
    <link href="http://blog.html-js.site/2021/10/20/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%88%B0JS%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%8CJS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84%E4%B8%80%E6%AC%A1%E6%A2%B3%E7%90%86/"/>
    <id>http://blog.html-js.site/2021/10/20/从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理/</id>
    <published>2021-10-20T03:33:26.000Z</published>
    <updated>2022-08-19T02:24:34.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="浏览器包含哪些进程"><a href="#浏览器包含哪些进程" class="headerlink" title="浏览器包含哪些进程"></a>浏览器包含哪些进程</h3><ol><li>Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有<ul><li>负责浏览器界面显示，与用户交互。如前进，后退等</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将Renderer进程得到的内存中的Bitmap，绘制到用户界面上</li><li>网络资源的管理，下载等</li></ul></li><li>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建</li><li>GPU进程：最多一个，用于3D绘制等</li><li>浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为<ul><li>页面渲染，脚本执行，事件处理等</li></ul></li></ol><h3 id="重点是浏览器内核（渲染进程）"><a href="#重点是浏览器内核（渲染进程）" class="headerlink" title="重点是浏览器内核（渲染进程）"></a>重点是浏览器内核（渲染进程）</h3><p>请牢记，浏览器的渲染进程是多线程的</p><ol><li>GUI渲染线程<ul><li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。</li><li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li><li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</li></ul></li><li>JS引擎线程<ul><li>也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）</li><li>JS引擎线程负责解析Javascript脚本，运行代码。</li><li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul></li><li>事件触发线程<ul><li>归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li><li>当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理</li><li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li></ul></li><li>定时触发器线程<ul><li>传说中的setInterval与setTimeout所在线程</li><li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li><li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。</li></ul></li><li>异步http请求线程<ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。</li></ul></li></ol><p><a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012925872</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;浏览器包含哪些进程&quot;&gt;&lt;a href=&quot;#浏览器包含哪些进程&quot; class=&quot;headerlink&quot; title=&quot;浏览器包含哪些进程&quot;&gt;&lt;/a&gt;浏览器包含哪些进程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端监控 SDK 的一些技术要点原理分析</title>
    <link href="http://blog.html-js.site/2021/10/14/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7-SDK-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://blog.html-js.site/2021/10/14/前端监控-SDK-的一些技术要点原理分析/</id>
    <published>2021-10-14T08:25:46.000Z</published>
    <updated>2022-08-19T02:24:34.485Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7017974567943536671?utm_source=gold_browser_extension#heading-23" target="_blank" rel="noopener">https://juejin.cn/post/7017974567943536671?utm_source=gold_browser_extension#heading-23</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7017974567943536671?utm_source=gold_browser_extension#heading-23&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.html-js.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>浅谈前端AST的概念与实际应用</title>
    <link href="http://blog.html-js.site/2021/10/14/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AFAST%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.html-js.site/2021/10/14/浅谈前端AST的概念与实际应用/</id>
    <published>2021-10-14T07:32:20.000Z</published>
    <updated>2022-08-19T02:24:34.489Z</updated>
    
    <content type="html"><![CDATA[<p>回想日常开发中使用的框架，脚手架，打包工具，再到编辑器的代码补全，代码格式化等功能，用一句话概括他们做的事那就是<strong>批量修改源代码</strong>，再精确一点即代码转换。既然要转换，那么首先第一步一定是理解源程序。如何能阅读和理解源程序？这就要引出一个关键概念-AST，本文将依次介绍AST的概念，生成过程，基本结构，节点类型，如何操作AST等，最后通过一个AST的实际应用来进行总结。</p><h3 id="AST的概念"><a href="#AST的概念" class="headerlink" title="AST的概念"></a>AST的概念</h3><p>抽象语法树（Abstract Syntax Tree）简称AST，顾名思义，它是一棵树，用分支和节点的组合来描述代码结构。他可以让计算机理解我们写的代码，我们不妨先试着按自己的理解来想象一下这棵树的构造。例如下面这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> b = a + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析，首先这是一个函数，有名字(foo)，参数(a)，函数体(body)三个基本属性。再来看body，他有两条语句，分别是声明语句和return语句。先看声明语句，他由变量b和一条表达式语句组成，表达式语句由三个元素：a,+,1组成。而return语句则由元素b组成。我们可以依照上述并按照节点与分支的组合描绘出这段代码的AST的大致结构如下。</p><p><img src="/images/page/20211014/1.webp" alt></p><a id="more"></a><p>在真正的AST中，每个节点都有自己的type以及一系列相关属性来描述它，那么真正的AST长什么样子？我们可以借助一个工具<a href="https://astexplorer.net/" target="_blank" rel="noopener">astexplorer</a>，上述代码的AST结构如下。</p><p><img src="/images/page/20211014/2.webp" alt></p><p>可以看到其基本结构与我们自己描述的结构图是类似的，只是其节点的描述属性会更加丰富。关于AST的详细结构与节点类型在下文会继续讨论，这里先不做展开。<br>现在我们知道，有了AST，计算机才能理解我们写的代码，那么我们不禁要问：AST到底是如何生成的？</p><h3 id="生成过程"><a href="#生成过程" class="headerlink" title="生成过程"></a>生成过程</h3><p>AST的生成是个复杂度极高过程，今天我们只关心一个关键概念——<strong>编译</strong>，以及两个关键步骤——<strong>词法分析，语法分析</strong>，下面对其做简单介绍。</p><ul><li>什么是编译：编译，就是把一门编程语言转成另一门编程语言的过程，一般是指高级语言到低级语言。</li></ul><p>我们平时开发使用的开发语言写出的代码计算机无法直接识别，计算机能直接识别的程序语言或指令代码是机器语言。而将高级语言转化为机器语言的过程就是编译的过程，与将英语翻译成汉语是一个道理。那什么是低级语言，什么又是高级语言？</p><p>低级语言：描述指令具体在机器上的执行过程，与硬件和执行细节有关，会操作寄存器、内存，需要开发者理解熟悉计算机的工作原理，熟悉具体的执行细节，无需经过翻译，每一操作码在计算机内部都有相应的电路来完成它。</p><p>高级语言：高级语言有很多用于描述逻辑的语言特性，如分支、循环、函数、面向对象等，接近人的思维，可以让开发者快速的通过它来表达各种逻辑。比如 c++、javascript。计算机无法直接识别高级语言，它需要被编译成低级语言的指令才能被执行，这个过程就是编译。</p><ul><li>编译的过程</li></ul><p>编译的本质就是转换，而转换的前提则是要理解被转换的东西，前面提到编译器通过AST理解高级语言代码，因此编译的第一步就是解析源代码，得到AST。具体来讲这个解析的过程分为如下几步：</p><h4 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h4><p>何为词法？词法组成语言的单词， 是语言中最小单元。我们写的高级语言代码 ，本质上就是一段文本，只不过是按照一定的格式组织的描述逻辑的文本。 因此词法可以理解成我们代码中一系列独立的单词，var，for ，if，while等。词法分析的过程就是读取代码，识别每一个单词及其种类，将它们按照预定的规则合并成一个个的标识，也叫 token，同时，它会移除空白符，注释，等，最终产出一个token数组。即词法分析阶段把会字符串形式的代码转换为 <strong>令牌</strong>（tokens） 流，用一段伪代码举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">[</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">"KEYWORD_CONST"</span>, <span class="attr">value</span>: <span class="string">"const"</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">"VARIABLE"</span>, <span class="attr">value</span>: <span class="string">"a"</span> &#125;,</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">"OPERATOR_EQUAL"</span>, <span class="attr">value</span>: <span class="string">"="</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">"INTEGER"</span>, <span class="attr">value</span>: <span class="string">"10"</span> &#125;</span><br><span class="line">...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p>语法，是词法之间的组合方式。前面说到，我们写的源程序是按照一定的格式组织的描述逻辑的文本，而所谓描述逻辑的格式就是指语法。语法分析的任务就是用由词法分析得到的令牌流，在上下文无关文法（一般指某种程序设计语言上的语法）的约束下，生成树形的中间表示（便于描述逻辑结构），该中间表示给出了令牌流的结构表示，同时验证语法，语法如果有错的话，抛出语法错误。</p><p>经过词法、语法分析之后就产生了AST，用一棵树形的数据结构来描述源代码，从这里开始就是计算机可以理解的了。有了AST，就可以根据不用需求进行不同操作，如编译器会将AST转换成线性中间代码，生成汇编代码，最后生成机器码。解释器会将AST解释执行或转成线性的中间代码再解释执行。转译器则会将AST转换为另一个AST，再生成目标代码，例如Babel就是一个典型的Javascript转译器，其主要能力是将ES6+代码转换成兼容旧的浏览器或环境的js代码，我们今天也会利用Babel的能力进行AST操作，关于编译的后续步骤如语义分析，代码优化，代码生成等这里就不再过多讨论，接下来具体了解AST。</p><h3 id="如何处理AST"><a href="#如何处理AST" class="headerlink" title="如何处理AST"></a>如何处理AST</h3><p>知己知彼，百战不殆。要对AST做处理，我们要清楚他的基本结构，节点类型，这将是我们基于AST进行实际应用的基础。<br>首先我们回顾前文的AST结构。我们会注意到，AST 的每一层都拥有近乎相同的结构，都有一个type属性以及一系列描述属性，type属性用来表示节点的类型（<code>CallExpression</code>,<code>Identifier</code>,<code>MemberExpression</code>等等）。这样的每一层结构称为一个 <strong>节点（Node）</strong>。 一个 AST 可以由单一的节点或是成百上千个节点构成。 抽象语法树有一套约定的规范：<a href="https://github.com/estree/estree" target="_blank" rel="noopener">GitHub - estree/estree: The ESTree Spec</a>，社区称为 estree。借助这个约定的 AST 规范，整个前端社区，生产类工具统一产出该格式的数据结构而无需关心下游，消费类工具统一使用该格式进行处理而无需关心上游。<br>AST的所有节点类型可分为以下几个大类：字面量、标识符、表达式、语句、模块语法，每个大类下又分类多个子类，下面介绍一些基本且开发常用的节点类型 ，更全面的信息可以查文档或者在ASTExplorer中具体查看。</p><h3 id="Literal-字面量"><a href="#Literal-字面量" class="headerlink" title="Literal 字面量"></a>Literal 字面量</h3><ul><li>StringLiteral 字符串字面量（”foo”）</li><li>NumericLiteral 数值字面量（123）</li><li>BooleanLiteral 布尔字面量 （true）</li><li>TemplateLiteral 模板字面量 （${obj}）<br>…</li></ul><h4 id="dentifier-标识符"><a href="#dentifier-标识符" class="headerlink" title="dentifier 标识符"></a>dentifier 标识符</h4><p>标识符即各种声明与引用的名字，js中的变量名，函数名，属性名等都是标识符。如下面代码中的bar,foo,num都是标识符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = foo(num)</span><br></pre></td></tr></table></figure><h4 id="Statement-语句"><a href="#Statement-语句" class="headerlink" title="Statement 语句"></a>Statement 语句</h4><p>这个比较好理解，它就是一段可以<strong>独立执行</strong>的代码。下面代码的每一行都是一条语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br></pre></td></tr></table></figure><p>Statement 分为众多子类型，下面举几个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a; <span class="comment">// ReturnStatement</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// TryStatement</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">  <span class="comment">// ForStatement</span></span><br><span class="line">  <span class="keyword">const</span> element = array[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (condition) &#123;&#125; <span class="comment">// WhileStatement</span></span><br></pre></td></tr></table></figure><h4 id="Declaration-声明语句"><a href="#Declaration-声明语句" class="headerlink" title="Declaration 声明语句"></a>Declaration 声明语句</h4><p>他是一种特殊的语句，用于在作用域内声明变量、函数、class、import、export 等，同样有众多子类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>; <span class="comment">// VariableDeclaration</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// FunctionDeclaration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125; <span class="comment">// ClassDeclaration</span></span><br></pre></td></tr></table></figure><h4 id="Expression-表达式"><a href="#Expression-表达式" class="headerlink" title="Expression 表达式"></a>Expression 表达式</h4><p>表达式与语句的区别是表达式执行后会有返回结果，举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>; <span class="comment">// AssignmentExpression</span></span><br><span class="line">a+b; <span class="comment">// BinaryExpression</span></span><br><span class="line"><span class="keyword">this</span>；<span class="comment">// ThisExpression</span></span><br></pre></td></tr></table></figure><h4 id="Modules-ES-module模块语法"><a href="#Modules-ES-module模块语法" class="headerlink" title="Modules ES module模块语法"></a>Modules ES module模块语法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">'name'</span>; <span class="comment">// ImportDeclaration</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> newName = <span class="string">'newName'</span>; <span class="comment">// ExportNamedDeclaration</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name; <span class="comment">// ExportDefaultDeclaration</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'name'</span>; <span class="comment">// ExportAllDeclaration</span></span><br></pre></td></tr></table></figure><h4 id="Program-amp-Directive"><a href="#Program-amp-Directive" class="headerlink" title="Program &amp; Directive"></a>Program &amp; Directive</h4><p>program 是代表整个程序的节点，它包裹了所有具体执行语句的节点，而Directive则是代码中的指令部分。</p><p><img src="/images/page/20211014/3.webp" alt></p><p>了解了AST的构造与节点类型，接下来就可以基于AST做些事情。工欲善其事，必先利其器，要处理AST，我们需要一个能遍历，访问，处理AST节点的工具，而Babel就是其中之一。</p><h3 id="Babel基础"><a href="#Babel基础" class="headerlink" title="Babel基础"></a>Babel基础</h3><p>Babel 是一个 JavaScript 的转译器，其执行过程就是一个编译转换的过程。作为一个js转译器，babel暴露了很多 api，利用这些 api 可以完成源代码到 AST 的 parse，AST 的遍历与处理以及目标代码的生成。babel将这些功能的实现放到了不同的包里面，下面逐一介绍。<br>@babel/parser 解析源码得到AST。<br>@babel/traverse 遍历 AST。<br>@babel/types 用于构建AST节点和校验AST节点类型；<br>@babel/generate 打印 AST，生成目标代码和 sorucemap。</p><h4 id="babel的处理步骤"><a href="#babel的处理步骤" class="headerlink" title="babel的处理步骤"></a>babel的处理步骤</h4><p>主要有三个阶段：解析（parse）， 转换 （transform），生成（generate）</p><ul><li>parse：将源码转成 AST，用到@babel/parser模块。</li><li>transform：对AST 进行遍历，在此过程中对节点进行添加、更新及移除等操作。因此这是bebel处理代码的核心步骤，是我们的讨论重点，主要使用@babel/traverse和@babel/types模块。</li><li>generate：打印 AST 成目标代码并生成 sourcemap，用到@babel/generate模块。</li></ul><p>接下来我们来重点了解转换这一步，上面我们提到，转换的第一步是遍历AST。说到这里就不得不提到一个设计模式——<strong>访问者模式</strong>。</p><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了目标元素的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。而在这里，访问者即是一个用于 AST 遍历的模式， 简单的说它就是一个对象，定义了用于在一个树状结构中获取具体节点的方法。当访问者把它用于遍历中时，每当在树中遇见一个对应类型时，都会调用该类型对应的方法。</p><p>因此我们只需根据需求，<strong>针对我们需要修改的节点类型去定义相应的遍历方法并指定相应的回调函数即可</strong>。举个例子，若我们想将所有var替换为let，则只需遍历所有的VariableDeclaration类型的节点，找到名为var的节点，将其替换为let即可。</p><p>先通过一段简单的代码结合astexplorer看一下变量声明语句的结构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span></span><br></pre></td></tr></table></figure><p><img src="/images/page/20211014/4.webp" alt></p><p>我们发现变量声明语句节点的kind属性就是其名字，因此问题迎刃而解。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">'@babel/generator'</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">'@babel/parser'</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>);</span><br><span class="line"><span class="keyword">const</span> transToLet = <span class="function"><span class="params">code</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ast = parser.parse(code);</span><br><span class="line">  <span class="comment">// 访问者对象</span></span><br><span class="line">  <span class="keyword">const</span> visitor = &#123;</span><br><span class="line">    <span class="comment">// 遍历声明表达式</span></span><br><span class="line">    VariableDeclaration(path) &#123;</span><br><span class="line">      <span class="keyword">if</span> (path.node.type === <span class="string">'VariableDeclaration'</span>) &#123;</span><br><span class="line">        <span class="comment">// 替换</span></span><br><span class="line">        <span class="keyword">if</span> (path.node.kind === <span class="string">'var'</span>) &#123;</span><br><span class="line">          path.node.kind = <span class="string">'let'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  traverse.default(ast, visitor);</span><br><span class="line">  <span class="comment">// 生成代码</span></span><br><span class="line">  <span class="keyword">const</span> newCode = generator.default(ast, &#123;&#125;, code).code;</span><br><span class="line">  <span class="keyword">return</span> newCode;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> code = <span class="string">`const a = 1</span></span><br><span class="line"><span class="string">var b = 2</span></span><br><span class="line"><span class="string">let c = 3`</span>;</span><br></pre></td></tr></table></figure><p><img src="/images/page/20211014/5.webp" alt></p><p>可以发现var节点变成了let节点，接下来来实现一个稍微复杂一些的应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回想日常开发中使用的框架，脚手架，打包工具，再到编辑器的代码补全，代码格式化等功能，用一句话概括他们做的事那就是&lt;strong&gt;批量修改源代码&lt;/strong&gt;，再精确一点即代码转换。既然要转换，那么首先第一步一定是理解源程序。如何能阅读和理解源程序？这就要引出一个关键概念-AST，本文将依次介绍AST的概念，生成过程，基本结构，节点类型，如何操作AST等，最后通过一个AST的实际应用来进行总结。&lt;/p&gt;
&lt;h3 id=&quot;AST的概念&quot;&gt;&lt;a href=&quot;#AST的概念&quot; class=&quot;headerlink&quot; title=&quot;AST的概念&quot;&gt;&lt;/a&gt;AST的概念&lt;/h3&gt;&lt;p&gt;抽象语法树（Abstract Syntax Tree）简称AST，顾名思义，它是一棵树，用分支和节点的组合来描述代码结构。他可以让计算机理解我们写的代码，我们不妨先试着按自己的理解来想象一下这棵树的构造。例如下面这段代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; b = a + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;分析，首先这是一个函数，有名字(foo)，参数(a)，函数体(body)三个基本属性。再来看body，他有两条语句，分别是声明语句和return语句。先看声明语句，他由变量b和一条表达式语句组成，表达式语句由三个元素：a,+,1组成。而return语句则由元素b组成。我们可以依照上述并按照节点与分支的组合描绘出这段代码的AST的大致结构如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/page/20211014/1.webp&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://blog.html-js.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>git放弃本地文件修改</title>
    <link href="http://blog.html-js.site/2021/10/09/git%E6%94%BE%E5%BC%83%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9/"/>
    <id>http://blog.html-js.site/2021/10/09/git放弃本地文件修改/</id>
    <published>2021-10-09T08:07:50.000Z</published>
    <updated>2022-08-19T02:24:34.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-未使用git-add-缓存代码"><a href="#1-未使用git-add-缓存代码" class="headerlink" title="1. 未使用git add 缓存代码"></a>1. 未使用git add 缓存代码</h3><p>使用git checkout – filename，注意中间有–</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>放弃所有文件修改 git checkout .</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br></pre></td></tr></table></figure><p>此命令用来放弃掉所有还没有加入到缓存区（就是 git add 命令）的修改：内容修改与整个文件删除<br>此命令不会删除新建的文件，因为新建的文件还没加入git管理系统中，所以对git来说是未知，只需手动删除即可</p><h3 id="2-已使用git-add-缓存代码，未使用git-commit"><a href="#2-已使用git-add-缓存代码，未使用git-commit" class="headerlink" title="2. 已使用git add 缓存代码，未使用git commit"></a>2. 已使用git add 缓存代码，未使用git commit</h3><p>使用 git reset HEAD filename</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD filename</span><br></pre></td></tr></table></figure><p>放弃所有文件修改 git reset HEAD</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure><p>此命令用来清除 git 对于文件修改的缓存。相当于撤销 git add 命令所在的工作。在使用本命令后，本地的修改并不会消失，而是回到了第一步1. 未使用git add 缓存代码，继续使用用git checkout – filename，就可以放弃本地修改</p><h3 id="3-已经用-git-commit-提交了代码"><a href="#3-已经用-git-commit-提交了代码" class="headerlink" title="3. 已经用 git commit 提交了代码"></a>3. 已经用 git commit 提交了代码</h3><p>使用 git reset –hard HEAD^ 来回退到上一次commit的状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>或者回退到任意版本git reset –hard commit id ，使用git log命令查看git提交历史和commit id</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit id</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-未使用git-add-缓存代码&quot;&gt;&lt;a href=&quot;#1-未使用git-add-缓存代码&quot; class=&quot;headerlink&quot; title=&quot;1. 未使用git add 缓存代码&quot;&gt;&lt;/a&gt;1. 未使用git add 缓存代码&lt;/h3&gt;&lt;p&gt;使用git ch
      
    
    </summary>
    
    
      <category term="git" scheme="http://blog.html-js.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>React深入</title>
    <link href="http://blog.html-js.site/2021/09/27/React%E6%B7%B1%E5%85%A5/"/>
    <id>http://blog.html-js.site/2021/09/27/React深入/</id>
    <published>2021-09-27T02:09:38.000Z</published>
    <updated>2022-08-19T02:24:34.480Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="https://mp.weixin.qq.com/s/vDJ_Txm4wi-cMVlX5xypLg" target="_blank" rel="noopener">【React深入】setState 的执行机制</a></li><li><a href="https://mp.weixin.qq.com/s/pffJQXw-x09t-46Ek-KYqg" target="_blank" rel="noopener">【React深入】React事件机制</a></li><li><a href="https://mp.weixin.qq.com/s/-xiHM6ydCxUSfoHlbB3dUQ" target="_blank" rel="noopener">【React深入】深入分析虚拟DOM的渲染过程和特性</a></li><li><a href="https://mp.weixin.qq.com/s/zhWs9NgjvM8Wy1vOVKKhHg" target="_blank" rel="noopener">【React深入】从Mixin到HOC再到Hook</a></li><li><a href="https://juejin.cn/post/7010539227284766751?utm_source=gold_browser_extension#comment" target="_blank" rel="noopener">React 运行时优化方案的演进</a></li></ul><p>卡颂 - <a href="https://react.iamkasong.com/#%E5%AF%BC%E5%AD%A6%E8%A7%86%E9%A2%91" target="_blank" rel="noopener">React 技术揭秘</a></p><p>7kms - <a href="https://github.com/7kms/react-illustration-series" target="_blank" rel="noopener">图解React源码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/vDJ_Txm4wi-cMVlX5xypLg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【React深入】setState 的执行机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="react" scheme="http://blog.html-js.site/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>探究setState的执行机制</title>
    <link href="http://blog.html-js.site/2021/09/23/%E6%8E%A2%E7%A9%B6setState%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://blog.html-js.site/2021/09/23/探究setState的执行机制/</id>
    <published>2021-09-23T03:15:39.000Z</published>
    <updated>2022-08-19T02:24:34.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、几个开发中经常会遇到的问题"><a href="#一、几个开发中经常会遇到的问题" class="headerlink" title="一、几个开发中经常会遇到的问题"></a>一、几个开发中经常会遇到的问题</h2><p>以下几个问题是我们在实际开发中经常会遇到的场景，下面用几个简单的示例代码来还原一下。</p><h3 id="1-setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以"><a href="#1-setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以" class="headerlink" title="1.setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?"></a>1.setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?</h3><h4 id="1-1-钩子函数和React合成事件中的-setState"><a href="#1-1-钩子函数和React合成事件中的-setState" class="headerlink" title="1.1 钩子函数和React合成事件中的 setState"></a>1.1 钩子函数和React合成事件中的 <code>setState</code></h4><p>现在有两个组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'parent componentDidMount'</span>);</span><br><span class="line">&#125;</span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;SetState1&gt;&lt;<span class="regexp">/SetState1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;SetState2&gt;&lt;/</span>SetState2&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>组件内部放入同样的代码，并在 <code>Setstate1</code>中的 <code>componentDidMount</code>中放入一段同步延时代码，打印延时时间：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'componentWillUpdate'</span>)</span><br><span class="line">&#125;</span><br><span class="line">componentDidUpdate()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'componentDidUpdate'</span>)</span><br><span class="line">&#125;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'SetState调用setState'</span>)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    index: <span class="keyword">this</span>.state.index + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'state'</span>, <span class="keyword">this</span>.state.index);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'SetState调用setState'</span>);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    index: <span class="keyword">this</span>.state.index + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'state), this.state.index'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是执行结果：<br><img src="/images/page/20210923/1.png" alt></p><p>说明：</p><ul><li>1.调用 setState不会立即更新</li><li>2.所有组件使用的是同一套更新机制，当所有组件 <code>didmount</code>后，父组件 <code>didmount</code>，然后执行更新</li><li>3.更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。</li></ul><a id="more"></a><h4 id="1-2-异步函数和原生事件中的-setstate？"><a href="#1-2-异步函数和原生事件中的-setstate？" class="headerlink" title="1.2 异步函数和原生事件中的 setstate？"></a>1.2 异步函数和原生事件中的 <code>setstate</code>？</h4><p>在 <code>setTimeout</code>中调用 <code>setState</code>（例子和在浏览器原生事件以及接口回调中执行效果相同）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用setState'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      index: <span class="keyword">this</span>.state.index + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'state'</span>, <span class="keyword">this</span>.state.index);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'调用setState'</span>);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      index: <span class="keyword">this</span>.state.index + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'state'</span>, <span class="keyword">this</span>.state.index);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="/images/page/20210923/2.png" alt></p><p>说明：</p><ul><li>1.在父组件 <code>didmount</code>后执行</li><li>2.调用 <code>setState</code> 同步更新</li></ul><h3 id="2-为什么有时连续两次-setState-只有一次生效？"><a href="#2-为什么有时连续两次-setState-只有一次生效？" class="headerlink" title="2.为什么有时连续两次 setState 只有一次生效？"></a>2.为什么有时连续两次 <code>setState</code> 只有一次生效？</h3><p>分别执行以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span> &#125;, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">index</span>: <span class="keyword">this</span>.state.index + <span class="number">1</span> &#125;, ()=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------</span><br><span class="line"></span><br><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState</span>) =&gt;</span> <span class="function">(<span class="params">&#123; index: preState.index + <span class="number">1</span> &#125;</span>), <span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index)</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState</span>) =&gt;</span> <span class="function">(<span class="params">&#123; index: preState.index + <span class="number">1</span> &#125;</span>), <span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.index)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>1.直接传递对象的 <code>setstate</code> 会被合并成一次</li><li>2.使用函数传递 <code>state</code> 不会被合并</li></ul><h2 id="二-setState执行过程"><a href="#二-setState执行过程" class="headerlink" title="二.setState执行过程"></a>二.setState执行过程</h2><p>由于源码比较复杂，就不贴在这里了，有兴趣的可以去 github上 clone一份然后按照下面的流程图去走一遍。</p><h3 id="1-流程图"><a href="#1-流程图" class="headerlink" title="1.流程图"></a>1.流程图</h3><p><img src="/images/page/20210923/3.webp" alt></p><ul><li><code>partialState</code>： <code>setState</code>传入的第一个参数，对象或函数</li><li><code>_pendingStateQueue</code>：当前组件等待执行更新的 state队列</li><li><code>isBatchingUpdates</code>：<code>react</code>用于标识当前是否处于批量更新状态，所有组件公用</li><li><code>dirtyComponent</code>：当前所有处于待更新状态的组件队列</li><li><code>transcation</code>：<code>react</code>的事务机制，在被事务调用的方法外包装n个 <code>waper</code>对象，并一次执行： <code>waper.init</code>、被调用方法、 <code>waper.close</code></li><li><code>FLUSH_BATCHED_UPDATES</code>：用于执行更新的 <code>waper</code>，只有一个 <code>close</code>方法</li></ul><h3 id="2-执行过程"><a href="#2-执行过程" class="headerlink" title="2.执行过程"></a>2.执行过程</h3><p>对照上面流程图的文字说明，大概可分为以下几步：</p><ul><li>1.将<code>setState</code>传入的 <code>partialState</code>参数存储在当前组件实例的<code>state</code>暂存队列中。</li><li>2.判断当前<code>React</code>是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。</li><li>3.如果未处于批量更新状态，将批量更新状态标识设置为<code>true</code>，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。</li><li>4.调用事务的 <code>waper</code>方法，遍历待更新组件队列依次执行更新。</li><li>5.执行生命周期 <code>componentWillReceiveProps</code>。</li><li>6.将组件的<code>state</code>暂存队列中的 <code>state</code>进行合并，获得最终要更新的<code>state</code>对象，并将队列置为空。</li><li>7.执行生命周期 <code>componentShouldUpdate</code>，根据返回值判断是否要继续更新。</li><li>8.执行生命周期 <code>componentWillUpdate</code>。</li><li>9.执行真正的更新， <code>render</code>。</li><li>10.执行生命周期 <code>componentDidUpdate</code>。</li></ul><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三.总结"></a>三.总结</h2><h3 id="1-钩子函数和合成事件中："><a href="#1-钩子函数和合成事件中：" class="headerlink" title="1.钩子函数和合成事件中："></a>1.钩子函数和合成事件中：</h3><p>在 <code>react</code>的生命周期和合成事件中， <code>react</code>仍然处于他的更新机制中，这时 <code>isBranchUpdate</code>为<code>true</code>。</p><p>按照上述过程，这时无论调用多少次 <code>setState</code>，都会不会执行更新，而是将要更新的 <code>state</code>存入 <code>_pendingStateQueue</code>，将要更新的组件存入<code>dirtyComponent</code>。</p><p>当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件 <code>didmount</code>后会将 <code>isBranchUpdate</code>设置为<code>false</code>。这时将执行之前累积的 <code>setState</code>。</p><h3 id="2-异步函数和原生事件中"><a href="#2-异步函数和原生事件中" class="headerlink" title="2.异步函数和原生事件中"></a>2.异步函数和原生事件中</h3><p>由执行机制看， <code>setState</code>本身并不是异步的，而是如果在调用 <code>setState</code>时，如果 <code>react</code>正处于更新过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。</p><p>在生命周期，根据JS的异步机制，会将异步函数先暂存，等所有同步代码执行完毕后在执行，这时上一次更新过程已经执行完毕， <code>isBranchUpdate</code>被设置为<code>false</code>，根据上面的流程，这时再调用 <code>setState</code>即可立即执行更新，拿到更新结果。</p><h3 id="3-partialState合并机制"><a href="#3-partialState合并机制" class="headerlink" title="3. partialState合并机制"></a>3. <code>partialState</code>合并机制</h3><p>我们看下流程中 <code>_processPendingState</code>的代码，这个函数是用来合并 <code>state</code>暂存队列的，最后返回一个合并后的 <code>state</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_processPendingState: <span class="function"><span class="keyword">function</span> (<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">  <span class="keyword">var</span> queue = <span class="keyword">this</span>._pendingStateQueue;</span><br><span class="line">  <span class="keyword">var</span> replace = <span class="keyword">this</span>._pendingReplaceState;</span><br><span class="line">  <span class="keyword">this</span>._pendingReplaceState = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>._pendingStateQueue = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (!queue) &#123;</span><br><span class="line">    <span class="keyword">return</span> inst.state</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (replace &amp;&amp; queue.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> nextState = _assign(&#123;&#125;, replace ? queue[<span class="number">0</span>] : inst.state );</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = replace ? <span class="number">1</span> : <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> partial = queue[i];</span><br><span class="line">    _assign(nextState, <span class="keyword">typeof</span> partial === <span class="string">'function'</span> ? partial.call(inst, nextState, props, context) : partial );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nextState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要关注下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_assign(nextState, <span class="keyword">typeof</span> partial === <span class="string">'function'</span> ? partial.call(inst, nextState, props, context) : partial );</span><br></pre></td></tr></table></figure><p>如果传入的是对象，很明显会被合并成一次：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">  nextState,</span><br><span class="line">  &#123;<span class="attr">index</span>: state.index + <span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">index</span>: state.index + <span class="number">1</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果传入的是函数，函数的参数<code>preState</code>是前一次合并后的结果，所以计算结果是准确的。</p><h3 id="4-componentDidMount调用-setstate"><a href="#4-componentDidMount调用-setstate" class="headerlink" title="4. componentDidMount调用 setstate"></a>4. <code>componentDidMount</code>调用 <code>setstate</code></h3><blockquote><p>在componentDidMount()中，你 可以立即调用setState()。它将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了在此情况下即使render()将会调用两次，用户也不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题。在大多数情况下，你可以 在constructor()中使用赋值初始状态来代替。然而，有些情况下必须这样，比如像模态框和工具提示框。这时，你需要先测量这些DOM节点，才能渲染依赖尺寸或者位置的某些东西。</p></blockquote><p>以上是官方文档的说明，不推荐直接在 <code>componentDidMount</code>直接调用 <code>setState</code>，由上面的分析： <code>componentDidMount</code>本身处于一次更新中，我们又调用了一次 <code>setState</code>，就会在未来再进行一次 <code>render</code>，造成不必要的性能浪费，大多数情况可以设置初始值来搞定。</p><p>当然在 <code>componentDidMount</code>我们可以调用接口，再回调中去修改 <code>state</code>，这是正确的做法。</p><p>当<code>state</code>初始值依赖<code>dom</code>属性时，在 <code>componentDidMount</code>中 <code>setState</code>是无法避免的。</p><h3 id="5-componentWillUpdate-componentDidUpdate"><a href="#5-componentWillUpdate-componentDidUpdate" class="headerlink" title="5. componentWillUpdate componentDidUpdate"></a>5. <code>componentWillUpdate</code> <code>componentDidUpdate</code></h3><p>这两个生命周期中不能调用 <code>setState</code>。</p><p>由上面的流程图很容易发现，在它们里面调用 <code>setState</code>会造成死循环，导致程序崩溃。</p><h3 id="6-推荐使用方式"><a href="#6-推荐使用方式" class="headerlink" title="6.推荐使用方式"></a>6.推荐使用方式</h3><p>在调用 <code>setState</code>时使用函数传递 <code>state</code>值，在回调函数中获取最新更新后的 <code>state</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、几个开发中经常会遇到的问题&quot;&gt;&lt;a href=&quot;#一、几个开发中经常会遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;一、几个开发中经常会遇到的问题&quot;&gt;&lt;/a&gt;一、几个开发中经常会遇到的问题&lt;/h2&gt;&lt;p&gt;以下几个问题是我们在实际开发中经常会遇到的场景，下面用几个简单的示例代码来还原一下。&lt;/p&gt;
&lt;h3 id=&quot;1-setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以&quot;&gt;&lt;a href=&quot;#1-setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以&quot; class=&quot;headerlink&quot; title=&quot;1.setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?&quot;&gt;&lt;/a&gt;1.setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?&lt;/h3&gt;&lt;h4 id=&quot;1-1-钩子函数和React合成事件中的-setState&quot;&gt;&lt;a href=&quot;#1-1-钩子函数和React合成事件中的-setState&quot; class=&quot;headerlink&quot; title=&quot;1.1 钩子函数和React合成事件中的 setState&quot;&gt;&lt;/a&gt;1.1 钩子函数和React合成事件中的 &lt;code&gt;setState&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;现在有两个组件&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;componentDidMount() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;parent componentDidMount&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;render()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;SetState1&amp;gt;&amp;lt;&lt;span class=&quot;regexp&quot;&gt;/SetState1&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;      &amp;lt;SetState2&amp;gt;&amp;lt;/&lt;/span&gt;SetState2&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;&lt;span class=&quot;regexp&quot;&gt;/div&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;  )&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;regexp&quot;&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;组件内部放入同样的代码，并在 &lt;code&gt;Setstate1&lt;/code&gt;中的 &lt;code&gt;componentDidMount&lt;/code&gt;中放入一段同步延时代码，打印延时时间：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;componentWillUpdate()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;componentWillUpdate&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;componentDidUpdate()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;componentDidUpdate&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;componentDidMount()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;SetState调用setState&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setState(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    index: &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state.index + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;state&#39;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state.index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;SetState调用setState&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setState(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    index: &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state.index + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;state), this.state.index&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下面是执行结果：&lt;br&gt;&lt;img src=&quot;/images/page/20210923/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.调用 setState不会立即更新&lt;/li&gt;
&lt;li&gt;2.所有组件使用的是同一套更新机制，当所有组件 &lt;code&gt;didmount&lt;/code&gt;后，父组件 &lt;code&gt;didmount&lt;/code&gt;，然后执行更新&lt;/li&gt;
&lt;li&gt;3.更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="react" scheme="http://blog.html-js.site/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>谈谈对前端框架的理解</title>
    <link href="http://blog.html-js.site/2021/09/13/%E8%B0%88%E8%B0%88%E5%AF%B9%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://blog.html-js.site/2021/09/13/谈谈对前端框架的理解/</id>
    <published>2021-09-13T06:58:27.000Z</published>
    <updated>2022-08-19T02:24:34.490Z</updated>
    
    <content type="html"><![CDATA[<p>最早的时候页面是服务端渲染的，也就是 PHP、JSP 那些技术，服务端通过模版引擎填充数据，返回生成的 html，交给浏览器渲染。那时候表单会同步提交，服务端返回结果页面的 html。</p><p>后来浏览器有了 ajax 技术，可以异步的请求，服务端返回 xml 或者 json。ajax 最早是基于 xml 的，这也是它名字的由来。因为 xml 多了很多没必要的标签，内容比较多，所以后来 json 流行开来。</p><p>网页和服务端的数据交互变成了异步的，可以服务端返回 json 数据，浏览器里拼接 html，之后渲染（浏览器里面生成 dom 就等同于渲染）。页面基本没啥刷新的必要了，于是后来就逐渐演变出了单页应用 SPA（single page application）。</p><p>早期开发页面的时候就是基于浏览器的 dom api 操作 dom 来做渲染和交互，但是 dom api 比较啰嗦，而且当时浏览器的兼容性问题也比较麻烦，不同浏览器有不同的写法。为了简化 dom 操作和更方便的兼容各种浏览器，出现了 jquery 并且迅速流行开来，那个时代 jquery 是如日中天的。</p><p>我一直习惯把网页分为物理层和逻辑层，dom 就算是物理层，jquery 是操作 dom 的一系列工具函数，也是工作在物理层。</p><p>网页做的事情基本就是拿到数据渲染 dom，并且数据改变之后更新 dom，这个流程是通用的，后来逐渐出现了 mvvm 框架，来自动把数据的变更映射到 dom，不再需要手动操作 dom。也就是 vue、react 等现代的前端框架。我把这一层叫做逻辑层。</p><p>前端框架除了提供了数据驱动视图变化的功能以外，还支持了 dom 的逻辑划分，可以把一部分 dom 封装成组件，组件和组件之间相互组合，构成整个界面。物理层依然是 dom，只是实现了数据到 dom 的自动映射之后，我们只需要在逻辑层写组件就可以了。</p><p>现在前端入门也不会再学物理层的操作 dom 的 jquery 了，而是直接从 vue、react 这种逻辑层的前端框架开始。</p><p><a href="https://nodejs.org/download/release/v12.22.4/node-v12.22.4-linux-x64.tar.xz" target="_blank" rel="noopener">https://nodejs.org/download/release/v12.22.4/node-v12.22.4-linux-x64.tar.xz</a><br>wget <a href="https://nodejs.org/dist/v6.9.5/node-v6.9.5-linux-x64.tar.xz" target="_blank" rel="noopener">https://nodejs.org/dist/v6.9.5/node-v6.9.5-linux-x64.tar.xz</a></p><p>tar xvf node-v12.22.4-linux-x64.tar.xz<br>ln -sf /opt/node/node-v12.22.4-linux-x64/bin/node /usr/local/bin/node<br>ln -sf /opt/node/node-v12.22.4-linux-x64/bin/npm /usr/local/bin/npm<br><a id="more"></a></p><p>但是也不是说完全不需要 jquery，前端框架主要解决的是数据到 dom 的绑定，可以变化以后自动更新 dom。如果不需要更新，那么直接操作 dom 即可，比如各种活动页，没啥数据更新，用 jquery 操作 dom 还是很方便。</p><p>前端框架是 UI = f(state) 这种声明式的思想，只需要声明组件的视图、组件的状态数据、组件之间的依赖关系，那么状态改变就会自动的更新 dom。而 jquery 那种直接操作 dom 的工具函数库则是命令式的。</p><p>对于视图的描述这件事 react 和 vue 用了不同的方案，react 是给 js 扩展了 jsx 的语法，由 babel 实现，可以在描述视图的时候直接用 js 来写逻辑，没啥新语法。而 vue 是实现了一套 template 的 DSL，引入了插值、指令、过滤器等模版语法，相对于 jsx 来说更简洁，template 的编译器由 vue 实现。</p><p>vue template 是受限制的，只能访问 data，prop、method，可以静态的分析和优化，而 react 的 jsx 因为直接是 js 的语法，动态逻辑比较多，没法静态的做分析和优化。</p><p>但是 vue template 也不全是好处，因为和 js 上下文割裂开来，引入 typescript 做类型推导的时候就比较困难，需要单独把所有 prop、method、data 的类型声明一遍才行。而 react 的 jsx 本来就是和 js 同一个上下文，结合 typescript 就很自然。</p><p>所以 vue template 和 react jsx 各有优缺点。</p><p>前端框架都是数据驱动视图变化的，而这个数据分散在每个组件中，怎么在数据变化以后更新 dom 呢？</p><p>数据变化的检测基本只有三种方式：watch、脏检查、不检查。</p><p>vue 就是基于数据的 watch 的，组件级别通过 Object.defineProperty 监听对象属性的变化，重写数组的 api 监听数组元素的变化，之后进行 dom 的更新。</p><p>angular 则是基于脏检查，在每个可能改变数据的逻辑之后都对比下数据是否变了，变了的话就去更新 dom。</p><p>react 则是不检查，不检查难道每次都渲染全部的 dom 么？ 也不是，不检查是因为不直接渲染到 dom，而是中间加了一层虚拟 dom，每次都渲染成这个虚拟 dom，然后 diff 下渲染出的虚拟 dom 是否变了，变了的话就去更新对应的 dom。</p><p>这就是前端框架的数据驱动视图变化的三种思路。</p><p>vue 是组件级别的数据 watch，当组件内部监听数据变化的地方特别多的时候，一次更新可能计算量特别大，计算量大了就可能会导致丢帧，也就是渲染的卡顿。所以 vue 的优化方式就是把大组件拆成小组件，这样每个数据就不会有太多的 watcher 了。</p><p>react 并不监听数据的变化，而是渲染出整个虚拟 dom，然后 diff。基于这种方案的优化方式就是对于不需要重新生成 vdom 的组件，通过 shouldComponentUpdate 来跳过渲染。</p><p>但是当应用的组件树特别大的时候，只是 shouldComponentUpdate 跳过部分组件渲染，依然可能计算量特别大。计算量大了同样可能导致渲染的卡顿，怎么办呢？<br>树的遍历有深度优先和广度优先两种方式，组件树的渲染就是深度优先的，一般是通过递归来做，但是如果能通过链表记录下路径，就可以变成循环。变成了循环，那么就可以按照时间片分段，让 vdom 的生成不再阻塞页面渲染，这就像操作系统对多个进程的分时调度一样。</p><p>这个通过把组件树改成链表，把 vdom 的生成从递归改循环的功能就是 react fiber。</p><p><img src="/images/page/20210914/1.png" alt></p><p>fiber 节点相对于之前的组件节点来说，没有了 parent、children 这种属性，多了 child、sibling、return 属性。<br>通过 fiber 链表树，优化了渲染的性能。</p><p>可以看到 vue 的性能优化和 react 的性能优化是不一样的：</p><p>vue 是组件级别的数据监听的方案，问题可能出现在一个属性太多 watcher 的时候，所以优化思路就是大组件拆分成小组件，保证每个属性不要有太多 watcher。</p><p>react 不监听、不检查数据变化，每次都渲染生成 vdom，然后进行 vdom 的对比，那么优化的思路就是 shouldComponentUpdate 来跳过部分组件的 render，而且 react 内部也做了组件树的链表化（fiber）来把递归改成可打断的渲染，按照时间片来逐渐生成整个 vdom。</p><p>组件之间难免要有逻辑的复用，react 和 vue 有不同的方案：</p><p>vue 的组件是 option 对象的方式，那么逻辑复用方式很自然可以想到通过对象属性的 mixin，vue2 的组件内逻辑复用方案就是 mixin，但是 mixin 很难区分混入的属性、方法的来源，比较乱，代码维护性差。但也没有更好的方案。</p><p>react 刚开始也是支持 mixin 的，但后来废弃了。</p><p>react 的组件是 class 和 function 两种形式，那么类似高阶函数的高阶组件（high order component）的方式就比较自然，也就是组件套组件，在父组件里面执行一部分逻辑，然后渲染子组件。</p><p>除了多加一层组件的 HOC 方式以外，没有逻辑的部分可以直接把那部分 jsx 作为 props 传入另一个组件来复用，也就是 render props。</p><p>HOC 和 render props 是 react 的 class 组件支持的两种逻辑复用方案。</p><p>最开始的 function 组件是没有状态的，只是作为 class 组件渲染的辅助而存在。</p><p>但是 HOC 的逻辑复用方式最终导致了组件嵌套太深，而且 class 内部生命周期比较多，逻辑都放在一起导致了组件比较大。</p><p>怎么解决 class 组件嵌套深和组件大的问题呢？而且还不能引入破坏性的更新，不然下场可能会很惨。</p><p>于是 react 团队就瞅准了 function 组件，能不能在 function 组件里面也支持 state，通过扩展一些 api 的方式来支持，也不是破坏性的更新。</p><p>function 组件要支持 state，那 state 存在哪里呢？</p><p>class 组件节点有 state，变成 fiber 节点之后依然有，function 组件本来就没有 state，那么 fiber 节点中同样也没有。</p><p>那在 function 组件的 fiber 节点中加入 state 不就行了？</p><p>于是 react 就在 function 组件的 fiber 节点中加入了 memorizedState 属性用来存储数据，然后在 function 组件里面通过 api 来使用这些数据，这些 api 被叫做 hooks api。</p><p>因为是使用 fiber 节点上的数据，就把 api 命名为了 useXxx。</p><p>每个 hooks api 都要有自己存放数据的地方，怎么组织呢？有两种方案，一种是 map，一种是数组。</p><p>用 map 的话那么要 hooks api 要指定 key，按照 key 来存取 fiber 节点中的数据。</p><p>用数组的话顺序不能变，所以 hooks api 不能出现在 if 等逻辑块中，只能在顶层。</p><p>为了简化使用， hooks 最终使用了数组的方式。当然，实现起来用的是链表。</p><p>每个 hooks api 取对应的 fiber.memoriedState 中的数据来用。</p><p>hooks api 可以分为 3 类：</p><p>第一类是数据类的：</p><ul><li>useState： 在 fiber.memoriedState 的对应元素中存放数据</li><li>useMemo：在 fiber.memoriedState 的对应元素中存放数据，值是缓存的函数计算的结果，在 state 变化后重新计算值</li><li>useCallback：在 fiber.memoriedState 的对应元素中存放数据，值是函数，在 state 变化后重新执行函数，是 useMemo 在值为函数的场景下的简化 api，比如 useCallback(fn, [a,b]) 相当于 useMemo(() =&gt; fn, [a, b])</li><li>useReducer：在 fiber.memoriedState 的对应元素中存放数据，值为 reducer 返回的结果，可以通过 action 来触发值的变更</li><li>useRef：在 fiber.memoriedState 的对应元素中存放数据，值为 {current: 具体值} 的形式，因为对象不变，只是 current 属性变了，所以不会修改。</li></ul><p>useState 是存储值最简单的方式，useMemo 是基于 state 执行函数并且缓存结果，相当于 vue 的 getter，useCallback 是一种针对值为函数的情况的简化，useReducer 是通过 action 来触发值的修改。useRef 包了一层对象，每次对比都是同一个，所以可以放一些不变的数据。<br>不管形式怎么样，这些 hooks 的 api 的作用都是返回值的。</p><p>第二类是逻辑类的：</p><ul><li>useEffect：异步执行函数，当依赖 state 变化之后会再次执行，当组件销毁的时候会调用返回的清理函数</li><li>useLayoutEffect： 在渲染完成后同步执行函数，可以拿到 dom</li></ul><p>这两个 hooks api 都是用于执行逻辑的，不需要等渲染完的逻辑都可以放到 useEffect 里。</p><p>第三类是 ref 转发专用的：<br>数据可以通过各种方案共享，但是 dom 元素这种就得通过 ref 转发了，所谓的 ref 转发就是在父组件创建 ref，然后子组件把元素传过去。传过去之前想做一些修改，就可以用 useImperativeHandle 来改。</p><p>通过这 3 类 hooks api，以及之后会添加的更多 hooks api ，函数组件里面也能做 state 的存储，也能在一些阶段执行一段逻辑，是可以替代 class 组件的方案了。</p><p>而且更重要的是，hooks api 是传递参数的函数调用的形式，可以对 hooks api 进一步封装成功能更强大的函数，也就是自定义 hooks。通过这种方式就可以做跨组件的逻辑复用了。</p><p>再回头看一下最开始要解决的 class 组件嵌套过深和组件太大的问题，通过 hooks 都能解决：</p><ul><li>逻辑扩展不需要嵌套 hoc 了，多调用一个自定义的 hooks 就行</li><li>组件的逻辑也不用都写在 class 里了，完全可以抽离成不同的 hooks</li></ul><p>react 通过 function 组件的 hooks api 解决了 class 组件的逻辑复用方案的问题。（fiber 是解决性能问题的，而 hooks 是解决逻辑复用问题的）</p><p>vue2 中是通过 mixin 的方式来复用逻辑的，也有组件太大的问题，在 vue3 中也可以通过类似的思路来解决。</p><p>为了体验和原生更接近，现在基本都是不刷新页面的单页应用，都是从服务端取数据然后驱动 dom 变化的 浏览器渲染(csr)方案。但对于一些低端机，仍然需要服务端渲染(ssr)的方案。但不能回到 jsp、php 时代的那种模版引擎服务端渲染了，而是要基于同一个组件树，把它渲染成字符串。服务端渲染和浏览器渲染都用同样的组件代码，这就是同构的方案。</p><p>技术从出现到完善到连带的周边生态的完善是一个轮回，从最开始服务端渲染，到了后来的客户端渲染，然后出现了逻辑层的组件方案，最后又要基于组件方案重新实现服务端渲染。其实物理层的东西一直都没变，只是逻辑层不断的一层添加又一层，目的都是为了提高生产效率，降低开发成本，保证质量，这也是技术发展的趋势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早的时候页面是服务端渲染的，也就是 PHP、JSP 那些技术，服务端通过模版引擎填充数据，返回生成的 html，交给浏览器渲染。那时候表单会同步提交，服务端返回结果页面的 html。&lt;/p&gt;
&lt;p&gt;后来浏览器有了 ajax 技术，可以异步的请求，服务端返回 xml 或者 json。ajax 最早是基于 xml 的，这也是它名字的由来。因为 xml 多了很多没必要的标签，内容比较多，所以后来 json 流行开来。&lt;/p&gt;
&lt;p&gt;网页和服务端的数据交互变成了异步的，可以服务端返回 json 数据，浏览器里拼接 html，之后渲染（浏览器里面生成 dom 就等同于渲染）。页面基本没啥刷新的必要了，于是后来就逐渐演变出了单页应用 SPA（single page application）。&lt;/p&gt;
&lt;p&gt;早期开发页面的时候就是基于浏览器的 dom api 操作 dom 来做渲染和交互，但是 dom api 比较啰嗦，而且当时浏览器的兼容性问题也比较麻烦，不同浏览器有不同的写法。为了简化 dom 操作和更方便的兼容各种浏览器，出现了 jquery 并且迅速流行开来，那个时代 jquery 是如日中天的。&lt;/p&gt;
&lt;p&gt;我一直习惯把网页分为物理层和逻辑层，dom 就算是物理层，jquery 是操作 dom 的一系列工具函数，也是工作在物理层。&lt;/p&gt;
&lt;p&gt;网页做的事情基本就是拿到数据渲染 dom，并且数据改变之后更新 dom，这个流程是通用的，后来逐渐出现了 mvvm 框架，来自动把数据的变更映射到 dom，不再需要手动操作 dom。也就是 vue、react 等现代的前端框架。我把这一层叫做逻辑层。&lt;/p&gt;
&lt;p&gt;前端框架除了提供了数据驱动视图变化的功能以外，还支持了 dom 的逻辑划分，可以把一部分 dom 封装成组件，组件和组件之间相互组合，构成整个界面。物理层依然是 dom，只是实现了数据到 dom 的自动映射之后，我们只需要在逻辑层写组件就可以了。&lt;/p&gt;
&lt;p&gt;现在前端入门也不会再学物理层的操作 dom 的 jquery 了，而是直接从 vue、react 这种逻辑层的前端框架开始。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/download/release/v12.22.4/node-v12.22.4-linux-x64.tar.xz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nodejs.org/download/release/v12.22.4/node-v12.22.4-linux-x64.tar.xz&lt;/a&gt;&lt;br&gt;wget &lt;a href=&quot;https://nodejs.org/dist/v6.9.5/node-v6.9.5-linux-x64.tar.xz&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://nodejs.org/dist/v6.9.5/node-v6.9.5-linux-x64.tar.xz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;tar xvf node-v12.22.4-linux-x64.tar.xz&lt;br&gt;ln -sf /opt/node/node-v12.22.4-linux-x64/bin/node /usr/local/bin/node&lt;br&gt;ln -sf /opt/node/node-v12.22.4-linux-x64/bin/npm /usr/local/bin/npm&lt;br&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://blog.html-js.site/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins自动化构建</title>
    <link href="http://blog.html-js.site/2021/09/09/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/"/>
    <id>http://blog.html-js.site/2021/09/09/Jenkins自动化构建/</id>
    <published>2021-09-09T08:46:46.000Z</published>
    <updated>2022-08-19T02:24:34.479Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/5f671aca2b5a" target="_blank" rel="noopener">https://www.jianshu.com/p/5f671aca2b5a</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/5f671aca2b5a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/5f671aca2b5a&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://blog.html-js.site/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="http://blog.html-js.site/2021/09/09/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://blog.html-js.site/2021/09/09/前端工程化/</id>
    <published>2021-09-09T08:45:27.000Z</published>
    <updated>2022-08-19T02:24:34.485Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7017710911443959839?utm_source=gold_browser_extension#heading-18" target="_blank" rel="noopener">前端部署方案</a></p><h2 id="关于部署的总结"><a href="#关于部署的总结" class="headerlink" title="关于部署的总结"></a>关于部署的总结</h2><h3 id="静态资源组织部分"><a href="#静态资源组织部分" class="headerlink" title="静态资源组织部分"></a>静态资源组织部分</h3><ol><li>为了最大程度利用缓存，将页面(HTML)设置为协商缓存，将 JavaScript、CSS 等设置为永久强缓存。</li><li>为了解决强缓存更新问题，将文件摘要（hash）作为资源路径(URL)构成的一部分。</li><li>为了解决覆盖式发布引发的问题，采用 name-hash 而非 query-hash 的组织方式，具体需要配置 webpack 的 output.filename 为 contenthash 方式。</li><li>为了解决 Nginx 目录存储过大 + 结合 CDN 提升访问速度，采用了 Nginx 反向代理+ 将静态资源上传到 CDN。</li><li>为了上传 CDN，我们需要按环境动态构造 publicPath + 按环境构造 CDN 上传目录并上传。</li><li>为了动态构造 publicPath 并且随构建过程插入到 HTML 中，采用 Webpack-HTML-Plugin 等插件，将编译好的带 hash + publicPath 的静态资源插入到 HTML 中。</li><li>为了保证上传 CDN 的安全，我们需要一种机制管控上传 CDN 秘钥，而非简单的将秘钥写到代码 / Dockerfile 等明文文件中。</li></ol><h3 id="自动化部署部分"><a href="#自动化部署部分" class="headerlink" title="自动化部署部分"></a>自动化部署部分</h3><p>为了提升部署效率，100% 避免因部署出错，需要设计 &amp; 搭建自动化部署平台，以 Docker 等保证环境的一致性，以 Jenkins 等保证构建流程的串联。使用es-build等提升构建效率。</p><h3 id="前端部署-amp-静态资源加工"><a href="#前端部署-amp-静态资源加工" class="headerlink" title="前端部署 &amp; 静态资源加工"></a>前端部署 &amp; 静态资源加工</h3><p>关于前端部署，能总结出下面几个原则/要求：</p><ol><li>构建发布后，不应该被覆盖。</li><li>构建发布后，静态资源应当永久保存在服务器/CDN 上，即只可读。</li><li>静态资源组织上，每个版本应该按文件夹存储，做到资源收敛。这样假如真要删除时，可按版本删除。（如某个版本代码泄密）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> CDN_HOST = process.env.CDN_HOST;<span class="comment">// CDN 域名</span></span><br><span class="line"><span class="keyword">const</span> CDN_PATH = process.env.CDN_PATH<span class="string">''</span>; <span class="comment">// CDN 路径</span></span><br><span class="line"><span class="keyword">const</span> ENV = process.env.ENV; <span class="comment">// 当前的环境等等</span></span><br><span class="line"><span class="keyword">const</span> VERSION = process.env.VERSION; <span class="comment">// 当前发布的版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPublicPath = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Some code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;CDN_HOST&#125;</span>/<span class="subst">$&#123;CDN_PATH&#125;</span>/<span class="subst">$&#123;ENV&#125;</span>/<span class="subst">$&#123;VERSION&#125;</span>/`</span>;<span class="comment">// 依据 ENV 等动态构造 publicPath</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.[name][contenthash].js'</span>,</span><br><span class="line">        publicPath: getPublicPath(),</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>故 publicPath 应增加 version 字段</p></blockquote><ol start="4"><li>发布过程应该自动化，开发人员不应该直接接触服务器。</li><li>版本切换时，也应当不接触服务器。</li><li>版本切换能秒级生效。（如 v0.2 切换 v0.3，立即生效）。</li><li>线上需要能同时生效多个版本，满足 AB 测试、灰度、PRE 环境等小流量需求。</li></ol><p>上述需求都相对复杂多变，为了应对复杂的线上需求，可以对静态资源做深度加工，如通过服务端直出 HTML、通过配置中心实现按用户 PRE 等等。</p><h3 id="前端发布服务"><a href="#前端发布服务" class="headerlink" title="前端发布服务"></a>前端发布服务</h3><p>面对复杂的商业化需求，方便多前端业务实现版本管理、灰度、PRE、AB 测试等小流量功能，我们设计了一个中间服务 PageConfig Web &amp; PageServer，与 Nginx 和各种后端相结合，达到配置即时生效的能力。</p><h2 id="灵魂拷问的部分答案"><a href="#灵魂拷问的部分答案" class="headerlink" title="灵魂拷问的部分答案"></a>灵魂拷问的部分答案</h2><p>Q: 前端代码从 tsx/jsx 到部署上线被用户访问，中间大致会经历哪些过程？<br>A: 经历本地开发、远程构建打包部署、安全检查、上传CDN、Nginx做流量转发、对静态资源做若干加工处理等过程。<br>Q：可能大部分同学都知道强缓存/协商缓存，那前端各种产物（HTML、JS、CSS、IMAGES 等）应该用什么缓存策略？以及为什么？</p><p>– 若使用协商缓存，但静态资源却不频繁更新，如何避免协商过程的请求浪费？<br>– 若使用强缓存，那静态资源如何更新？</p><p>A：HTML使用协商缓存，静态资源使用强缓存，使用name-hash（非覆盖式发布）解决静态资源更新问题。<br>Q：配套的，前端静态资源应该如何组织？<br>A：搭配 Webpack 的Webpack_HTML-Plugin &amp; 配置 output publicPath等。<br>Q：配套的，自动化构建 &amp; 部署过程如何与 CDN 结合？<br>A：自动化构建打包后，将产物传输到对应环境 URL 的CDN上。<br>Q：如何避免前端上线，影响未刷新页面的用户？<br>A：使用name-hash方式组织静态资源，先上线静态资源，再上线HTML。<br>Q：刚上线的版本发现有阻塞性 bug，如何做到秒级回滚，而非再次部署等 20 分钟甚至更久？<br>A：HTML文件使用非覆盖方式存储在CDN上，搭建前端发布服务，对 HTML 按版本等做缓存加工处理。当需要回滚时，更改发布服务HTMl指向即可。<br>Q: CDN 域名突然挂了，如何实现秒级 CDN 降级修补而非再次全部业务重新部署一次？<br>A1: 将静态资源传输到多个 CDN 上，并开发一个加载Script的SDK集成到HTML中。当发现CDN资源加载失败时，逐步降级CDN域名。<br>A2：在前端发布服务中，增加HTML文本处理环节，如增加CDN域名替换，发生异常时，在发布服务中一键设置即可。<br>Q：如何实现一个预发环境，除了前端资源外都是线上环境，将变量控制前端环境内？<br>A：对静态资源做加工，对HTML入口做小流量。<br>Q：部署环节如何方便配套做 AB 测试等？<br>A：参见前端发布服务<br>Q：如何实现一套前端代码，发布成多套环境产物？<br>A：使用环境变量，将当前环境、CDN、CDN_HOST、Version等注入环境变量中，构建时消费 &amp; 将产物上传不同的CDN即可。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果想深入学习前端部署，下面是一些学习建议。</p><ol><li>学习负载均衡（要求：了解）。<br>学习和了解负载均衡的原理、都有哪些配置玩法。如参考<a href="https://www.jianshu.com/p/215b5575107c" target="_blank" rel="noopener">大型网站架构系列：负载均衡详解</a></li><li>深入学习 HTTP（要求：熟练掌握）<br>如掌握常见的状态码、常见的 Header 及其深度应用、强缓存/协商缓存、HTTP2 的新增功能等等。尤其HTTP 1.1 和 HTTP 2.0。<br>推荐书籍：<br><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">图解HTTP</a><br><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener">HTTP 权威指南</a></li><li>深入学习前端工程化 （要求：精通）<br>– 了解前端工程化可以做什么，如 <a href="https://book.douban.com/subject/27605366/" target="_blank" rel="noopener">前端工程化：体系设计与实践</a><br>– 掌握前端工程师的常见实践原理 &amp; 实操<br>– 深度学习 Webpack <a href="https://webpack.docschina.org/guides/" target="_blank" rel="noopener">Webpack 官方文档</a></li><li>学习各种对前端静态资源加工的各种方案（要求：掌握）</li><li>深度学习浏览器原理 （要求：精通）<br>一些资料：<a href="https://segmentfault.com/a/1190000012925872" target="_blank" rel="noopener">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7017710911443959839?utm_source=gold_browser_extension#heading-18&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端部署方案&lt;/
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://blog.html-js.site/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
</feed>

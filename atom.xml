<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>前端-洋洋</title>
  <subtitle>专注于前端</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://html-js.site/"/>
  <updated>2016-09-18T06:43:23.007Z</updated>
  <id>http://html-js.site/</id>
  
  <author>
    <name>wangyang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git 推送和删除远程标签</title>
    <link href="http://html-js.site/2016/09/18/Git-%E6%8E%A8%E9%80%81%E5%92%8C%E5%88%A0%E9%99%A4%E8%BF%9C%E7%A8%8B%E6%A0%87%E7%AD%BE/"/>
    <id>http://html-js.site/2016/09/18/Git-推送和删除远程标签/</id>
    <published>2016-09-18T06:34:41.000Z</published>
    <updated>2016-09-18T06:43:23.007Z</updated>
    
    <content type="html"><![CDATA[<p>事实上Git 的推送和删除远程标签命令是相同的，删除操作实际上就是推送空的源标签refs：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 标签名</span><br></pre></td></tr></table></figure>
<p>相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin refs/tags/源标签名:refs/tags/目的标签名</span><br></pre></td></tr></table></figure></p>
<p>推送标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin 标签名</span><br></pre></td></tr></table></figure></p>
<p>删除本地标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d 标签名</span><br></pre></td></tr></table></figure></p>
<p>删除远程标签：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/标签名  </span><br><span class="line">  </span><br><span class="line">git push origin :refs/tags/protobuf-2.5.0rc1</span><br></pre></td></tr></table></figure></p>
<p>其他本地操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#打标签  </span><br><span class="line">git tag -a v1.1.4 -m &quot;tagging version 1.1.4&quot;  </span><br><span class="line">  </span><br><span class="line">#删除本地仓库标签  </span><br><span class="line">git tag -d v1.1.4  </span><br><span class="line">  </span><br><span class="line">#列出标签  </span><br><span class="line">git tag</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事实上Git 的推送和删除远程标签命令是相同的，删除操作实际上就是推送空的源标签refs：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
    
    </summary>
    
    
      <category term="git" scheme="http://html-js.site/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>fiddler之https抓包（windows）</title>
    <link href="http://html-js.site/2016/09/12/fiddler%E4%B9%8Bhttps%E6%8A%93%E5%8C%85%EF%BC%88windows%EF%BC%89/"/>
    <id>http://html-js.site/2016/09/12/fiddler之https抓包（windows）/</id>
    <published>2016-09-12T11:13:36.000Z</published>
    <updated>2016-09-12T12:00:02.689Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近因为fiddler升级，引发的一系列血案，花了整整2个小时才解决，必须记录一下</p>
</blockquote>
<h2 id="安装并设置"><a href="#安装并设置" class="headerlink" title="安装并设置"></a>安装并设置</h2><p>下载fiddler最新版本，官网地址：<a href="http://www.telerik.com/fiddler" target="_blank" rel="external">http://www.telerik.com/fiddler</a></p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>1.打开Fiddler，然后点击菜单栏的Tools &gt; Fiddler Options，打开“Fiddler Options”对话框。<br><img src="/images/page/fiddler/1.jpg" alt=""></p>
<p>2.在打开的对话框中切换到“HTTPS”选项卡<br><img src="/images/page/fiddler/2.jpg" alt=""></p>
<p>3.在打开的“HTTPS”选项卡中，勾选“Capture HTTPS  CONNECTs”和“Decrypt HTTPS traffic”前面的复选框，然后点击“OK”。<br><img src="/images/page/fiddler/3.jpg" alt=""></p>
<p>4.现在Fiddler就是在监听https的请求和响应了。</p>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><h3 id="证书问题，需要重新安装"><a href="#证书问题，需要重新安装" class="headerlink" title="证书问题，需要重新安装"></a>证书问题，需要重新安装</h3><ol>
<li>导出证书：fiddler-&gt;tools-&gt;fiddler options-&gt;https tab-&gt;action-&gt;Export Root Certificate to Desktop</li>
<li>安装证书：</li>
</ol>
<ul>
<li>IE：Internet选项-&gt;内容 tab-&gt;证书-&gt;删除所有颁发者为DO_NOT_TRUST_FiddlerRoot-&gt;导入证书</li>
<li>Chrome:设置-&gt;高级设置-&gt;管理证书-&gt;删除所有颁发者为DO_NOT_TRUST_FiddlerRoot-&gt;导入证书<br><img src="/images/page/fiddler/4.jpg" alt=""></li>
</ul>
<h3 id="证书、设置都正确了发现还是有问题，请重启FIDDLER和浏览器，fiddler请用管理员权限运行，还不行就重启电脑"><a href="#证书、设置都正确了发现还是有问题，请重启FIDDLER和浏览器，fiddler请用管理员权限运行，还不行就重启电脑" class="headerlink" title="证书、设置都正确了发现还是有问题，请重启FIDDLER和浏览器，fiddler请用管理员权限运行，还不行就重启电脑"></a>证书、设置都正确了发现还是有问题，请重启FIDDLER和浏览器，fiddler请用管理员权限运行，还不行就重启电脑</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近因为fiddler升级，引发的一系列血案，花了整整2个小时才解决，必须记录一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装并设置&quot;&gt;&lt;a href=&quot;#安装并设置&quot; class=&quot;headerlink&quot; title=&quot;安装并设置&quot;
    
    </summary>
    
    
      <category term="工具" scheme="http://html-js.site/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>vue学习-用vue-cli快速开发单页应用</title>
    <link href="http://html-js.site/2016/09/09/vue%E5%AD%A6%E4%B9%A0-%E7%94%A8vue-cli%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8/"/>
    <id>http://html-js.site/2016/09/09/vue学习-用vue-cli快速开发单页应用/</id>
    <published>2016-09-09T03:55:56.000Z</published>
    <updated>2016-09-09T03:55:56.086Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript核心(转)</title>
    <link href="http://html-js.site/2016/08/24/JavaScript%E6%A0%B8%E5%BF%83-%E8%BD%AC/"/>
    <id>http://html-js.site/2016/08/24/JavaScript核心-转/</id>
    <published>2016-08-24T07:00:13.000Z</published>
    <updated>2016-08-24T07:48:55.157Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ol>
<li><a href="#对象">对象</a></li>
<li><a href="#构造函数">构造函数</a></li>
<li><a href="#执行上下文堆栈">执行上下文堆栈</a></li>
<li><a href="#执行上下文">执行上下文</a></li>
<li><a href="#变量对象">变量对象</a></li>
<li><a href="#活动对象">活动对象</a></li>
<li><a href="#作用域链">作用域链</a></li>
<li><a href="#闭包">闭包</a></li>
<li><a href="#this">this</a></li>
</ol>
</blockquote>
<p>这篇文章是“深入理解ECMA-262-3”的一个总览和概要，每个章节都有对应的详细的链接。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>ECMAScript作为一个高度抽象的面向对象语言，是通过对象来做数据传递的。当然也有一些基本数据类型，但通常也会被转换为对象来处理。</p>
<blockquote>
<p>一个对象就是一组属性的集合，并拥有一个独立的prototype对象，这个prototype可以是个对象也可以是个null</p>
</blockquote>
<p>举个简单例子，对象的 prototype 是以内部的<code>[[Prototype]]</code>属性来引用的。但是我们在图表中使用 <code>__&lt;internal-property&gt;__</code>下划线标记来代替双括号，尤其是prototype对象：<code>__proto__</code></p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  x: 10,</span><br><span class="line">  y: 20</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>于是就有这个结构：两个显式的自身属性和一个隐式属性<strong>proto</strong>,这个隐式属性就是对 foo 原型对象的引用<br><img src="/images/page/jsCore/1.png" alt=""></p>
<p>为什么需要这些prototype？那我们就以原型链 (prototype chain) 的概念来回答这个问题。</p>
<p>##　原型链<br>原型对象也是简单对象，并且也有自己的原型。如果一个原型对象的原型有一个非空(not null)的引用，那么以此类推，这就叫做原型链。</p>
<blockquote>
<p>原型链是一个可以实现继承和对象共享的有限对象链</p>
</blockquote>
<p>假设我们有两个对象，其中只有一小部分不同，其他绝大部分相同。很明显，对于一个有良好设计的系统，我们会复用相似的函数和代码。在基于类的系统中，代码复用风格叫做类继承<code>class-based inheritance</code> —— 把一组相似的功能放入Class A，然后Class B和C继承Class A，并又有独自的小改动。</p>
<p>ECMAScript中没有类的概念。但是代码复用的风格并没有多大的不同（尽管从某些方面来说这种方式比累积成要更灵活）并且通过原型链来实现。这种集成被称作委托继承<code>(delegation based inheritance)</code>(或者用ECMAScript的范式来说就叫做原型继承)。</p>
<p>类似子上面例子中的类A、B、C，在ECMAScript中创建对象a、b、c。那么在a中存储b、c通用的部分，b、c只存储自己额外属性和方法。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">  x: 10,</span><br><span class="line">  calculate: function (z) &#123;</span><br><span class="line">    return this.x + this.y + z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var b = &#123;</span><br><span class="line">  y: 20,</span><br><span class="line">  __proto__: a</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var c = &#123;</span><br><span class="line">  y: 30,</span><br><span class="line">  __proto__: a</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// call the inherited method</span><br><span class="line">b.calculate(30); // 60</span><br><span class="line">c.calculate(40); // 80</span><br></pre></td></tr></table></figure></p>
<p>足够简单，对吧。b和c调用了a中的calculate方法，这就叫做原型链继承。</p>
<p>规则很简单：一个属性或一个方法没有在对象自身中找到（即对象自身没有那个属性），然后就尝试在原型中查找这个属性或者方法，如果原型中没有找到，就会继续查找原型的原型，以此来遍历整个原型链（当然这在基于类继承中是一样的，调用继承方法时会遍历真个Class链）第一个被查找到的同名属性/方法会被使用。因此，一个被查找到的属性叫作继承属性。如果在遍历了整个原型链之后还是没有查找到这个属性的话，返回<code>undefined</code>值。</p>
<p>规则很简单：如果一个属性或者一个方法在对象自身中无法找到（也就是对象自身没有一个那样的属性），然后它会尝试在原型链中寻找这个属性/方法。如果这个属性在原型中没有查找到，那么将会查找这个原型的原型，以此类推，遍历整个原型链（当然这在类继承中也是一样的，当解析一个继承的方法的时候－我们遍历class链（ class chain））。第一个被查找到的同名属性/方法会被使用。因此，一个被查找到的属性叫作继承属性。如果在遍历了整个原型链之后还是没有查找到这个属性的话，返回<code>undefined</code>值。</p>
<p>注意，继承方法中所使用的<code>this</code>的值被设置为原始对象，而并不是在其中查找到这个方法的（原型）对象。也就是，在上面的例子中<code>this.y</code>取的是<code>b</code>和<code>c</code>中的值，而不是<code>a</code>中的值。但是，<code>this.x</code>是取的是<code>a</code>中的值，并且又一次通过原型链机制完成。</p>
<p>如果没有明确为一个对象指定原型，那么它将会使用<code>__proto__</code>的默认值－<code>Object.prototype</code>。<code>Object.prototype</code>对象自身也有一个<code>__proto__</code>属性，这是原型链的终点并且值为<code>null</code>。</p>
<p>下一张图展示了对象<code>a</code>，<code>b</code>，<code>c</code>之间的继承层级：<br><img src="/images/page/jsCore/2.png" alt=""></p>
<p>注意：<br><br>ES5标准化了一个实现原型继承的可选方法，即使用<code>Object.create</code>函数：<br><code>var b = Object.create(a, {y: {value: 20}});
var c = Object.create(a, {y: {value: 30}});</code><br>你可以在<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-1-properties-and-property-descriptors/#new-api-methods" target="_blank" rel="external">对应的章节</a>获取到更多关于ES5新API的信息。<br>ES6标准化了 <code>__proto__</code>属性，并且可以在对象初始化的时候使用它。</p>
<p>通常情况下需要对象拥有相同或者相似的状态结构（也就是相同的属性集合），赋以不同的状态值。在这个情况下我们可能需要使用构造函数(constructor function)，其以指定的模式来创造对象。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>除了以指定模式创建对象之外，构造函数也做了另一个有用的事情－它自动地为新创建的对象设置一个原型对象。这个原型对象存储在<code>ConstructorFunction.prototype</code>属性中。</p>
<p>换句话说，我们可以使用构造函数来重写上一个拥有对象b和对象c的例子。因此，对象a（一个原型对象）的角色由<code>Foo.prototype</code>来扮演：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// a constructor function</span><br><span class="line">function Foo(y) &#123;</span><br><span class="line">  // which may create objects</span><br><span class="line">  // by specified pattern: they have after</span><br><span class="line">  // creation own &quot;y&quot; property</span><br><span class="line">  this.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// also &quot;Foo.prototype&quot; stores reference</span><br><span class="line">// to the prototype of newly created objects,</span><br><span class="line">// so we may use it to define shared/inherited</span><br><span class="line">// properties or methods, so the same as in</span><br><span class="line">// previous example we have:</span><br><span class="line"></span><br><span class="line">// inherited property &quot;x&quot;</span><br><span class="line">Foo.prototype.x = 10;</span><br><span class="line"></span><br><span class="line">// and inherited method &quot;calculate&quot;</span><br><span class="line">Foo.prototype.calculate = function (z) &#123;</span><br><span class="line">  return this.x + this.y + z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// now create our &quot;b&quot; and &quot;c&quot;</span><br><span class="line">// objects using &quot;pattern&quot; Foo</span><br><span class="line">var b = new Foo(20);</span><br><span class="line">var c = new Foo(30);</span><br><span class="line"></span><br><span class="line">// call the inherited method</span><br><span class="line">b.calculate(30); // 60</span><br><span class="line">c.calculate(40); // 80</span><br><span class="line"></span><br><span class="line">// let&apos;s show that we reference</span><br><span class="line">// properties we expect</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line"></span><br><span class="line">  b.__proto__ === Foo.prototype, // true</span><br><span class="line">  c.__proto__ === Foo.prototype, // true</span><br><span class="line"></span><br><span class="line">  // also &quot;Foo.prototype&quot; automatically creates</span><br><span class="line">  // a special property &quot;constructor&quot;, which is a</span><br><span class="line">  // reference to the constructor function itself;</span><br><span class="line">  // instances &quot;b&quot; and &quot;c&quot; may found it via</span><br><span class="line">  // delegation and use to check their constructor</span><br><span class="line"></span><br><span class="line">  b.constructor === Foo, // true</span><br><span class="line">  c.constructor === Foo, // true</span><br><span class="line">  Foo.prototype.constructor === Foo // true</span><br><span class="line"></span><br><span class="line">  b.calculate === b.__proto__.calculate, // true</span><br><span class="line">  b.__proto__.calculate === Foo.prototype.calculate // true</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>这个代码可以表示为如下关系：<br><img src="/images/page/jsCore/3.png" alt=""><br>这张图又一次说明了每个对象都有一个原型。构造函数<code>Foo</code>也有自己的<code>__proto__</code>，值为<code>Function.prototype</code>，<code>Function.prototype</code>也通过其<code>__proto__</code>属性关联到<code>Object.prototype</code>。因此，重申一下，<code>Foo.prototype</code>就是<code>Foo</code>的一个明确的属性，指向对象<code>b</code>和对象<code>c</code>的原型。</p>
<p>正式来说，如果思考一下分类的概念（并且我们已经对<code>Foo</code>进行了分类），那么构造函数和原型对象合在一起可以叫作「类」。实际上，举个例子，Python的第一级（first-class）动态类（dynamic classes）显然是以同样的<code>属性/方法</code>处理方案来实现的。从这个角度来说，Python中的类就是ECMAScript使用的委托继承的一个语法糖。</p>
<p>注意: 在ES6中「类」的概念被标准化了，并且实际上以一种构建在构造函数上面的语法糖来实现，就像上面描述的一样。从这个角度来看原型链成为了类继承的一种具体实现方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// ES6</span><br><span class="line">class Foo &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this._name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this._name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Bar extends Foo &#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    return super.getName() + &apos; Doe&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar = new Bar(&apos;John&apos;);</span><br><span class="line">console.log(bar.getName()); // John Doe</span><br></pre></td></tr></table></figure></p>
<p>有关这个主题的完整、详细的解释可以在ES3系列的第七章找到。分为两个部分：<a href="&quot;http://dmitrysoshnikov.com/ecmascript/chapter-7-1-oop-general-theory/">7.1 面向对象.基本理论</a>，在那里你将会找到对各种面向对象范例、风格的描述以及它们和ECMAScript之间的对比，然后在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/" target="_blank" rel="external">7.2 面向对象.ECMAScript实现</a>，是对ECMAScript中面向对象的介绍。</p>
<p>现在，在我们知道了对象的基础之后，让我们看看运行时程序的执行（runtime program execution）在ECMAScript中是如何实现的。这叫作执行上下文栈（execution context stack），其中的每个元素也可以抽象成为一个对象。是的，ECMAScript几乎在任何地方都和对象的概念打交道;)</p>
<h2 id="执行上下文堆栈"><a href="#执行上下文堆栈" class="headerlink" title="执行上下文堆栈"></a>执行上下文堆栈</h2><p>这里有三种类型的ECMAScript代码：全局代码、函数代码和eval代码。每个代码是在其执行上下文（execution context）中被求值的。这里只有一个全局上下文，可能有多个函数执行上下文以及eval执行上下文。对一个函数的每次调用，会进入到函数执行上下文中，并对函数代码类型进行求值。每次对<code>eval</code>函数进行调用，会进入eval执行上下文并对其代码进行求值。</p>
<p>注意，一个函数可能会创建无数的上下文，因为对函数的每次调用（即使这个函数递归的调用自己）都会生成一个具有新状态的上下文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo(bar) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// call the same function,</span><br><span class="line">// generate three different</span><br><span class="line">// contexts in each call, with</span><br><span class="line">// different context state (e.g. value</span><br><span class="line">// of the &quot;bar&quot; argument)</span><br><span class="line"></span><br><span class="line">foo(10);</span><br><span class="line">foo(20);</span><br><span class="line">foo(30);</span><br></pre></td></tr></table></figure></p>
<p>一个执行上下文可能会触发另一个上下文，比如，一个函数调用另一个函数（或者在全局上下文中调用一个全局函数），等等。从逻辑上来说，这是以栈的形式实现的，它叫作执行上下文栈。</p>
<p>一个触发其他上下文的上下文叫作caller。被触发的上下文叫作callee。callee在同一时间可能是一些其他callee的caller（比如，一个在全局上下文中被调用的函数，之后调用了一些内部函数）。</p>
<p>当一个caller触发（调用）了一个callee，这个caller会暂缓自身的执行，然后把控制权传递给callee。这个callee被push到栈中，并成为一个运行中（活动的）执行上下文。在callee的上下文结束后，它会把控制权返回给caller，然后caller的上下文继续执行（它可能触发其他上下文）直到它结束，以此类推。callee可能简单的返回或者由于异常而退出。一个抛出的但是没有被捕获的异常可能退出（从栈中pop）一个或者多个上下文。</p>
<p>换句话说，所有ECMAScript<em>程序的运行时可以用执行上下文（EC）栈来表示，栈顶是当前活跃</em>(active)上下文：<br><img src="/images/page/jsCore/4.png" alt=""></p>
<p>当程序开始的时候它会进入全局执行上下文，此上下文位于栈底并且是栈中的第一个元素。然后全局代码进行一些初始化，创建需要的对象和函数。在全局上下文的执行过程中，它的代码可能触发其他（已经创建完成的）函数，这些函数将会进入它们自己的执行上下文，向栈中push新的元素，以此类推。当初始化完成之后，运行时系统（runtime system）就会等待一些事件（比如，用户鼠标点击），这些事件将会触发一些函数，从而进入新的执行上下文中。</p>
<p>在下个图中，拥有一些函数上下文EC1和全局上下文<code>Global EC</code>，当<code>EC1</code>进入和退出全局上下文的时候下面的栈将会发生变化：<br><img src="/images/page/jsCore/5.png" alt=""></p>
<p>这就是ECMAScript的运行时系统如何真正地管理代码执行的。</p>
<p>更多有关ECMAScript中执行上下文的信息可以在对应的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-1-execution-contexts/" target="_blank" rel="external">第一章 执行上下文</a>中获取。</p>
<p>像我们所说的，栈中的每个执行上下文都可以用一个对象来表示。让我们来看看它的结构以及一个上下文到底需要什么状态（什么属性）来执行它的代码。</p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p>一个执行上下文可以抽象的表示为一个简单的对象。每一个执行上下文拥有一些属性（可以叫作上下文状态）用来跟踪和它相关的代码的执行过程。在下图中展示了一个上下文的结构：</p>
<p><img src="/images/page/jsCore/5.png" alt=""></p>
<p>除了这三个必需的属性（一个变量对象（variable objec），一个this值以及一个作用域链（scope chain））之外，执行上下文可以拥有任何附加的状态，这取决于实现。</p>
<p>让我们详细看看上下文中的这些重要的属性。</p>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><blockquote>
<p>变量对象是与执行上下文相关的数据作用域。它是一个与上下文相关的特殊对象，其中存储了在上下文中定义的变量和函数声明。</p>
</blockquote>
<p>注意，函数表达式（与函数声明相对）不包含在变量对象之中。</p>
<p>变量对象是一个抽象概念。对于不同的上下文类型，在物理上，是使用不同的对象。比如，在全局上下文中变量对象就是全局对象本身（这就是为什么我们可以通过全局对象的属性名来关联全局变量）。</p>
<p>让我们在全局执行上下文中考虑下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var foo = 10;</span><br><span class="line"></span><br><span class="line">function bar() &#123;&#125; // function declaration, FD</span><br><span class="line">(function baz() &#123;&#125;); // function expression, FE</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  this.foo == foo, // true</span><br><span class="line">  window.bar == bar // true</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(baz); // ReferenceError, &quot;baz&quot; is not defined</span><br></pre></td></tr></table></figure></p>
<p>之后，全局上下文的变量对象（variable objec，简称VO）将会拥有如下属性：<br><img src="/images/page/jsCore/7.png" alt=""></p>
<p>再看一遍，函数<code>baz</code>是一个函数表达式，没有被包含在变量对象之中。这就是为什么当我们想要在函数自身之外访问它的时候会出现<code>ReferenceError</code>。</p>
<p>注意，与其他语言（比如C/C++）相比，在ECMAScript中只有函数可以创建一个新的作用域。在函数作用域中所定义的变量和内部函数在函数外边是不能直接访问到的，而且并不会污染全局变量对象。</p>
<p>使用<code>eval</code>我们也会进入一个新的（eval类型）执行上下文。无论如何，<code>eval</code>使用全局的变量对象或者使用caller（比如<code>eval</code>被调用时所在的函数）的变量对象。</p>
<p>那么函数和它的变量对象是怎么样的？在函数上下文中，变量对象是以活动对象（activation object）来表示的。</p>
<h2 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h2><p>当一个函数被caller所触发（被调用），一个特殊的对象，叫作活动对象（activation object）将会被创建。这个对象中包含形参和那个特殊的<code>arguments</code>对象（是对形参的一个映射，但是值是通过索引来获取）。活动对象之后会做为函数上下文的变量对象来使用。</p>
<p>换句话说，函数的变量对象也是一个同样简单的变量对象，但是除了变量和函数声明之外，它还存储了形参和<code>arguments</code>对象，并叫作活动对象。</p>
<p>考虑如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo(x, y) &#123;</span><br><span class="line">  var z = 30;</span><br><span class="line">  function bar() &#123;&#125; // FD</span><br><span class="line">  (function baz() &#123;&#125;); // FE</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(10, 20);</span><br></pre></td></tr></table></figure></p>
<p>我们看下函数<code>foo</code>的上下文中的活动对象（activation object，简称AO）：<br><img src="/images/page/jsCore/8.png" alt=""></p>
<p>并且函数表达式<code>baz</code>还是没有被包含在变量/活动对象中。</p>
<p>关于这个主题所有细节方面（像变量和函数声明的提升问题（hoisting））的完整描述可以在同名的章节<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/" target="_blank" rel="external">第二章 变量对象</a>中找到。</p>
<p>注意，在ES5中变量对象和活动对象被并入了词法环境模型（lexical environments model），详细的描述可以在<a href="http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/" target="_blank" rel="external">对应的章节</a>找到。</p>
<p>然后我们向下一个部分前进。众所周知，在ECMAScript中我们可以使用<em>内部函数</em>，然后在这些内部函数我们可以引用父函数的变量或者全局上下文中的变量。当我们把变量对象命名为上下文的作用域对象，与上面讨论的原型链相似，这里有一个叫作<em>作用域链</em>的东西。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><blockquote>
<p>作用域链是一个对象列表，上下文代码中出现的标识符在这个列表中进行查找。</p>
</blockquote>
<p>这个规则还是与原型链同样简单以及相似：如果一个变量在函数自身的作用域（在自身的变量/活动对象）中没有找到，那么将会查找它父函数（外层函数）的变量对象，以此类推。</p>
<p>就上下文而言，标识符指的是：变量<em>名称</em>，函数声明，形参，等等。当一个函数在其代码中引用一个不是局部变量（或者局部函数或者一个形参）的标识符，那么这个标识符就叫作<em>自由变量</em>。搜索这些<em>自由变量</em>(free variables)正好就要用到作用域链。</p>
<p>在通常情况下，作用域链是一个包含所有父（函数）变量对象_加上（在作用域链头部的）函数自身变量/活动对象的一个列表。但是，这个作用域链也可以包含任何其他对象，比如，在上下文执行过程中动态加入到作用域链中的对象－像_with对象或者特殊的catch从句（catch-clauses）对象。</p>
<p>当解析（查找）一个标识符的时候，会从作用域链中的活动对象开始查找，然后（如果这个标识符在函数自身的活动对象中没有被查找到）向作用域链的上一层查找－重复这个过程，就和原型链一样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line"></span><br><span class="line">(function foo() &#123;</span><br><span class="line">  var y = 20;</span><br><span class="line">  (function bar() &#123;</span><br><span class="line">    var z = 30;</span><br><span class="line">    // &quot;x&quot; and &quot;y&quot; are &quot;free variables&quot;</span><br><span class="line">    // and are found in the next (after</span><br><span class="line">    // bar&apos;s activation object) object</span><br><span class="line">    // of the bar&apos;s scope chain</span><br><span class="line">    console.log(x + y + z);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>我们可以假设通过隐式的<code>__parent__</code>属性来和作用域链对象进行关联，这个属性指向作用域链中的下一个对象。这个方案可能在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/#feature-of-implementations-property-__parent__" target="_blank" rel="external">真实的Rhino代码</a>中经过了测试，并且这个技术很明确得被用于ES5的词法环境中（在那里被叫作outer连接）。作用域链的另一个表现方式可以是一个简单的数组。利用<code>__parent__</code>概念，我们可以用下面的图来表现上面的例子（并且父变量对象存储在函数的<code>[[Scope]]</code>属性中）：<br><img src="/images/page/jsCore/9.png" alt=""></p>
<p>在代码执行过程中，作用域链可以通过使用<code>with</code>语句和<code>catch</code>从句对象来增强。并且由于这些对象是简单的对象，它们可以拥有原型（和原型链）。这个事实导致作用域链查找变为两个维度：（1）首先是作用域链连接，然后（2）在每个作用域链连接上－深入作用域链连接的原型链（如果此连接拥有原型）。</p>
<p>对于这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.x = 10;</span><br><span class="line"></span><br><span class="line">var w = 20;</span><br><span class="line">var y = 30;</span><br><span class="line"></span><br><span class="line">// in SpiderMonkey global object</span><br><span class="line">// i.e. variable object of the global</span><br><span class="line">// context inherits from &quot;Object.prototype&quot;,</span><br><span class="line">// so we may refer &quot;not defined global</span><br><span class="line">// variable x&quot;, which is found in</span><br><span class="line">// the prototype chain</span><br><span class="line"></span><br><span class="line">console.log(x); // 10</span><br><span class="line"></span><br><span class="line">(function foo() &#123;</span><br><span class="line"></span><br><span class="line">  // &quot;foo&quot; local variables</span><br><span class="line">  var w = 40;</span><br><span class="line">  var x = 100;</span><br><span class="line"></span><br><span class="line">  // &quot;x&quot; is found in the</span><br><span class="line">  // &quot;Object.prototype&quot;, because</span><br><span class="line">  // &#123;z: 50&#125; inherits from it</span><br><span class="line"></span><br><span class="line">  with (&#123;z: 50&#125;) &#123;</span><br><span class="line">    console.log(w, x, y , z); // 40, 10, 30, 50</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // after &quot;with&quot; object is removed</span><br><span class="line">  // from the scope chain, &quot;x&quot; is</span><br><span class="line">  // again found in the AO of &quot;foo&quot; context;</span><br><span class="line">  // variable &quot;w&quot; is also local</span><br><span class="line">  console.log(x, w); // 100, 40</span><br><span class="line"></span><br><span class="line">  // and that&apos;s how we may refer</span><br><span class="line">  // shadowed global &quot;w&quot; variable in</span><br><span class="line">  // the browser host environment</span><br><span class="line">  console.log(window.w); // 20</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>我们可以给出如下的结构（确切的说，在我们查找<code>__parent__</code>连接之前，首先查找<code>__proto__</code>链）：<br><img src="/images/page/jsCore/10.png" alt=""></p>
<p>注意，不是在所有的实现中全局对象都是继承自<code>Object.prototype</code>。上图中描述的行为（从全局上下文中引用「未定义」的变量<code>x</code>）可以在诸如SpiderMonkey引擎中进行测试。</p>
<p>由于所有父变量对象都存在，所以在内部函数中获取父函数中的数据没有什么特别－我们就是遍历作用域链去解析（搜寻）需要的变量。就像我们上边提及的，在一个上下文结束之后，它所有的状态和它自身都会被销毁。在同一时间父函数可能会返回一个内部函数。而且，这个返回的函数之后可能在另一个上下文中被调用。如果自由变量的上下文已经「消失」了，那么这样的调用将会发生什么？通常来说，有一个概念可以帮助我们解决这个问题，叫作（词法）闭包，其在ECMAScript中就是和作用域链的概念紧密相关的。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在ECMAScript中，函数是第一级（first-class）对象。这个术语意味着函数可以做为参数传递给其他函数（在那种情况下，这些参数叫作「函数类型参数」（funargs，是”functional arguments”的简称））。接收「函数类型参数」的函数叫作高阶函数或者，贴近数学一些，叫作高阶操作符。同样函数也可以从其他函数中返回。返回其他函数的函数叫作以函数为值（function valued）的函数（或者叫作拥有函数类值的函数（functions with functional value））。</p>
<p>这有两个在概念上与「函数类型参数（funargs）」和「函数类型值（functional　values）」相关的问题。并且这两个子问题在”Funarg problem”（或者叫作”functional argument”问题）中很普遍。为了解决整个”funarg problem”，闭包（closure）的概念被创造了出来。我们详细的描述一下这两个子问题（我们将会看到这两个问题在ECMAScript中都是使用图中所提到的函数的<code>[[Scope]]</code>属性来解决的）。</p>
<p>「funarg问题」的第一个子问题是「向上funarg问题」（upward funarg problem）。它会在当一个函数从另一个函数向上返回（到外层）并且使用上面所提到的自由变量的时候出现。为了在即使父函数上下文结束的情况下也能访问其中的变量，内部函数在被创建的时候会在它的<code>[[Scope]]</code>属性中保存父函数的作用域链。所以当函数被调用的时候，它上下文的作用域链会被格式化成活动对象与<code>[[Scope]]</code>属性的和（实际上就是我们刚刚在上图中所看到的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope chain = Activation object + [[Scope]]</span><br></pre></td></tr></table></figure>
<p>再次注意这个关键点－确切的说在创建时刻－函数会保存父函数的作用域链，因为确切的说这个保存下来的作用域链将会在未来的函数调用时用来查找变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var x = 10;</span><br><span class="line">  return function bar() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// &quot;foo&quot; returns also a function</span><br><span class="line">// and this returned function uses</span><br><span class="line">// free variable &quot;x&quot;</span><br><span class="line"></span><br><span class="line">var returnedFunction = foo();</span><br><span class="line"></span><br><span class="line">// global variable &quot;x&quot;</span><br><span class="line">var x = 20;</span><br><span class="line"></span><br><span class="line">// execution of the returned function</span><br><span class="line"></span><br><span class="line">returnedFunction(); // 10, but not 20</span><br></pre></td></tr></table></figure></p>
<p>这个类型的作用域叫作静态（或者词法）作用域。我们看到变量x在返回的bar函数的[[Scope]]属性中被找到。通常来说，也存在动态作用域，那么上面例子中的变量x将会被解析成20，而不是10。但是，动态作用域在ECMAScript中没有被使用。</p>
<p>「funarg问题」的第二个部分是「向下funarg问题」。这种情况下可能会存在一个父上下文，但是在解析标识符的时候可能会模糊不清。问题是：标识符该使用哪个作用域的值－以静态的方式存储在函数创建时刻的还是在执行过程中以动态方式生成的（比如caller的作用域）？为了避免这种模棱两可的情况并形成闭包，静态作用域被采用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// global &quot;x&quot;</span><br><span class="line">var x = 10;</span><br><span class="line"></span><br><span class="line">// global function</span><br><span class="line">function foo() &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(function (funArg) &#123;</span><br><span class="line"></span><br><span class="line">  // local &quot;x&quot;</span><br><span class="line">  var x = 20;</span><br><span class="line"></span><br><span class="line">  // there is no ambiguity,</span><br><span class="line">  // because we use global &quot;x&quot;,</span><br><span class="line">  // which was statically saved in</span><br><span class="line">  // [[Scope]] of the &quot;foo&quot; function,</span><br><span class="line">  // but not the &quot;x&quot; of the caller&apos;s scope,</span><br><span class="line">  // which activates the &quot;funArg&quot;</span><br><span class="line"></span><br><span class="line">  funArg(); // 10, but not 20</span><br><span class="line"></span><br><span class="line">&#125;)(foo); // pass &quot;down&quot; foo as a &quot;funarg&quot;</span><br></pre></td></tr></table></figure></p>
<p>我们可以断定静态作用域是一门语言拥有闭包的必需条件。但是，一些语言可能会同时提供动态和静态作用域，允许程序员做选择－什么应该包含（closure）在内和什么不应包含在内。由于在ECMAScript中只使用了静态作用域（比如我们对于<code>funarg问题</code>的两个子问题都有解决方案），所以结论是：ECMAScript完全支持闭包，技术上是通过函数的<code>[[Scope]]</code>属性实现的。现在我们可以给闭包下一个准确的定义：</p>
<blockquote>
<p>闭包是一个代码块（在ECMAScript是一个函数）和以静态方式/词法方式进行存储的所有父作用域的一个集合体。所以，通过这些存储的作用域，函数可以很容易的找到自由变量。</p>
</blockquote>
<p>注意，由于每个（标准的）函数都在创建的时候保存了<code>[[Scope]]</code>，所以理论上来讲，ECMAScript中的所有函数都是闭包。</p>
<p>另一个需要注意的重要事情是，多个函数可能拥有相同的父作用域（这是很常见的情况，比如当我们拥有两个内部/全局函数的时候）。在这种情况下，<code>[[Scope]]</code>属性中存储的变量是在拥有相同父作用域链的所有函数之间共享的。一个闭包对变量进行的修改会体现在另一个闭包对这些变量的读取上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function baz() &#123;</span><br><span class="line">  var x = 1;</span><br><span class="line">  return &#123;</span><br><span class="line">    foo: function foo() &#123; return ++x; &#125;,</span><br><span class="line">    bar: function bar() &#123; return --x; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var closures = baz();</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  closures.foo(), // 2</span><br><span class="line">  closures.bar()  // 1</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>以上代码可以通过下图进行说明：<br><img src="/images/page/jsCore/11.png" alt=""></p>
<p>确切来说这个特性在循环中创建多个函数的时候会使人非常困惑。在创建的函数中使用循环计数器的时候，一些程序员经常会得到非预期的结果，所有函数中的计数器都是同样的值。现在是到了该揭开谜底的时候了－因为所有这些函数拥有同一个<code>[[Scope]]</code>，这个属性中的循环计数器的值是最后一次所赋的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var k = 0; k &amp;lt; 3; k++) &#123;</span><br><span class="line">  data[k] = function () &#123;</span><br><span class="line">    alert(k);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[0](); // 3, but not 0</span><br><span class="line">data[1](); // 3, but not 1</span><br><span class="line">data[2](); // 3, but not 2</span><br></pre></td></tr></table></figure></p>
<p>这里有几种技术可以解决这个问题。其中一种是在作用域链中提供一个额外的对象－比如，使用额外函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var data = [];</span><br><span class="line"></span><br><span class="line">for (var k = 0; k &amp;lt; 3; k++) &#123;</span><br><span class="line">  data[k] = (function (x) &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">      alert(x);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(k); // pass &quot;k&quot; value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// now it is correct</span><br><span class="line">data[0](); // 0</span><br><span class="line">data[1](); // 1</span><br><span class="line">data[2](); // 2</span><br></pre></td></tr></table></figure></p>
<p>对闭包理论和它们的实际应用感兴趣的同学可以在<a href="http://dmitrysoshnikov.com/ecmascript/chapter-6-closures/" target="_blank" rel="external">第六章 闭包</a>中找到额外的信息。如果想获取更多关于作用域链的信息，可以看一下同名的<a href="http://dmitrysoshnikov.com/ecmascript/chapter-4-scope-chain/" target="_blank" rel="external">第四章 作用域链</a>。</p>
<p>然后我们移动到下个部分，考虑一下执行上下文的最后一个属性。这就是关于<code>this</code>值的概念。</p>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><blockquote>
<p>this是一个与执行上下文相关的特殊对象。因此，它可以叫作上下文对象（也就是用来指明执行上下文是在哪个上下文中被触发的对象）。</p>
</blockquote>
<p>任何对象都可以做为上下文中的<code>this</code>的值。我想再一次澄清，在一些对ECMAScript执行上下文和部分<code>this</code>的描述中的所产生误解。<code>this</code>经常被错误的描述成是变量对象的一个属性。这类错误存在于比如像<a href="http://yuiblog.com/assets/High_Perf_JavaScr_Ch2.pdf" target="_blank" rel="external">这本书</a>中（即<br>使如此，这本书的相关章节还是十分不错的）。再重复一次：</p>
<blockquote>
<p>this是执行上下文的一个属性，而不是变量对象的一个属性</p>
</blockquote>
<p>这个特性非常重要，因为与变量相反，<code>this</code>从不会参与到标识符解析过程。换句话说，在代码中当访问<code>this</code>的时候，它的值是直接从执行上下文中获取的，并不需要任何作用域链查找。<code>this</code>的值只在进入上下文的时候进行一次确定。</p>
<p>顺便说一下，与<code>ECMAScript</code>相反，比如，Python的方法都会拥有一个被当作简单变量的<code>self</code>参数，这个变量的值在各个方法中是相同的的并且在执行过程中可以被更改成其他值。在ECMAScript中，给<code>this</code>赋一个新值是不可能的，因为，再重复一遍，它不是一个变量并且不存在于变量对象中。</p>
<p>在全局上下文中，<code>this</code>就等于全局对象本身（这意味着，这里的this等于变量对象）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line"></span><br><span class="line">console.log(</span><br><span class="line">  x, // 10</span><br><span class="line">  this.x, // 10</span><br><span class="line">  window.x // 10</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>在函数上下文的情况下，对函数的每次调用，其中的<code>this</code>值可能是不同的。这个<code>this</code>值是通过函数调用表达式（也就是函数被调用的方式）的形式由caller所提供的。举个例子，下面的函数<code>foo</code>是一个<code>callee</code>，在全局上下文中被调用，此上下文为caller。让我们通过例子看一下，对于一个代码相同的函数，<code>this</code>值是如何在不同的调用中（函数触发的不同方式），由caller给出不同的结果的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// the code of the &quot;foo&quot; function</span><br><span class="line">// never changes, but the &quot;this&quot; value</span><br><span class="line">// differs in every activation</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  alert(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// caller activates &quot;foo&quot; (callee) and</span><br><span class="line">// provides &quot;this&quot; for the callee</span><br><span class="line"></span><br><span class="line">foo(); // global object</span><br><span class="line">foo.prototype.constructor(); // foo.prototype</span><br><span class="line"></span><br><span class="line">var bar = &#123;</span><br><span class="line">  baz: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.baz(); // bar</span><br><span class="line"></span><br><span class="line">(bar.baz)(); // also bar</span><br><span class="line">(bar.baz = bar.baz)(); // but here is global object</span><br><span class="line">(bar.baz, bar.baz)(); // also global object</span><br><span class="line">(false || bar.baz)(); // also global object</span><br><span class="line"></span><br><span class="line">var otherFoo = bar.baz;</span><br><span class="line">otherFoo(); // again global object</span><br></pre></td></tr></table></figure></p>
<p>为了深入理解<code>this</code>为什么（并且更本质一些－如何）在每个函数调用中可能会发生变化，你可以阅读<a href="http://dmitrysoshnikov.com/ecmascript/chapter-3-this/" target="_blank" rel="external">第三章 This</a>。在那里，上面所提到的情况都会有详细的讨论。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#对象&quot;&gt;对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#构造函数&quot;&gt;构造函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#执行上下文堆栈&quot;&gt;执行上下文堆栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#执行上下
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>九个Console命令，让js调试更简单</title>
    <link href="http://html-js.site/2016/08/19/%E4%B9%9D%E4%B8%AAConsole%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%AE%A9js%E8%B0%83%E8%AF%95%E6%9B%B4%E7%AE%80%E5%8D%95/"/>
    <id>http://html-js.site/2016/08/19/九个Console命令，让js调试更简单/</id>
    <published>2016-08-19T04:02:45.000Z</published>
    <updated>2016-08-19T04:18:53.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、显示信息的命令"><a href="#一、显示信息的命令" class="headerlink" title="一、显示信息的命令"></a><strong>一、显示信息的命令</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;常用console命令&lt;/title&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        console.log(&apos;hello&apos;);</span><br><span class="line">        console.info(&apos;信息&apos;);</span><br><span class="line">        console.error(&apos;错误&apos;);</span><br><span class="line">        console.warn(&apos;警告&apos;);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>最常用的就是console.log了。</p>
<h2 id="二：占位符"><a href="#二：占位符" class="headerlink" title="二：占位符"></a><strong>二：占位符</strong></h2><p>onsole上述的集中度支持printf的占位符格式，支持的占位符有：字符（%s）、整数（%d或%i）、浮点数（%f）和对象（%o）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">   console.log(&quot;%d年%d月%d日&quot;,2011,3,26);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>效果：<br><img src="/images/page/console/1.png" alt=""></p>
<h2 id="三、信息分组"><a href="#三、信息分组" class="headerlink" title="三、信息分组"></a><strong>三、信息分组</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;常用console命令&lt;/title&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        console.group(&quot;第一组信息&quot;);</span><br><span class="line"></span><br><span class="line">    　　　　console.log(&quot;第一组第一条:我的博客(http://www.ido321.com)&quot;);</span><br><span class="line"></span><br><span class="line">    　　　　console.log(&quot;第一组第二条:CSDN(http://blog.csdn.net/u011043843)&quot;);</span><br><span class="line"></span><br><span class="line">    　　console.groupEnd();</span><br><span class="line"></span><br><span class="line">　　    console.group(&quot;第二组信息&quot;);</span><br><span class="line"></span><br><span class="line">    　　　　console.log(&quot;第二组第一条:程序爱好者QQ群： 259280570&quot;);</span><br><span class="line"></span><br><span class="line">    　　　　console.log(&quot;第二组第二条:欢迎你加入&quot;);</span><br><span class="line"></span><br><span class="line">　　    console.groupEnd();</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="/images/page/console/2.png" alt=""></p>
<h2 id="四、查看对象的信息"><a href="#四、查看对象的信息" class="headerlink" title="四、查看对象的信息"></a><strong>四、查看对象的信息</strong></h2><p>console.dir()可以显示一个对象所有的属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var info = &#123;</span><br><span class="line">        blog:&quot;http://www.ido321.com&quot;,</span><br><span class="line">        QQGroup:259280570,</span><br><span class="line">        message:&quot;程序爱好者欢迎你的加入&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    console.dir(info);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>效果：<br><img src="/images/page/console/3.png" alt=""></p>
<h2 id="五、显示某个节点的内容"><a href="#五、显示某个节点的内容" class="headerlink" title="五、显示某个节点的内容"></a><strong>五、显示某个节点的内容</strong></h2><p>console.dirxml()用来显示网页的某个节点（node）所包含的html/xml代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;常用console命令&lt;/title&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;info&quot;&gt;</span><br><span class="line">        &lt;h3&gt;我的博客：www.ido321.com&lt;/h3&gt;</span><br><span class="line">        &lt;p&gt;程序爱好者:259280570,欢迎你的加入&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        var info = document.getElementById(&apos;info&apos;);</span><br><span class="line">        console.dirxml(info);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>效果：<br><img src="/images/page/console/4.png" alt=""></p>
<h2 id="六、判断变量是否是真"><a href="#六、判断变量是否是真" class="headerlink" title="六、判断变量是否是真"></a><strong>六、判断变量是否是真</strong></h2><p>console.assert()用来判断一个表达式或变量是否为真。如果结果为否，则在控制台输出一条相应信息，并且抛出一个异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">　　var result = 1;</span><br><span class="line">　　console.assert( result );</span><br><span class="line">　　var year = 2014;</span><br><span class="line">　　console.assert(year == 2018 );</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>1是非0值，是真；而第二个判断是假，在控制台显示错误信息<br><img src="/images/page/console/5.png" alt=""></p>
<h2 id="七、追踪函数的调用轨迹。"><a href="#七、追踪函数的调用轨迹。" class="headerlink" title="七、追踪函数的调用轨迹。"></a><strong>七、追踪函数的调用轨迹。</strong></h2><p>console.trace()用来追踪函数的调用轨迹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">/*函数是如何被调用的，在其中加入console.trace()方法就可以了*/</span><br><span class="line">　　function add(a,b)&#123;</span><br><span class="line">        console.trace();</span><br><span class="line">　　　　return a+b;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var x = add3(1,1);</span><br><span class="line">　　function add3(a,b)&#123;return add2(a,b);&#125;</span><br><span class="line">　　function add2(a,b)&#123;return add1(a,b);&#125;</span><br><span class="line">　　function add1(a,b)&#123;return add(a,b);&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出信息：<br><img src="/images/page/console/6.png" alt=""></p>
<h2 id="八、计时功能"><a href="#八、计时功能" class="headerlink" title="八、计时功能"></a><strong>八、计时功能</strong></h2><p>console.time()和console.timeEnd()，用来显示代码的运行时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">　　console.time(&quot;控制台计时器一&quot;);</span><br><span class="line">　　for(var i=0;i&lt;1000;i++)&#123;</span><br><span class="line">　　　　for(var j=0;j&lt;1000;j++)&#123;&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　console.timeEnd(&quot;控制台计时器一&quot;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>运行时间是38.84ms<br><img src="/images/page/console/7.png" alt=""></p>
<h2 id="九、console-profile-的性能分析"><a href="#九、console-profile-的性能分析" class="headerlink" title="九、console.profile()的性能分析"></a><strong>九、console.profile()的性能分析</strong></h2><p>性能分析（Profiler）就是分析程序各个部分的运行时间，找出瓶颈所在，使用的方法是console.profile()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">　　function All()&#123;</span><br><span class="line">        alert(11);</span><br><span class="line">　　　　     for(var i=0;i&lt;10;i++)&#123;</span><br><span class="line">            funcA(1000);</span><br><span class="line">         &#125;</span><br><span class="line">　　　　    funcB(10000);</span><br><span class="line">　　    &#125;</span><br><span class="line"></span><br><span class="line">　　function funcA(count)&#123;</span><br><span class="line">　　　　for(var i=0;i&lt;count;i++)&#123;&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　function funcB(count)&#123;</span><br><span class="line">　　　　for(var i=0;i&lt;count;i++)&#123;&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　console.profile(&apos;性能分析器&apos;);</span><br><span class="line">　　All();</span><br><span class="line">　　console.profileEnd();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>输出如图：<br><img src="/images/page/console/8.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、显示信息的命令&quot;&gt;&lt;a href=&quot;#一、显示信息的命令&quot; class=&quot;headerlink&quot; title=&quot;一、显示信息的命令&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、显示信息的命令&lt;/strong&gt;&lt;/h2&gt;&lt;figure class=&quot;highlight pla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>工欲善其事必先利其器-sublimetext使用技巧</title>
    <link href="http://html-js.site/2016/08/18/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8Sublime%20Text/"/>
    <id>http://html-js.site/2016/08/18/如何优雅地使用Sublime Text/</id>
    <published>2016-08-18T01:41:08.000Z</published>
    <updated>2016-08-18T11:43:04.746Z</updated>
    
    <content type="html"><![CDATA[<p><strong>工欲善其事，必先利其器！</strong><br>Sublime Text：一款具有代码高亮、语法提示、自<br>动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。</p>
<h2 id="Sublime-Text-3安装插件"><a href="#Sublime-Text-3安装插件" class="headerlink" title="Sublime Text 3安装插件"></a><strong>Sublime Text 3安装插件</strong></h2><p>Sublime Text的强大就是她拥有强大的课可扩展性。您可根据自己的需要安装不同的插件；这使得她变的无比强大的同时又不失轻便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装Sublime text 3插件很方便</span><br><span class="line">打开Package Control：菜单-&gt;Perferences-&gt;Package Control 或者 ctrl+shift+p</span><br><span class="line">选择install Package,然后选择要安装的插件即可</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/page/sublimetext/1.jpg"></p>
<p>PS：国内使用SublimeText3，经常可能遇到无法安装可用插件问题，可remove掉<b>Package Control</b>重新安装下；如遇到连Package Control也无法安装，则可以在别处拷贝一份关于Package Control的文件－(Package Control.sublime-package)存放于<code>Installed Packages</code>目录之下即可。</p>
<h2 id="Sublime-Text-3插件推荐"><a href="#Sublime-Text-3插件推荐" class="headerlink" title="Sublime Text 3插件推荐"></a><strong>Sublime Text 3插件推荐</strong></h2><p>无插件，不神器！根据自己的需要定制属于自己的强大插件集；下面是一些常用的推荐。</p>
<p><a href="http://www.jianshu.com/p/5905f927d01b" target="_blank" rel="external">Sublime Text3插件：增强篇</a></p>
<p><a href="http://www.open-open.com/news/view/26d731" target="_blank" rel="external">20个强大的SublimeText插件</a></p>
<p>墙裂推荐以下这么几款插件：</p>
<p><strong><a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="external">MarkDown Editing</a></strong><br>SublimeText不仅仅是能够查看和编辑 Markdown 文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。</p>
<p><strong><a href="https://github.com/titoBouzout/SideBarFolders" target="_blank" rel="external">SideBarFolders</a></strong><br>打开的文件夹都太多了? 来用这个来管理文件夹，世界原来也可以这么美好。<br><img src="/images/page/sublimetext/2.jpg"></p>
<p><strong><a href="http://wbond.net/sublime_packages/terminal" target="_blank" rel="external">Sublime Terminal</a></strong><br>这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。</p>
<p><strong><a href="https://github.com/SublimeLinter" target="_blank" rel="external">SublimeLinter插件</a></strong><br>SublimeLinter 是前端编码利器——<code>Sublime Text</code> 的一款插件，用于高亮提示用户编写的代码中存在的不规范和错误的写法，支持 JavaScript、CSS、HTML、Java、PHP、Python、Ruby 等十多种开发语言。这篇文章介绍如何在 Windows 中配置 SublimeLinter 进行 JS &amp; CSS 校验。<br>比如写例如像lua这样的弱语言脚本代码，有这个可以规避掉很多不该有的低级错误吧？当然这也需要你SublimeLinter安装完毕之后再安装一个<code>SublimeLinter-lua</code>即可。具体的使用可以参见：<br><a href="http://www.cnblogs.com/lhb25/archive/2013/05/02/sublimelinter-for-js-css-coding.html" target="_blank" rel="external">借助 SublimeLinter 编写高质量的 JavaScript &amp; CSS 代码</a></p>
<p><strong><a href="https://github.com/victorporof/Sublime-HTMLPrettify" target="_blank" rel="external">HTML-CSS-JS Prettify</a></strong><br>一款集成了格式化（美化）html、css、js三种文件类型的插件，即便html,js写在PHP文件之内。插件依赖于nodejs，因此需要事先安装nodejs，然后才可以正常运行。插件安装完成后，快捷键ctrl+shift+H完成当前文件的美化操作。插件对html、css文件的美化不是非常满意，但还可以，后面将说明如何修改css美化脚本。本人用起来超级爽的，鉴于篇幅，就不赘述，可以参见<br><a href="http://frontenddev.org/article/sublime-does-text-three-plug-ins-html-and-css-js-prettify.html" target="_blank" rel="external">这篇</a></p>
<p><strong><a href="https://github.com/csscomb/CSScomb-for-Sublime" target="_blank" rel="external">CSScomb CSS属性排序</a>:</strong>有时候看看自己写的CSS文件，会不会觉得属性很乱查找不易维护难？CSScomb可以按照一定的CSS属性排序规则，将杂乱无章的CSS属性进行重新排序。选中要排序的CSS代码，按Ctrl+Shift+C，即可对CSS属性重新排序了，代码从此简洁有序易维护，如果不款选代码则插件将排序文件中所有的CSS属性。当然，可以自己自定义CSS属性排序规则，打开插件目录里的CSScomb.sublime-settings文件，更改里面的CSS属性顺序就行了。因为这个插件使用PHP写的，要使他工作需要在环境变量中添加PHP的路径，具体请看github上的说明。</p>

<p></p><p>剩下些许其他的可以按需安装的插件，比如：</p><p></p>
<ul><br><li><strong>ConvertToUTF8</strong>  支持 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的插件</li><br><li><strong>Bracket Highlighter</strong> 用于匹配括号，引号和html标签。对于很长的代码很有用。安装好之后，不需要设置插件会自动生效</li><br><li><strong>DocBlockr</strong> 可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++</li><br><li><strong><font color="purple">Emmet(Zen Coding)</font></strong>快速生成HTML代码段的插件，强大到无与伦比:可以超快速编写HTML/CSS/JS，当然这个插件还支持多种编译环境，如常见的：Eclipse/Aptana、Coda、Notepad++、Adobe Dreamweaver、TextMate等，<strong>web开发必备！！！</strong>。</li><br><li><strong>jsFormat</strong> 格式化js代码，懂者自懂；强迫症Coder必备！默认快捷键Ctrl+Alt+F。</li><br><li><strong>phpFormat</strong> 格式化php代码，懂者自懂；强迫症Coder必备！</li><br><li><strong>CSS Compact Expand CSS属性展开收缩:</strong>写CSS的盆友，喜欢将其写多行还是一行(个人喜欢将其格式化为多行)？如果阅读别人的代码不符合自己的习惯，可以用CSS Compact Expand这个插件将CSS格式化一下，按 Ctrl+Alt+[ 收缩CSS代码为一行显示，按 Ctrl+Alt+] 展开CSS代码为多行显示；强迫症Coder必备！。</li><br><li><strong>Autoprefixer插件</strong>：这是一款CSS3私有前缀自动补全插件；该插件使用CanIUse资料库（当然，SublimeText自然也有<font color="purple">CanIUse</font>这个插件咯），能精准判断哪些属性需要什么前缀，与CssComb插件一样，该插件也需要系统已安装Node.js环境；使用方法：在输入CSS3属性后（冒号前）按Tab键即可。</li><br><li><strong>YUI Compressor</strong>：压缩JS和CSS文件，按F7键后，若压缩当前文件（demo.js），则压缩后的文件（demo.min.js）保存在该文件的同级目录，需要安装java的JDK。使用方法：<a href="http://frontenddev.org/article/sublime-does-text-3-plug-in-yui-compressor.html" target="_blank" rel="external">YUI Compressor</a></li><br><li><strong>ClickableURLs：可点击的URL</strong>使用小插件<a href="https://github.com/leonid-shevtsov/ClickableUrls_SublimeText" target="_blank" rel="external">ClickableURLs</a>可以让文件中的URL能够点击。</li><br><li><strong>终极王道</strong>：自己编写专用的Sublime Text插件。虽然说各个方面比如移动端，Web前段，服务器端，非Coder的Writer所需要的方便已经被集成在了不同的插件中。但譬如，需要快捷打开PC端的某个模拟器，便捷的进行某些校验，只要你想的到的基本都可以将其在插件内，以快捷键处理之。至于如何编写SublimeText插件，请参看这里<a href="http://www.360doc.com/content/15/0417/22/19342630_463999403.shtml" target="_blank" rel="external">编写自己的Sublime Text2 插件</a></li><br></ul>



<h2 id="自定义代码片段"><a href="#自定义代码片段" class="headerlink" title="自定义代码片段"></a><strong>自定义代码片段</strong></h2><p>我们在开发中有很多代码是需要重复编写的，每一次都去复制粘贴显然是一件效率极其低下的事情，sublime的自定义代码片段功能就很好的解决了这个问题。下面就来看一下如何在sublime中自定义代码片段</p>
<p></p><p>首先在菜单栏选择：Tools -&gt;developer -&gt; New Snippet可以看到新建一个<code>xml</code>类型的描述文件，如下：</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;snippet&gt;</span><br><span class="line">    &lt;content&gt;&lt;![CDATA[</span><br><span class="line">Hello, $&#123;1:this&#125; is a $&#123;2:snippet&#125;.</span><br><span class="line">]]&gt;&lt;/content&gt;</span><br><span class="line">    &lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;</span><br><span class="line">    &lt;!-- &lt;tabTrigger&gt;hello&lt;/tabTrigger&gt; --&gt;</span><br><span class="line">    &lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;</span><br><span class="line">    &lt;!-- &lt;scope&gt;source.python&lt;/scope&gt; --&gt;</span><br><span class="line">&lt;/snippet&gt;</span><br></pre></td></tr></table></figure><p></p>
<p></p><p>注释已经非常详细了，<code>content</code> 里面就是代码模版：<code>${序号：默认值}</code> ，序号相同的地方光标会同时停在那可以多处同时编辑。序号大小就是 <code>tabindex</code>。在实际使用代码的时候，可以使用 <code>tab</code> 切换光标位置。</p><br>例子：Tatami.module<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;snippet&gt;</span><br><span class="line">	&lt;content&gt;&lt;![CDATA[</span><br><span class="line">/**</span><br><span class="line"> * Created by wangyang on $&#123;1:16/8/1&#125;.</span><br><span class="line"> */</span><br><span class="line">(function (rc) &#123;</span><br><span class="line">  	rc.modules.define(&#123;</span><br><span class="line">	    name: &apos;$&#123;2:name&#125;&apos;,</span><br><span class="line">	    depend: &apos;$&#123;3:depend&#125;&apos;,</span><br><span class="line">	    viewName: &apos;view.$&#123;2:name&#125;&apos;,</span><br><span class="line">	    type: &apos;&apos;, //basic/normal/sub</span><br><span class="line">	    ctrlsMap: &#123;&#125;,</span><br><span class="line">	    statusMap: &#123;&#125;,</span><br><span class="line">	    dataMap: &#123;&#125;,</span><br><span class="line">	    methodsMap: &#123;</span><br><span class="line">	    &#125;,</span><br><span class="line">	    events: &#123;&#125;,</span><br><span class="line">	    activation: function()&#123;&#125;,</span><br><span class="line">	    init: function () &#123;</span><br><span class="line">	    &#125;,</span><br><span class="line">	    update: function (hashs, isSelf) &#123;</span><br><span class="line"></span><br><span class="line">	    &#125;,</span><br><span class="line">	    destory: function () &#123;&#125;,</span><br><span class="line">	    disabled: function () &#123;&#125;</span><br><span class="line">  	&#125;)</span><br><span class="line">&#125;)(window.Tatami);</span><br><span class="line">]]&gt;&lt;/content&gt;</span><br><span class="line">	&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;</span><br><span class="line">	&lt;!-- 可选：快捷键，利用Tab自动补全代码的功能 --&gt;</span><br><span class="line">	&lt;tabTrigger&gt;ttmModule&lt;/tabTrigger&gt;</span><br><span class="line">	&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;</span><br><span class="line">	&lt;!-- 可选：使用范围，不填写代表对所有文件有效。附：source.css和test.html分别对应不同文件。 --&gt;</span><br><span class="line">	&lt;scope&gt;source.js&lt;/scope&gt;</span><br><span class="line">	&lt;!-- 可选：在snippet菜单中的显示说明（支持中文）。如果不定义，菜单则显示当前文件的文件名。 --&gt;</span><br><span class="line">	&lt;description&gt;Tatami Module&lt;/description&gt;</span><br><span class="line">&lt;/snippet&gt;</span><br></pre></td></tr></table></figure><p></p>
<p>结束语：如果你还在一行一行的手动敲代码，是时候改变了</p>
<p><strong>工欲善其事，必先利其器！</strong><br><strong>工欲善其事，必先利其器！</strong><br><strong>工欲善其事，必先利其器！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;工欲善其事，必先利其器！&lt;/strong&gt;&lt;br&gt;Sublime Text：一款具有代码高亮、语法提示、自&lt;br&gt;动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。&lt;/p&gt;
&lt;h2 id=&quot;Sublime-T
    
    </summary>
    
    
      <category term="sublime text" scheme="http://html-js.site/tags/sublime-text/"/>
    
  </entry>
  
  <entry>
    <title>一些jquery小技巧</title>
    <link href="http://html-js.site/2016/07/14/%E4%B8%80%E4%BA%9Bjquery%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://html-js.site/2016/07/14/一些jquery小技巧/</id>
    <published>2016-07-14T08:27:08.000Z</published>
    <updated>2016-08-23T10:01:21.886Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章总结了一些个人的jquery小知识</p>
<h3 id="回到顶部的按钮"><a href="#回到顶部的按钮" class="headerlink" title="回到顶部的按钮"></a>回到顶部的按钮</h3><p>通过使用jQuery中的<code>animate</code> 与 <code>scrollTop</code> 方法可以创建一个非常简易的带有平滑滚动的回到顶部的按钮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Back to top</span><br><span class="line">$(&apos;a.top&apos;).click(function (e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  $(document.body).animate(&#123;scrollTop: 0&#125;, 800);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;!-- Create an anchor tag --&gt;</span><br><span class="line">&lt;a class=&quot;top&quot; href=&quot;#&quot;&gt;Back to top&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过修改 <code>scrollTop</code>的值可以设置滚动最终停止的位置，最终的效果就是在800毫秒的时间内文档会被滚动到指定的地方。</p>
<h3 id="checkbox和radio的相关操作"><a href="#checkbox和radio的相关操作" class="headerlink" title="checkbox和radio的相关操作"></a>checkbox和radio的相关操作</h3><p>判断是否选中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;input.class&apos;).is(&apos;:checked&apos;);// true/false</span><br></pre></td></tr></table></figure></p>
<p>让某个选中,使用 <code>prop</code> 而不是 <code>attr</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;input.class&apos;).prop(&apos;checked&apos;,true/false);</span><br></pre></td></tr></table></figure></p>
<p>取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;input[name=name]:checked&apos;).val();</span><br></pre></td></tr></table></figure></p>
<h3 id="js-replaceAll实现"><a href="#js-replaceAll实现" class="headerlink" title="js replaceAll实现"></a>js replaceAll实现</h3><p><code>js</code> 没有 <code>java</code> 的 <code>replaceAll</code> 方法，这边有个方便的实现方法，利用正则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var aa = &apos;1212121212&apos;</span><br><span class="line">aa.replace(/1/g,&apos;2&apos;)</span><br><span class="line">//&quot;2222222222&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="检查图片是否加载完成"><a href="#检查图片是否加载完成" class="headerlink" title="检查图片是否加载完成"></a>检查图片是否加载完成</h3><p>有时候需要检查某个图片是否加载完成从而继续下面的操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;img&apos;).load(function () &#123;</span><br><span class="line">  console.log(&apos;image load successful&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>同样的，可以使用ID或者类选择器来判断某个特定的图片是否加载完成。</p>
<h3 id="图片加载失败的处理"><a href="#图片加载失败的处理" class="headerlink" title="图片加载失败的处理"></a>图片加载失败的处理</h3><p>在页面上如果发生某些图片加载失败是一个非常常见并且恶心的事情，如下的一小段代码可以在某种程度上解决这个问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;img&apos;).on(&apos;error&apos;, function () &#123;</span><br><span class="line">  $(this).prop(&apos;src&apos;, &apos;img/broken.png&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>即使没有发现任何的坏链的情况，也是建议将这段代码添加到页面中。</p>
<h3 id="使用Toggle"><a href="#使用Toggle" class="headerlink" title="使用Toggle"></a>使用Toggle</h3><p>很多时候需要的响应是在用户悬浮在某个元素上时改变其的可见性或者状态，换言之，即是在用户将鼠标悬浮在某个元素上时修改其的类属性，而在用户停止悬浮时移除该类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.btn&apos;).hover(function () &#123;</span><br><span class="line">  $(this).addClass(&apos;hover&apos;);</span><br><span class="line">  &#125;, function () &#123;</span><br><span class="line">    $(this).removeClass(&apos;hover&apos;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>当然，更简单的就是利用 <code>toggleClass</code> 方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.btn&apos;).hover(function () &#123;</span><br><span class="line">  $(this).toggleClass(&apos;hover&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><b>Note</b>: CSS的hover伪类可能是更方便的做法，不过知晓这种用法也是值得的。</p>
<h3 id="禁用输入框"><a href="#禁用输入框" class="headerlink" title="禁用输入框"></a>禁用输入框</h3><p>很多情况下我们希望提交按钮能够在部分文本框未填入的情况下处于禁用状态直到用户执行了某个动作，此时我们就需要为这个按钮添加disabled属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;input[type=&quot;submit&quot;]&apos;).prop(&apos;disabled&apos;, true);</span><br></pre></td></tr></table></figure></p>
<p>如果需要回复输入框的状态，那么就要再次使用 <code>prop</code>方法, 不过将 <code>disabled</code> 的值设置为<code>false</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;input[type=&quot;submit&quot;]&apos;).prop(&apos;disabled&apos;, false);</span><br></pre></td></tr></table></figure></p>
<h3 id="阻止链接的加载"><a href="#阻止链接的加载" class="headerlink" title="阻止链接的加载"></a>阻止链接的加载</h3><p>有时候你不希望用户在点击了某个链接之后跳转到新的页面或者重载当前页面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;a.no-link&apos;).click(function (e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:;&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="触发渐隐-滑动"><a href="#触发渐隐-滑动" class="headerlink" title="触发渐隐/滑动"></a>触发渐隐/滑动</h3><p>滑动与渐隐是jQuery种最常见的动画之一，很多时候我们希望能在用户点击某个元素之后将其渐隐渐出或者滑动出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Fade</span><br><span class="line">$(&apos;.btn&apos;).click(function () &#123;</span><br><span class="line">  $(&apos;.element&apos;).fadeToggle(&apos;slow&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// Toggle</span><br><span class="line">$(&apos;.btn&apos;).click(function () &#123;</span><br><span class="line">  $(&apos;.element&apos;).slideToggle(&apos;slow&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="将两个DIV设置为统一高度"><a href="#将两个DIV设置为统一高度" class="headerlink" title="将两个DIV设置为统一高度"></a>将两个DIV设置为统一高度</h3><p>有时候希望无论两个DIV种包含怎样的内容都能保持统一高度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;.div&apos;).css(&apos;min-height&apos;, $(&apos;.main-div&apos;).height());</span><br></pre></td></tr></table></figure></p>
<h3 id="根据文本选择元素"><a href="#根据文本选择元素" class="headerlink" title="根据文本选择元素"></a>根据文本选择元素</h3><p>通过使用 <code>contains()</code> 选择器可以根据内容搜索对应的元素，下述代码的作用就是在文本不存在的时候隐藏元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var search = $(&apos;#search&apos;).val();</span><br><span class="line">$(&apos;div:not(:contains(&quot;&apos;+search+&apos;&quot;))&apos;).hide();</span><br></pre></td></tr></table></figure></p>
<h3 id="可见性变化时候的触发"><a href="#可见性变化时候的触发" class="headerlink" title="可见性变化时候的触发"></a>可见性变化时候的触发</h3><p>在某个Tab获得焦点或者失去焦点的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(document).on(&apos;visibilitychange&apos;, function(e)&#123;</span><br><span class="line">  if (e.target.visibilityState === &quot;visible&quot;) &#123;</span><br><span class="line">    console.log(&apos;Tab is now in view!&apos;);</span><br><span class="line">  &#125; else if (e.target.visibilityState === &quot;hidden&quot;) &#123;</span><br><span class="line">    console.log(&apos;Tab is now hidden!&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章总结了一些个人的jquery小知识&lt;/p&gt;
&lt;h3 id=&quot;回到顶部的按钮&quot;&gt;&lt;a href=&quot;#回到顶部的按钮&quot; class=&quot;headerlink&quot; title=&quot;回到顶部的按钮&quot;&gt;&lt;/a&gt;回到顶部的按钮&lt;/h3&gt;&lt;p&gt;通过使用jQuery中的&lt;code&gt;ani
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JavaScript中创建对象的模式汇总</title>
    <link href="http://html-js.site/2016/07/05/JavaScript%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB/"/>
    <id>http://html-js.site/2016/07/05/JavaScript中创建对象的模式汇总/</id>
    <published>2016-07-05T06:19:25.000Z</published>
    <updated>2016-07-05T10:06:46.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为超级营销无线装修用到了很多创建对象的方法，而不同的方法对于对象的设计，功能的实现会有很大的不同，所以最近在看代码的时候特意查了下<b>创建对象</b>的各种方法，在这里记录一下</p>
<p>-对象字面量<br>-工厂模式<br>-构造函数模式<br>-原型模式<br>-结合构造函数和原型模式<br>-原型动态模式</p>
<h3 id="1、对象字面量"><a href="#1、对象字面量" class="headerlink" title="1、对象字面量"></a>1、对象字面量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name : &apos;Nicholas&apos;;</span><br><span class="line">    age : &apos;22&apos;;</span><br><span class="line">    job :&quot;software Engineer&quot;</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">      alter(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中创建一个名为person的对象，并为它添加了三个属性（name,age,job）和一个方法（sayName()），其中，sayName()方法用于显示this.name(被解析为person.name)的值。</p>
<p><b>对象字面量可以用来创建单个对象，但这个方法有个明显的缺点：使用同一个接口创建很多对象，会产生大量重复的代码。</b></p>
<h3 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h3><p>工厂模式是软件工程领域中一种广为人知的设计模式，工厂模式抽象了创建具体对象的过程，用函数来封装以特定的接口创建对象的细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function createPerson(name,age,job)&#123;</span><br><span class="line">  var o = new object&#123;&#125;;</span><br><span class="line">  o.name=name;</span><br><span class="line">  o.age=age;</span><br><span class="line">  o.job=job;</span><br><span class="line">  o.sayName=function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line">var person1=creatPerson(&quot;Nicholas&quot;,22,&quot;software Engineer&quot;);</span><br><span class="line">var person2=creatPerson(&quot;Greg&quot;,24,&quot;student&quot;);</span><br></pre></td></tr></table></figure>
<p>函数creatPerson{}能够根据接受的参数构建一个包含所有必要信息的Person对象。可以无数次的调用这个函数，每次都会返回一个包含三个属性一个方法的对象。</p>
<p><b>工厂模型虽然解决了创建多个相似对象的问题，却没有解决对象识别的问题（即怎么知道一个对象的类型）。 </b></p>
<h3 id="3、构造函数模式"><a href="#3、构造函数模式" class="headerlink" title="3、构造函数模式"></a>3、构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">  this.sayName = function() &#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//通过new操作符创建Person的实例</span><br><span class="line">var person1 = new Person(&quot;Nicholas&quot;,22,&quot;software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;,24,&quot;student&quot;);</span><br><span class="line">person1.sayName(); //Nicholas</span><br><span class="line">person2.sayName(); //Greg</span><br></pre></td></tr></table></figure>
<p><b>与工厂模式不同的是</b><br>没有显示的创建对象</p>
<p>直接将属性和方法赋给了this对象</p>
<p>没有return语句</p>
<p>创建Person的新实例，必须使用new操作符。调用构造函数的4个步骤：</p>
<p>创建一个新对象</p>
<p>将构造函数的作用域赋给新对象（this指向了这个新对象）</p>
<p>执行构造函数中的代码</p>
<p>返回新对象</p>
<p>这个例子中创建的所有对象既是Object的实例，也是Person实例。可以通过instanceof操作符验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person1 instanceof Object);//true</span><br></pre></td></tr></table></figure>
<p>构造函数模式也有自己的问题，实际上，sayName方法在每个实例上都会被重新创建一次，需要注意的是，通过实例化创建的方法并不相等，以下代码可以证明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(person1.sayName == person2.sayName);//false</span><br></pre></td></tr></table></figure></p>
<p>可以将方法移到构造器的外部作为全局函数来解决这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;  </span><br><span class="line">&#125;</span><br><span class="line">function sayName() &#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在全局下创建的全局函数实际上只能被经由Person创建的实例调用，这就有点名不副实了；如果对象需要定义很对方法，那么就要定义很多个全局函数，缺少封装性。</p>
<h3 id="4、原型模式"><a href="#4、原型模式" class="headerlink" title="4、原型模式"></a>4、原型模式</h3><p>JavaScript中创建的每个函数都有一个prototype（原型）属性，它是一个指针，指向一个对象，包含了可以由特定类型的所有实例共享的属性和方法（让所有的对象实例共享它的属性和方法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">  Person.prototype.name =&quot;Nicholas&quot;;</span><br><span class="line">  Person.prototype.age = 22;</span><br><span class="line">  Person.prototype.job = &quot;software Engineer&quot;;  </span><br><span class="line">  Person.prototype.sayName()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line"> var person1 = new Person();</span><br><span class="line"> person1.sayName(); //Nicholas</span><br><span class="line">alert(person1.sayName == person2.sayName);//true</span><br></pre></td></tr></table></figure></p>
<p>以上代码做了这几件事情：</p>
<p>定义了一个构造函数Person，Person函数自动获得一个prototype属性，该属性默认只包含一个指向Person的constructor属性</p>
<p>通过Person.prototype添加三个属性，和一个方法</p>
<p>创建一个Person的实例，随后在实例上调用了sayName()方法 </p>
<p>使用Person构造函数和Person.prototype创建实例的代码为例，展示个对象之间的关系 </p>
<p><img src="/images/page/createObject/1.png"></p>
<p>图中展示了Person构造函数、Person的原型属性以及Person的两个实例，之间的关系。Person.prototype指向了原型对象，Person.prototype.constructor有指回了Person。原型对象中除了包含constructor属性，还包含后来添加的其他属性和方法，Person的两个实例person1和person2都包含一个内部属性，该属性仅指向Person.prototype。 </p>
<p><b>sayName()方法的调用过程：</b></p>
<p>在person1实例上查找sayame()方法，发现没有这个方法，于是追溯到person1的原型</p>
<p>在person1的原型上查找sayame()方法，有这个方法，于是调用该方法</p>
<p>基于这样一个查找过程，我们可以通过在实例上定义原型中的同名属性，来阻止该实例访问原型上的同名属性，需要注意的是，这样做并不会删除原型上的同名属性，仅仅是阻止实例访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">  Person.prototype.name =&quot;Nicholas&quot;;</span><br><span class="line">  Person.prototype.age = 22;</span><br><span class="line">  Person.prototype.job = &quot;software Engineer&quot;;  </span><br><span class="line">  Person.prototype.sayName()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line"> var person1 = new Person();</span><br><span class="line"> var person2 = new Person();</span><br><span class="line"> person1.name=&quot;Greg&quot;</span><br><span class="line">alert(person1.name) //Greg 来自实例</span><br><span class="line">alert(person2.name) //Nicholas 来自原型</span><br></pre></td></tr></table></figure>
<p>使用delete操作符可以完全删除实例属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete person1.name;</span><br><span class="line">alert(person1.name) //Nicholas 来自原型</span><br></pre></td></tr></table></figure></p>
<p>使用hasOwnProperty()方法可以检测一个属性是存在于实例还是原型中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">  Person.prototype.name =&quot;Nicholas&quot;;</span><br><span class="line">  Person.prototype.age = 22;</span><br><span class="line">  Person.prototype.job = &quot;software Engineer&quot;;  </span><br><span class="line">  Person.prototype.sayName()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line"> var person1 = new Person();</span><br><span class="line"> var person2 = new Person();</span><br><span class="line"> alert(person1,hasOwnProperty(&quot;name&quot;));//false</span><br><span class="line"> person1.name=&quot;Greg&quot;</span><br><span class="line">alert(person1.name) //Greg 来自实例</span><br><span class="line"> alert(person1,hasOwnProperty(&quot;name&quot;));//true</span><br><span class="line">alert(person2.name) //Nicholas 来自原型</span><br><span class="line"> alert(person2,hasOwnProperty(&quot;name&quot;));//false</span><br><span class="line"> delete person1.name;</span><br><span class="line">alert(person1.name) //Nicholas 来自原型</span><br><span class="line"> alert(person1,hasOwnProperty(&quot;name&quot;));//false</span><br></pre></td></tr></table></figure></p>
<p>下图展示了在不同情况下实例与原型之间的关系<br><img src="/images/page/createObject/2.png"></p>
<h3 id="5、简单的原型语法"><a href="#5、简单的原型语法" class="headerlink" title="5、简单的原型语法"></a>5、简单的原型语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"> Person.prototype=&#123;</span><br><span class="line"> name ：&quot;Nicholas&quot;,</span><br><span class="line"> age ： 22,</span><br><span class="line"> job ： &quot;software Engineer&quot;, </span><br><span class="line"> sayName：function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中constructor属性不再指向Person了，通过constructor无法确定对象的类型了。可以像下面这样特意将他设置回适当的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"> Person.prototype=&#123;</span><br><span class="line"> constructor:Person,</span><br><span class="line"> name ：&quot;Nicholas&quot;,</span><br><span class="line"> age ： 22,</span><br><span class="line"> job ： &quot;software Engineer&quot;,  </span><br><span class="line"> sayName：function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>重设constructor属性会导致它的[[Enumerable]]特性被设置为true，默认情况，原生的constructor属性是不可枚举的，可以使用Object.defineProperty()方法来改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperty(Person.prototype,&quot;constructor&quot;,&#123;</span><br><span class="line">  enumerable:false,</span><br><span class="line">  value:Person</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>原型中查找值的过程是一次搜索，原型对象所做的任何修改都能从实例上立即反应出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var friend=new Person();</span><br><span class="line">Person.prototype.sayHi=function()&#123;</span><br><span class="line">  alert(&quot;hi);</span><br><span class="line">&#125;</span><br><span class="line">friend,sayHi();//&quot;hi&quot;(没有问题)</span><br></pre></td></tr></table></figure></p>
<p>person实例是在添加新方法之前创建的，但仍可以访问新添加的方法，原因是实例与原型之间的松散连接关系 </p>
<p>重写原型对象后的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line">var friend=new Person();</span><br><span class="line"> Person.prototype=&#123;</span><br><span class="line"> name ：&quot;Nicholas&quot;,</span><br><span class="line"> age ： 22,</span><br><span class="line"> job ： &quot;software Engineer&quot;, </span><br><span class="line"> sayName：function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  friend.sayName();//error</span><br></pre></td></tr></table></figure></p>
<p>调用friend.sayName()时发生错误的原因是，friend指向的原型中不包含以该字段命名的属性，如下图。<br><img src="/images/page/createObject/3.png"></p>
<p><b>原型对象的问题</b><br>原型对象省略了为构造函数传递初始化参数这一环节，所有势力在默认情况下都取得相同的属性值。原型模型最大的问题是有其共享本性所导致的。当原型模型包含引用类型的属性来说，问题就比较严重了。来看下面的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;&#125;</span><br><span class="line"> Person.prototype=&#123;</span><br><span class="line"> constructor:Person,</span><br><span class="line"> name ：&quot;Nicholas&quot;,</span><br><span class="line"> age ： 22,</span><br><span class="line"> job ： &quot;software Engineer&quot;,  </span><br><span class="line"> friends:[&quot;Shelby&quot;,&quot;Court&quot;],</span><br><span class="line"> sayName：function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  var person1=new Person();</span><br><span class="line">  var person2=new Person();</span><br><span class="line">  person1.friend.push(&quot;Van&quot;);</span><br><span class="line">  alert(person1.friends);//&quot;Shelby,Court,Van&quot;</span><br><span class="line">  alert(person2.friends);//&quot;Shelby,Court,Van&quot;</span><br><span class="line"> alert(person1.friends==person2.friends);//true</span><br></pre></td></tr></table></figure></p>
<h3 id="5、组合使用构造函数模式和原型模式"><a href="#5、组合使用构造函数模式和原型模式" class="headerlink" title="5、组合使用构造函数模式和原型模式"></a>5、组合使用构造函数模式和原型模式</h3><p>组合使用构造函数模式和原型模式中，构造函数用于定义实例属性，原型模型用于定义方法和共享的属性。这样每个实例都会有自己的一份实例属性的副本，同时也可以共享对方法的引用，最大限度的节省了内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age,job) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;  </span><br><span class="line">  this.friends=[&quot;Shelby&quot;,&quot;Court&quot;];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype=&#123;</span><br><span class="line"> constructor：Person，</span><br><span class="line"> sayName：function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">var person1=new Person(&quot;Nicholas&quot;,22,&quot;software Engineer&quot;);</span><br><span class="line">var person2 = new Person(&quot;Greg&quot;,24,&quot;student&quot;);</span><br><span class="line">person1.friend.push(&quot;Van&quot;);</span><br><span class="line">  alert(person1.friends);//&quot;Shelby,Court,Van&quot;</span><br><span class="line">  alert(person2.friends);//&quot;Shelby,Court&quot;</span><br><span class="line"> alert(person1.friends==person2.friends);//false</span><br><span class="line"> alert(person1.sayName==person2.sayName);//true</span><br></pre></td></tr></table></figure>
<h3 id="6、动态原型模式"><a href="#6、动态原型模式" class="headerlink" title="6、动态原型模式"></a>6、动态原型模式</h3><p>原型动态模式将需要的所有信息都封装到构造函数中，通过if语句判断原型中的某个属性是否存在，若不存在（在第一次调用这个构造函数的时候），执行if语句内部的原型初始化代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job =job;</span><br><span class="line">//方法</span><br><span class="line">  if(typeof this.sayName != &apos;function&apos;) &#123;</span><br><span class="line">  Person.prototype.sayName = function() &#123;</span><br><span class="line">      alert(this.name);</span><br><span class="line">    &#125;;   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new Person(&apos;Nicholas&apos;,&apos;22&apos;,&apos;Software Engineer&apos;);//初次调用构造函数，此时修改了原型</span><br><span class="line">var person2 = new Person(&apos;amy&apos;,&apos;21&apos;);//此时sayName()方法已经存在，不会再修改原型</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;因为超级营销无线装修用到了很多创建对象的方法，而不同的方法对于对象的设计，功能的实现会有很大的不同，所以最近在看代码的时候特意查了下&lt;b&gt;创
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
      <category term="对象" scheme="http://html-js.site/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>自己实现lazyload</title>
    <link href="http://html-js.site/2016/06/28/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0lazyload/"/>
    <id>http://html-js.site/2016/06/28/自己实现lazyload/</id>
    <published>2016-06-28T01:31:12.000Z</published>
    <updated>2016-06-29T09:09:40.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>心血来潮，自己花了一个小时实现了一个简易版的lazyload插件。</p>
<p><a href="/file/lazyload/index.html" target="_blank">例子</a>，<br><a href="https://github.com/WangYang-Rex/lazyload" target="_blank">源代码</a></p>
<h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>插件初始化时对匹配的img元素进行遍历，如果在可是区域之内，那么就赋值src，然后监听scroll事件，直到匹配的img数组为空。</p>
<p>主要用到了getBoundingClientRect()函数，兼容ie，作用是获取元素距离视窗上下左右的距离<br><img src="/images/page/lazyload/1.jpg"></p>
<p><a href="/file/lazyload/index.html" target="_blank">例子</a>，<br><a href="https://github.com/WangYang-Rex/lazyload" target="_blank">源代码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;心血来潮，自己花了一个小时实现了一个简易版的lazyload插件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/file/lazyload/index
    
    </summary>
    
    
      <category term="lazyload" scheme="http://html-js.site/tags/lazyload/"/>
    
      <category term="js" scheme="http://html-js.site/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>window.location hash和search 掐架</title>
    <link href="http://html-js.site/2016/06/17/window-location-hash%E5%92%8Csearch-%E6%8E%90%E6%9E%B6/"/>
    <id>http://html-js.site/2016/06/17/window-location-hash和search-掐架/</id>
    <published>2016-06-17T03:01:03.000Z</published>
    <updated>2016-06-17T05:52:47.143Z</updated>
    
    <content type="html"><![CDATA[<h3 id="发现问题的由来"><a href="#发现问题的由来" class="headerlink" title="发现问题的由来"></a>发现问题的由来</h3><p>首先有个需求，就是获取浏览器参数，也就是 window.location.href问号后面的参数值，就google了一个在江湖中流传的号称最好用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function GetQueryString(name)</span><br><span class="line">&#123;</span><br><span class="line">     var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">     var r = window.location.search.substr(1).match(reg);</span><br><span class="line">     if(r!=null)return  unescape(r[2]); return null;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 调用方法</span><br><span class="line">alert(GetQueryString(&quot;参数名1&quot;));</span><br></pre></td></tr></table></figure></p>
<p>设置了一个全局方法，成功了，立马各个项目用起来~</p>
<p>这次有个需求，在页面加载时去获取参数时发现怎么都获取不到，于是去看代码，发现用到了window.location.search，调试发现window.location.search是空字符串。</p>
<h3 id="科普window-location"><a href="#科普window-location" class="headerlink" title="科普window.location"></a>科普window.location</h3><p>这段内容是W3C上找的，高手请跳过~<br><img src="/images/page/location/2.jpg"></p>
<h4 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h4><p>Location 对象包含有关当前 URL 的信息。</p>
<p>Location 对象是 Window 对象的一个部分，可通过 window.location 属性来访问。<br><img src="/images/page/location/1.jpg"></p>
<h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>search:设置或返回从问号 (?) 开始的 URL（查询部分）。<br>感觉没问题啊，可是为什么window.location.search是空字符串？</p>
<p>请看下图调试结果：<br><img src="/images/page/location/3.jpg"></p>
<p><b>?id=1出现在了hash中，而没有出现在search中</b>，汗！！！</p>
<h3 id="找到答案"><a href="#找到答案" class="headerlink" title="找到答案"></a>找到答案</h3><p>继续google，在<a href="http://stackoverflow.com/questions/23789587/why-is-window-location-search-empty" target="_blick">stackoverflow</a>找到了解答：<br><img src="/images/page/location/4.jpg"></p>
<p>window.location在解析url时，#后面的全都识别成了hash；</p>
<p>个人猜测url解析时,即使遇到?，后面也会去解析#;</p>
<p>相反，如解析时遇到#，后面却不会再去解析? 得找个相关的资料看下了~</p>
<p>一句话，慎用#,慎用#,慎用#，重要的话说三遍！</p>
<p>最后修改了获取浏览器参数的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function GetQueryString(name)</span><br><span class="line">&#123;</span><br><span class="line">     var search = window.location.search;</span><br><span class="line">     if(!search)&#123;</span><br><span class="line">        var hash = location.hash;</span><br><span class="line">        search = hash?hash.substring(hash.indexOf(&apos;?&apos;)):&apos;&apos;;</span><br><span class="line">     &#125;</span><br><span class="line">     var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">     var r = search.substr(1).match(reg);</span><br><span class="line">     if(r!=null)return  unescape(r[2]); return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，根据我们的项目特征，可以把参数设置放在#之前<br>比如：<br><img src="/images/page/location/5.jpg"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://taeyxbak1.superboss.cc/index.html?id=18511#/zx/zdy/</span><br></pre></td></tr></table></figure></p>
<p>当然这个场景设定在我们的框架初始化之前就要拿url参数，如果是框架初始化之后，那么可以用我们框架的方法，相应方法可以在pages里面找到~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;发现问题的由来&quot;&gt;&lt;a href=&quot;#发现问题的由来&quot; class=&quot;headerlink&quot; title=&quot;发现问题的由来&quot;&gt;&lt;/a&gt;发现问题的由来&lt;/h3&gt;&lt;p&gt;首先有个需求，就是获取浏览器参数，也就是 window.location.href问号后面的参数值，
    
    </summary>
    
    
      <category term="window.location" scheme="http://html-js.site/tags/window-location/"/>
    
      <category term="search" scheme="http://html-js.site/tags/search/"/>
    
      <category term="hash" scheme="http://html-js.site/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>mobile reset.css</title>
    <link href="http://html-js.site/2016/06/08/mobile-reset-css/"/>
    <id>http://html-js.site/2016/06/08/mobile-reset-css/</id>
    <published>2016-06-08T07:15:32.000Z</published>
    <updated>2016-06-08T07:21:08.489Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>手机端页面开发有很多未知的问题，android和ios又有所不同，所以有个reset.css会避免掉很多的问题、bug</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* css reset author wangyang */</span><br><span class="line">*&#123;</span><br><span class="line">	cursor: pointer; //为所有dom添加手势，解决IOS下不能点击的对象上绑定点击事件失效的问题</span><br><span class="line">&#125;</span><br><span class="line">html &#123;</span><br><span class="line">  font-family: &quot;Helvetica Neue&quot;, Helvetica, STHeiTi, sans-serif;//设置通用字体</span><br><span class="line">  -webkit-text-size-adjust: 100%;//chrome字体禁止缩放</span><br><span class="line">  font-size: 20px;//设置初始rem基准值</span><br><span class="line">  overflow-y: scroll;</span><br><span class="line">&#125;</span><br><span class="line">body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;</span><br><span class="line">body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;</span><br><span class="line">td,th,caption &#123; font-size:14px; &#125;</span><br><span class="line">h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;</span><br><span class="line">address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;</span><br><span class="line">a,input,textarea,select,button&#123;</span><br><span class="line">  outline: 0;//去除外框</span><br><span class="line">  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);//去除聚焦时的阴影</span><br><span class="line">  -webkit-tap-highlight-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">a &#123;text-decoration:none;&#125; //去除下划线</span><br><span class="line">a:hover &#123; text-decoration:underline; &#125;</span><br><span class="line">a:active&#123;</span><br><span class="line">	outline: 0;</span><br><span class="line">    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);</span><br><span class="line">    -webkit-tap-highlight-color: transparent;</span><br><span class="line">&#125;</span><br><span class="line">img, input, button &#123; border:none; &#125;//去除边框</span><br><span class="line">ol,ul,li &#123; list-style:none; &#125; //去除默认圆点</span><br><span class="line">input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif;border-radius: 0; &#125;</span><br><span class="line">table &#123; </span><br><span class="line">	border-collapse:collapse;  //把表格边框显示为一条单独的边框</span><br><span class="line">	border-spacing: 0; //设置相邻单元格的边框间的距离为0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;手机端页面开发有很多未知的问题，android和ios又有所不同，所以有个reset.css会避免掉很多的问题、bug&lt;/p&gt;
&lt;figur
    
    </summary>
    
    
      <category term="css" scheme="http://html-js.site/tags/css/"/>
    
      <category term="reset.css" scheme="http://html-js.site/tags/reset-css/"/>
    
  </entry>
  
  <entry>
    <title>GitHub/GitLab 代码结构浏览插件-Octotree</title>
    <link href="http://html-js.site/2016/06/03/GitHub-GitLab-%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E6%B5%8F%E8%A7%88%E6%8F%92%E4%BB%B6-Octotree/"/>
    <id>http://html-js.site/2016/06/03/GitHub-GitLab-代码结构浏览插件-Octotree/</id>
    <published>2016-06-03T02:50:46.000Z</published>
    <updated>2016-06-08T06:13:34.108Z</updated>
    
    <content type="html"><![CDATA[<p>Octotree 是一个浏览器扩展（Chrome，Firefox，Opera和Safari），用以显示GitHub/GitLab 代码结构(代码树)。可以非常方便的浏览项目源代码，这样不必把每个项目拉取到你的机器。浏览器浏览时就像使用IDE目录结构，也不必来回的前进后退。</p>
<p>项目地址：<a href="https://github.com/buunguyen/octotree" target="_blank" rel="external">https://github.com/buunguyen/octotree</a></p>
<p><img src="/images/page/Octotree/1.png"></p>
<p><img src="/images/page/Octotree/2.png"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Octotree 是一个浏览器扩展（Chrome，Firefox，Opera和Safari），用以显示GitHub/GitLab 代码结构(代码树)。可以非常方便的浏览项目源代码，这样不必把每个项目拉取到你的机器。浏览器浏览时就像使用IDE目录结构，也不必来回的前进后退。&lt;
    
    </summary>
    
    
      <category term="Octotree" scheme="http://html-js.site/tags/Octotree/"/>
    
  </entry>
  
  <entry>
    <title>webpack前端模块加载工具</title>
    <link href="http://html-js.site/2016/05/30/webpack%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%B7%A5%E5%85%B7/"/>
    <id>http://html-js.site/2016/05/30/webpack前端模块加载工具/</id>
    <published>2016-05-30T11:34:21.000Z</published>
    <updated>2016-06-08T06:13:46.252Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看许多React的资料，发现了大部分的项目都是用webpack行模块化管理的工具。这次也是借着写了一个React-Todos的小应用，对webPack最基本实用的功能体验了一番，顺带做个小记录。</p>
<h3 id="为什么用webpack"><a href="#为什么用webpack" class="headerlink" title="为什么用webpack"></a>为什么用webpack</h3><h3 id="CommonJs与AMD"><a href="#CommonJs与AMD" class="headerlink" title="CommonJs与AMD"></a>CommonJs与AMD</h3><p>在一开始，我们先讲一下它和以往我们所用的模块管理工具有什么不一样。在最开始的阶段，Js并没有这些模块机制，各种Js到处飞，得不到有效妥善的管理。后来前端圈开始制定规范，最耳熟能详的是CommonJs和AMD。</p>
<p>CommonJs是应用在NodeJs，是一种同步的模块机制。它的写法大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var firstModule = require(&quot;firstModule&quot;);</span><br><span class="line"></span><br><span class="line">//your code...</span><br><span class="line"></span><br><span class="line">module.export = anotherModule</span><br></pre></td></tr></table></figure></p>
<p>AMD的应用场景则是浏览器，异步加载的模块机制。require.js的写法大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;firstModule&apos;], function(module)&#123;</span><br><span class="line">  </span><br><span class="line">  //your code...</span><br><span class="line">  return anotherModule</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>其实我们单比较写法，就知道CommonJs是更为优秀的。它是一种同步的写法，对Human友好，而且代码也不会繁琐臃肿。但更重要的原因是， 随着npm成为主流的JavaScript组件发布平台，越来越多的前端项目也依赖于npm上的项目，或者自身就会发布到npm平台。 所以我们对如何可以使用npm包中的模块是我们的一大需求。所以browserify工具就出现了，它支持我们直接使用 require() 的同步语法去加载npm模块。</p>
<p>当然我们这里不得不说的是，ES2015（ES6）里也有了自己的模块机制，也就是说ES6的模块机制是官方规定的，我们通过 <a href="https://babeljs.io/" rel="external" target="_blank">babel</a> （一种6to5的编译器）可以使用比较多的新特性了，包括我们提到的模块机制，而它的写法大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123;someModule&#125; from &quot;someModule&quot;;</span><br><span class="line"></span><br><span class="line">// your codes...</span><br><span class="line"></span><br><span class="line">export anotherModule;</span><br></pre></td></tr></table></figure></p>
<p>当然上面的写法只是最基本的，还有其他的不同加载模块的写法，可以看一下阮一峰老师的 <a href="http://es6.ruanyifeng.com/#docs/class" rel="external" target="_blank">ECMAScript 6 入门</a> 或者babel的相关文档 <a href="https://babeljs.io/docs/learn-es2015/#modules" rel="external" target="_blank">Learn ES2015</a> 。</p>
<h3 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h3><h4 id="browserify的出现非常棒，但webpack更胜一筹"><a href="#browserify的出现非常棒，但webpack更胜一筹" class="headerlink" title="browserify的出现非常棒，但webpack更胜一筹"></a>browserify的出现非常棒，但webpack更胜一筹</h4><p>我们来看看webpack支持哪些功能特性：</p>
<ul>
<li>支持CommonJs和AMD模块，意思也就是我们基本可以无痛迁移旧项目。</li>
<li>支持模块加载器和插件机制，可对模块灵活定制。特别是我最爱的babel-loader，有效支持ES6。</li>
<li>可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。</li>
<li>将样式文件和图片等静态资源也可视为模块进行打包。配合loader加载器，可以支持sass，less等CSS预处理器。</li>
<li>内置有source map，即使打包在一起依旧方便调试。</li>
</ul>
<p>看完上面这些，可以想象它就是一个前端工具，可以让我们进行各种模块加载，预处理后，再打包。之前我们对这些的处理是放在grunt或gulp等前端自动化工具中。有了webpack，我们无需借助自动化工具对模块进行各种处理，让我们工具的任务分的更加清晰。</p>
<p>我们看一下官方对webpack理解的图。<br><img src="/images/page/webpack/1.jpg"><br>任何静态资源都可以视作模块，然后模块之间也可以相互依赖，通过webpack对模块进行处理后，可以打包成我们想要的静态资源。</p>
<p>既然已经大致知道为什么我们要使用webpack了，我们接下来就开始使用webpack吧！</p>
<h3 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h3><p>首先新建一个webpack101的项目，我们将在webpack101这里开展我们接下来的各项学习<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ npm init // 用于初始化项目的package.json</span><br><span class="line"></span><br><span class="line">//初始化文件目录：</span><br><span class="line">webpack101</span><br><span class="line">  --- src</span><br><span class="line">    --- entry.js</span><br><span class="line">    --- module1.js</span><br><span class="line">  --- index.html</span><br><span class="line">  --- package.json</span><br><span class="line">  --- webpack.config.js</span><br></pre></td></tr></table></figure></p>
<h3 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h3><p>我们通过npm来将webpack安装到全局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install webpack -g</span><br></pre></td></tr></table></figure></p>
<h3 id="一个最简单的webpack"><a href="#一个最简单的webpack" class="headerlink" title="一个最简单的webpack"></a>一个最简单的webpack</h3><h4 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h4><p>webpack是需要进行配置的，我们在使用webpack的时候，会默认 webpack.config.js 为我们的配置文件。所以接下来，我们新建这个js文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &apos;../src/entry.js&apos;, //演示单入口文件</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &apos;out&apos;),  //打包输出的路径</span><br><span class="line">    filename: &apos;bundle.js&apos;,			  //打包后的名字</span><br><span class="line">    publicPath: &quot;./out/&quot;				//html引用路径，在这里是本地地址。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="编写入口文件"><a href="#编写入口文件" class="headerlink" title="编写入口文件"></a>编写入口文件</h3><p>接下来就编写我们的入口文件 entry.js 和第一个模块文件 module1.js 。我们一切从简，里面只用来加载一个Js模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// entry.js</span><br><span class="line">require(&quot;./module1&quot;); // 使用CommonJs来加载模块</span><br></pre></td></tr></table></figure></p>
<p>下一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// module1.js</span><br><span class="line">console.log(&quot;Hello Webpack!&quot;);</span><br></pre></td></tr></table></figure></p>
<h3 id="启动webpack"><a href="#启动webpack" class="headerlink" title="启动webpack"></a>启动webpack</h3><p>一切准备好后，我们仅需要在项目根目录下，用命令行 webpack 执行一下即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// webpack 命令行的几种基本命令</span><br><span class="line"></span><br><span class="line">$ webpack // 最基本的启动webpack方法</span><br><span class="line">$ webpack -w // 提供watch方法，实时进行打包更新</span><br><span class="line">$ webpack -p // 对打包后的文件进行压缩，提供production</span><br><span class="line">$ webpack -d // 提供source map，方便调试。</span><br></pre></td></tr></table></figure></p>
<p>webpack成功运行后，我们就可以看到根目录出现了out文件夹，里面有我们打包生成的 bundle.js 。我们最后通过在 index.html 里对这个文件引入就可以了。我们可以在控制台看到我们想要的结果， <b>Hello Webpack !</b></p>
<h3 id="多模块依赖"><a href="#多模块依赖" class="headerlink" title="多模块依赖"></a>多模块依赖</h3><p>刚才的例子，我们仅仅是跑通了webpack通过 entry.js 入口文件进行打包的例子。下面我们就来看一下它是否真的支持CommonJs和AMD两种模块机制呢？下面我们新建多几个js文件吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 修改module1.js</span><br><span class="line">require([&quot;./module3&quot;], function()&#123;</span><br><span class="line">  console.log(&quot;Hello Webpack!&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>下一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// module2.js，使用的是CommonJs机制导出包</span><br><span class="line">module.exports = function(a, b)&#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下一个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// module3.js，使用AMD模块机制</span><br><span class="line">define([&apos;./module2.js&apos;], function(sum)&#123;</span><br><span class="line">  return console.log(&quot;1 + 2 = &quot; + sum(1, 2));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>其实像上面这样混用两种不同机制非常不好，这里仅仅是展示用的，在开发新项目时还是推荐CommonJs或ES2015的Module。当然我个人更倾向于ES2015的模块机制的～</p>
<h3 id="loader加载器"><a href="#loader加载器" class="headerlink" title="loader加载器"></a>loader加载器</h3><p>到了我最喜欢也是最激动人心的功能了！我们先想想应用场景，前端社区有许多预处理器供我们使用。我们可以使用这些预处理器做一些强大的事情，大家都听过的就是 CoffeeScript 和 Sass 了。我们以前要编译这些预处理器，就是用 gulp 进行编译。但是我们对这些文件处理其实也挺繁琐的，webpack可以一次性解决！</p>
<p>在这里我们用Sass和babel编译ES2015为例子，看一下loader是如何使用的。</p>
<h3 id="安装loader"><a href="#安装loader" class="headerlink" title="安装loader"></a>安装loader</h3><p>我们第一步就是先要安装好各个必须的loader，我们直接看看需要通过npm安装什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install style-loader css-loader url-loader babel-loader sass-loader file-loader --save-dev</span><br></pre></td></tr></table></figure></p>
<h3 id="配置loader"><a href="#配置loader" class="headerlink" title="配置loader"></a>配置loader</h3><p>安装完各个loader后，我们就需要配置一下我们的 webpack.config.js ，载入我们的loader。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: path.join(__dirname, &apos;src/entry.js&apos;),</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, &apos;out&apos;),</span><br><span class="line">    publicPath: &quot;./out/&quot;,</span><br><span class="line">    filename: &apos;bundle.js&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 新添加的module属性</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;test: /\.js$/, loader: &quot;babel&quot;&#125;,</span><br><span class="line">      &#123;test: /\.css$/, loader: &quot;style!css&quot;&#125;,</span><br><span class="line">      &#123;test: /\.(jpg|png)$/, loader: &quot;url?limit=8192&quot;&#125;,</span><br><span class="line">      &#123;test: /\.scss$/, loader: &quot;style!css!sass&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们主要看看module的loaders。loaders是一个数组，里面的每一个对象都用正则表达式，对应着一种配对方案。比如匹配到js后缀名就用babel-loader，匹配到scss后缀名的就先用sass，再用css，最后用style处理，不同的处理器通过 ! 分隔并串联起来。这里的loader是可以省略掉 -loader 这样的，也就是原本应该写成 style-loader!css-loader!sass-loader ，当然我们必须惜字如金，所以都去掉后面的东东。</p>
<p>我们仅仅是配置一下，已经是可以直接用ES2015和SASS去写我们的前端代码了。在此之前，我们对src文件夹里再细分成js，css，image三个文件夹，处理好分层。话不多说，赶紧试试。</p>
<h3 id="稍微复杂的webpack项目"><a href="#稍微复杂的webpack项目" class="headerlink" title="稍微复杂的webpack项目"></a>稍微复杂的webpack项目</h3><h3 id="bebel-loader"><a href="#bebel-loader" class="headerlink" title="bebel-loader"></a>bebel-loader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// js/es6-module.js</span><br><span class="line">class People&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayhi()&#123;</span><br><span class="line">    console.log(`hi $&#123;this.name&#125; !`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">exports.module = People;</span><br></pre></td></tr></table></figure>
<p>写好模块后，我们直接在 entry.js 入口文件中引入该模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// entry.js</span><br><span class="line"></span><br><span class="line">// javascript</span><br><span class="line">require(&apos;./js/module1&apos;);</span><br><span class="line">let People = require(&apos;./js/es6-module&apos;);</span><br><span class="line">let p = new People(&quot;Yika&quot;);</span><br><span class="line">p.sayHi();</span><br><span class="line"></span><br><span class="line">// css</span><br><span class="line">require(&apos;./css/main.scss&apos;);</span><br></pre></td></tr></table></figure></p>
<p>哈哈哈，不能再爽！这下子我们可以使用很多优秀的ES6特性去构建大型的web了</p>
<h3 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h3><p>大家或许注意到了下方的css的require，那就是用来加载Sass样式的。我们通过启动style-loader会将css代码转化到 style 标签内，我们看一下里面的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// css/main.scss</span><br><span class="line">html, body&#123;</span><br><span class="line">  background: #dfdfdf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后我们打开 index.html 观察我们所有的结果，首先背景已经是淡灰色的，并且控制台也有我们想要的内容。我们通过查看DOM结构，可以发现 head 标签里多出了 style 标签，里面正是我们想要定制的样式</p>
<h3 id="关于对图片的打包"><a href="#关于对图片的打包" class="headerlink" title="关于对图片的打包"></a>关于对图片的打包</h3><p>我们之前也说，webpack对与静态资源来说，也是看作模块来加载的。CSS我们是已经看过了，那图片是怎么作为模块打包加载进来呢？这里我们可以想到，图片我们是用url-loader加载的。我们在css文件里的url属性，其实就是一种封装处理过require操作。当然我们还有一种方式就是直接对元素的src属性进行require赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div.img&#123;</span><br><span class="line">  background: url(../image/xxx.jpg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//或者</span><br><span class="line">var img = document.createElement(&quot;img&quot;);</span><br><span class="line">img.src = require(&quot;../image/xxx.jpg&quot;);</span><br><span class="line">document.body.appendChild(img);</span><br></pre></td></tr></table></figure>
<p>上述两种方法都会对符合要求的图片进行处理。而要求就是在url-loader后面通过query参数的方式实现的，这里就是说只有不大于8kb的图片才会打包处理成Base64的图片。关于query，请看文档： <a href="http://webpack.github.io/docs/using-loaders.html#query-parameters" rel="external" target="_blank">Query parameters</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;test: /\.(jpg|png)$/, loader: &quot;url?limit=8192&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="打包成多个资源文件"><a href="#打包成多个资源文件" class="headerlink" title="打包成多个资源文件"></a>打包成多个资源文件</h3><p>我们在开发多页面的站点的时候，还是需要希望能有多个资源文件的。这样我们就可以有效利用缓存提升性能，做到文件按需加载。如何写入口文件，这里就不再赘述了，我们直接看如何对 webpack.config.js 进行修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// webpack.config.js</span><br><span class="line"></span><br><span class="line">entry: &#123;</span><br><span class="line">  page1: &quot;entry.js&quot;,</span><br><span class="line">  page2: &quot;entry2.js&quot;</span><br><span class="line">&#125;,</span><br><span class="line">output: &#123;</span><br><span class="line">  path: path.join(__dirname, &apos;out&apos;),</span><br><span class="line">    publicPath: &quot;./out/&quot;,</span><br><span class="line">    filename: &apos;[name].js&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里重点关注两个地方，entry属性可以是一个对象，而对象名也就是key会作为下面output的filename属性的 [name] 。当然entry也可以是一个数组，更多用法都可以去webpack的 <a href="https://webpack.github.io/docs/" rel="external" target="_blank">官方文档</a> 进行查看。</p>
<p>当然webpack也考虑到公共模块的利用，我们利用插件就可以智能提取公共部分，以提供我们浏览器的缓存复用。我们只需要在 webpack.config.js 添加下面的代码即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 修改添加，webpack.config.js</span><br><span class="line">var webpack = require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ....省略各种代码</span><br><span class="line">      plugins: [</span><br><span class="line">        new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;)</span><br><span class="line">      ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们做个小测试，让第二个入口文件也加载我们之前的 es6-module.js 。然后我们用webpack进行打包，就发现生成的 common.js 里是有相应代码的。我们需要手动在html上去加载 common.js ，并且是<b> 必须要最先加载</b> 。</p>
<h3 id="独立出css样式"><a href="#独立出css样式" class="headerlink" title="独立出css样式"></a>独立出css样式</h3><p>如果我们希望样式通过 <link> 引入，而不是放在 style 标签内呢，即使这样做会多一个请求。这个时候我们就要配合插件一起使用啦，我们一起来看看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install extract-text-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure></p>
<p>安装完插件就要配置 webpack.config.js 了。我们添加以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...省略各种代码</span><br><span class="line">  module: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;test: /\.js$/, loader: &quot;babel&quot;&#125;,</span><br><span class="line">      &#123;test: /\.css$/, loader: ExtractTextPlugin.extract(&quot;style-loader&quot;, &quot;css-loader&quot;)&#125;,</span><br><span class="line">      &#123;test: /\.(jpg|png|svg)$/, loader: &quot;url?limit=8192&quot;&#125;,</span><br><span class="line">      &#123;test: /\.scss$/, loader: &quot;style!css!sass&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;),</span><br><span class="line">    new ExtractTextPlugin(&quot;[name].css&quot;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了区分开用 <link> 链接和用 style ，我们这里以CSS后缀结尾的模块用插件。我们重点关注一下使用了ExtractTextPlugin的模块，在ExtractTextPlugin的extract方法有两个参数，第一个参数是经过编译后通过style-loader单独提取出文件来，而第二个参数就是用来编译代码的loader。</p>
<p>当然，插件也支持所有独立样式打包成一个css文件。增加多一个参数即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new ExtractTextPlugin(&quot;style.css&quot;, &#123;allChunks: true&#125;)</span><br></pre></td></tr></table></figure></p>
<p>至于怎样加载样式是最佳实践，这个就要自己平时多思考了。多站点多样式的时候，是做到一次性打包加载呢，还是按需加载呢？我这里就建议一项，主页尽量做到最精简，毕竟决定用户存留时间。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>前端社区不断发展，越来越趋向于组件化的发展。通过webpack，我们就能体验到 one component one module 的开发感觉。当然如何更好的使用webpack还是要通过不断的思考总结，才能找到最优的方案。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="http://webpackdoc.com/development.html" target="_blank" rel="external">http://webpackdoc.com/development.html</a><br><a href="https://github.com/webpack/worker-loader" target="_blank" rel="external">https://github.com/webpack/worker-loader</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看许多React的资料，发现了大部分的项目都是用webpack行模块化管理的工具。这次也是借着写了一个React-Todos的小应用，对webPack最基本实用的功能体验了一番，顺带做个小记录。&lt;/p&gt;
&lt;h3 id=&quot;为什么用webpack&quot;&gt;&lt;a href=&quot;#为
    
    </summary>
    
    
      <category term="webpack" scheme="http://html-js.site/tags/webpack/"/>
    
      <category term="打包工具" scheme="http://html-js.site/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>移动端适配方案</title>
    <link href="http://html-js.site/2016/05/30/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/"/>
    <id>http://html-js.site/2016/05/30/移动端适配方案/</id>
    <published>2016-05-30T02:22:08.000Z</published>
    <updated>2016-06-08T06:14:35.183Z</updated>
    
    <content type="html"><![CDATA[<p>原文地址：<a href="http://www.cnblogs.com/lyzg/p/4877277.html" target="_blank">http://www.cnblogs.com/lyzg/p/4877277.html</a></p>
<p>目前很多流行的，html5要适应各种分辨率的移动设备，应该使用rem尺寸单位，各个分辨率范围在html上设置font-size.</p>
<p>这里介绍我们项目组在用的适配方案：<br>页面加载的时候通过js计算出html的font-size。</p>
<h3 id="计算和设计稿有关"><a href="#计算和设计稿有关" class="headerlink" title="计算和设计稿有关"></a>计算和设计稿有关</h3><p>拿网易来说，它的设计稿应该是基于iphone4或者iphone5来的，所以它的设计稿竖直放时的横向分辨率为640px，为了计算方便，取一个100px的font-size为参照，那么body元素的宽度就可以设置为width: 6.4rem，于是html的font-size=deviceWidth / 6.4。这个deviceWidth就是viewport设置中的那个deviceWidth。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deviceWidth = 320，font-size = 320 / 6.4 = 50px</span><br><span class="line">deviceWidth = 375，font-size = 375 / 6.4 = 58.59375px</span><br><span class="line">deviceWidth = 414，font-size = 414 / 6.4 = 64.6875px</span><br><span class="line">deviceWidth = 500，font-size = 500 / 6.4 = 78.125px</span><br></pre></td></tr></table></figure></p>
<p>事实上网易就是这么干的，你看它的代码就知道，body元素的宽是：<br><img src="/images/page/adapter/1.png"></p>
<p>根据这个可以肯定它的设计稿竖着时的横向分辨率为640。然后你再看看网易在分辨率为320<em>680，375</em>680，414<em>680，500</em>680时，html的font-size是不是与上面计算的一致：</p>
<p><img src="/images/page/adapter/2.png"><br><img src="/images/page/adapter/3.png"><br><img src="/images/page/adapter/4.png"><br><img src="/images/page/adapter/5.png"></p>
<p>贴上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">(function (doc, win) &#123;</span><br><span class="line">    var docEl = doc.documentElement,</span><br><span class="line">            isIOS = navigator.userAgent.match(/iphone|ipod|ipad/gi),</span><br><span class="line">            dpr = isIOS? Math.min(win.devicePixelRatio, 3) : 1,</span><br><span class="line">            dpr = window.top === window.self? dpr : 1, //被iframe引用时，禁止缩放</span><br><span class="line">            dpr = 1, // 首页引用IFRAME，强制为1</span><br><span class="line">            scale = 1 / dpr,</span><br><span class="line">            resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;;</span><br><span class="line">    docEl.dataset.dpr = win.devicePixelRatio;</span><br><span class="line">    if(navigator.userAgent.match(/iphone/gi) &amp;&amp; screen.width == 375 &amp;&amp; win.devicePixelRatio == 2)&#123;</span><br><span class="line">        docEl.classList.add(&apos;iphone6&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    if(navigator.userAgent.match(/iphone/gi) &amp;&amp; screen.width == 414 &amp;&amp; win.devicePixelRatio == 3)&#123;</span><br><span class="line">        docEl.classList.add(&apos;iphone6p&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">    var metaEl = doc.createElement(&apos;meta&apos;);</span><br><span class="line">    metaEl.name = &apos;viewport&apos;;</span><br><span class="line">    metaEl.content = &apos;initial-scale=&apos; + scale + &apos;,maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale;</span><br><span class="line">    docEl.firstElementChild.appendChild(metaEl);</span><br><span class="line">    var recalc = function () &#123;</span><br><span class="line">        var width = docEl.clientWidth;</span><br><span class="line">        if (width / dpr &gt; 640) &#123;</span><br><span class="line">            //width = 640 * dpr;</span><br><span class="line">        &#125;</span><br><span class="line">        docEl.style.cssText  = &quot;font-size:&quot;+(40 * (width / 640)) + &apos;px!important&apos;;</span><br><span class="line">        //docEl.style.fontSize = 40 * (width / 640) + &apos;px&apos;;</span><br><span class="line">        //document.body.style.width = 16rem;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    recalc()</span><br><span class="line">    if (!doc.addEventListener) return;</span><br><span class="line">    // win.addEventListener(resizeEvt, recalc, false);</span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure></p>
<p>还有，如果采用网易的这种做法，视口要如下设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1,maximum-scale=1, minimum-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文地址：&lt;a href=&quot;http://www.cnblogs.com/lyzg/p/4877277.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/lyzg/p/4877277.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前很多流行的，h
    
    </summary>
    
    
      <category term="移动端" scheme="http://html-js.site/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="适配" scheme="http://html-js.site/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://html-js.site/2016/05/20/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://html-js.site/2016/05/20/排序算法/</id>
    <published>2016-05-20T02:59:52.000Z</published>
    <updated>2016-08-23T10:08:48.620Z</updated>
    
    <content type="html"><![CDATA[<p>平常在项目中可能都会用到排序，就我本人而言，可能大部分都是用的选择排序或者冒泡排序，简单粗暴，但是这往往都只是实现了功能，而没有去关注性能，所以还是有必要了解常用的排序方法(<b>使用内存</b>)。</p>
<h2 id="插入排序-直接插入排序"><a href="#插入排序-直接插入排序" class="headerlink" title="插入排序-直接插入排序"></a>插入排序-直接插入排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想:"></a>基本思想:</h3><p>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p>
<h3 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h3><p>设立哨兵，作为临时存储和判断数组边界之用。</p>
<h3 id="直接插入排序示例："><a href="#直接插入排序示例：" class="headerlink" title="直接插入排序示例："></a>直接插入排序示例：</h3><p><img width="500" src="/images/page/sort/1.jpg"></p>
<p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，<b>所以插入排序是稳定的。</b></p>
<h3 id="原理演示："><a href="#原理演示：" class="headerlink" title="原理演示："></a>原理演示：</h3><p><a href="/file/sortAnimate/index.html" target="_blank">点击查看</a></p>
<h3 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function insertSortArray(sort_Array,x)&#123;         //一趟排序的算法</span><br><span class="line">for(var i=0;i&lt;sort_Array.length;i++)&#123;</span><br><span class="line">   if(sort_array[i]&gt;=x)&#123;                    //找到插入点</span><br><span class="line">    for (var j=sort_array.length; j&gt;i; j--)&#123;   //后挪空出位置 </span><br><span class="line">     sort_array[j]=sort_array[j-1]         </span><br><span class="line">    &#125;</span><br><span class="line">    sort_array[i]=x;                             //插入</span><br><span class="line">    break;                                      //任务结束，退出循环</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">return sort_array;                                      //返回处理后的数组</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function SortArrayByInsert(array)&#123;                      //主排序算法</span><br><span class="line">var returnValue=new Array(1);                        //定义成功排序后的返回值，初始大小为一位</span><br><span class="line">returnValue[0]=array[0];                               //在结果后置入排序前的第一位</span><br><span class="line">for (i=1; i&lt;array.length; i++)&#123;</span><br><span class="line">   returnValue=insertSortArray(returnValue,array[i]);     //调用一趟排序函数，从第二个元素开始，依次使用</span><br><span class="line">&#125;</span><br><span class="line">return returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-插入排序—希尔排序（Shell-s-Sort）"><a href="#2-插入排序—希尔排序（Shell-s-Sort）" class="headerlink" title="2.插入排序—希尔排序（Shell`s Sort）"></a>2.插入排序—希尔排序（Shell`s Sort）</h2><p>希尔排序是1959 年由D.L.Shell 提出来的，相对直接排序有较大的改进。希尔排序又叫<b>缩小增量排序</b></p>
<h3 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p>
<h3 id="原理演示：-1"><a href="#原理演示：-1" class="headerlink" title="原理演示："></a>原理演示：</h3><p><a href="/file/sortAnimate/index.html" target="_blank">点击查看</a></p>
<h3 id="操作方法："><a href="#操作方法：" class="headerlink" title="操作方法："></a>操作方法：</h3><ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p><img width="500" src="/images/page/sort/2.jpg"></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 …..1} n为要排序数的个数</p>
<p>即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function shellInsertSort(elements, di)&#123;</span><br><span class="line">  //从增量的所在位置开始</span><br><span class="line">  for(var i = di; i &lt; elements.length; i++)&#123;</span><br><span class="line">    //升序</span><br><span class="line">    if(elements[i] &lt; elements[i-di])&#123;</span><br><span class="line">      //取出增量位置的元素作为被插入元素（哨兵）</span><br><span class="line">      var guard = elements[i];</span><br><span class="line">      var j = i - di;</span><br><span class="line">      elements[i] = elements[j];</span><br><span class="line">      </span><br><span class="line">      //向前，将增量的倍数的位置作为同一组比较及进行直接插入法</span><br><span class="line">      while(j &gt;= 0 &amp;&amp; guard &lt; elements[j])&#123;</span><br><span class="line">        elements[j+di] = elements[j];</span><br><span class="line">        j -= di;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      //插入</span><br><span class="line">      elements[j + di] = guard;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function shellSort(elements)&#123;</span><br><span class="line">  //增量为序列的一半</span><br><span class="line">  var di = parseInt(elements.length / 2);</span><br><span class="line">  while(di &gt;= 1)&#123;</span><br><span class="line">    shellInsertSort(elements, di);</span><br><span class="line">    //每次减半，最后增量必须为1</span><br><span class="line">    di = parseInt(di / 2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var elements = [10, 9, 8, 7, 6, 5];</span><br><span class="line">console.log(&apos;before: &apos; + elements);</span><br><span class="line">shellSort(elements);</span><br><span class="line">console.log(&apos; after: &apos; + elements);</span><br></pre></td></tr></table></figure>
<p>效率：比直接插入法快。但不是一种稳定的排序算法，关键取决于增量的选择，初次通常选取序列长度的一半。</p>
<h2 id="3-选择排序—简单选择排序（Simple-Selection-Sort）"><a href="#3-选择排序—简单选择排序（Simple-Selection-Sort）" class="headerlink" title="3.选择排序—简单选择排序（Simple Selection Sort）"></a>3.选择排序—简单选择排序（Simple Selection Sort）</h2><h3 id="基本思想：-1"><a href="#基本思想：-1" class="headerlink" title="基本思想："></a>基本思想：</h3><p>在要排序的一组数中，选出最小（或者最大）的一个数与<b style="color:green">第1个位置</b>的数交换；然后在剩下的数当中再找最小（或者最大）的与<b style="color:green">第2个位置</b>的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>
<h3 id="简单选择排序的示例"><a href="#简单选择排序的示例" class="headerlink" title="简单选择排序的示例"></a>简单选择排序的示例</h3><p><img width="500" src="/images/page/sort/3.jpg"></p>
<h3 id="原理演示：-2"><a href="#原理演示：-2" class="headerlink" title="原理演示："></a>原理演示：</h3><p><a href="/file/sortAnimate/index.html" target="_blank">点击查看</a></p>
<h3 id="操作方法：-1"><a href="#操作方法：-1" class="headerlink" title="操作方法："></a>操作方法：</h3><p>第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；</p>
<p>第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；</p>
<p>以此类推…..</p>
<p>第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，</p>
<p>直到整个序列按关键码有序。</p>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sorrt(ary) &#123;</span><br><span class="line">    length = ary.length;</span><br><span class="line">    for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        _min = ary[i]</span><br><span class="line">        k = i</span><br><span class="line">        for (var j = i + 1; j &lt; length; j++) &#123;</span><br><span class="line">            if (_min &gt; ary[j]) &#123;</span><br><span class="line">                _min = ary[j]</span><br><span class="line">                k = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ary[k] = ary[i]</span><br><span class="line">        ary[i] = _min</span><br><span class="line">    &#125;</span><br><span class="line">    return ary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单选择排序的改进——二元选择排序</p>
<p>简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。</p>
<h2 id="4-交换排序—冒泡排序（Bubble-Sort）"><a href="#4-交换排序—冒泡排序（Bubble-Sort）" class="headerlink" title="4. 交换排序—冒泡排序（Bubble Sort）"></a>4. 交换排序—冒泡排序（Bubble Sort）</h2><h3 id="基本思想：-2"><a href="#基本思想：-2" class="headerlink" title="基本思想："></a>基本思想：</h3><p>在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p>
<h3 id="冒泡排序的示例"><a href="#冒泡排序的示例" class="headerlink" title="冒泡排序的示例"></a>冒泡排序的示例</h3><p><img width="500" src="/images/page/sort/4.jpg"></p>
<h3 id="原理演示：-3"><a href="#原理演示：-3" class="headerlink" title="原理演示："></a>原理演示：</h3><p><a href="/file/sortAnimate/index.html" target="_blank">点击查看</a></p>
<h3 id="算法的实现："><a href="#算法的实现：" class="headerlink" title="算法的实现："></a>算法的实现：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(int a[], int n)&#123;</span><br><span class="line">  for(int i =0 ; i&lt; n-1; ++i) &#123;</span><br><span class="line">    for(int j = 0; j &lt; n-i-1; ++j) &#123;</span><br><span class="line">      if(a[j] &gt; a[j+1])</span><br><span class="line">      &#123;</span><br><span class="line">        int tmp = a[j] ; a[j] = a[j+1] ;  a[j+1] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序算法的改进"><a href="#冒泡排序算法的改进" class="headerlink" title="冒泡排序算法的改进"></a>冒泡排序算法的改进</h3><p>对冒泡排序常见的改进方法是加入一标志性变量exchange，用于标志某一趟排序过程中是否有数据交换，如果进行某一趟排序时并没有进行数据交换，则说明数据已经按要求排列好，可立即结束排序，避免不必要的比较过程。</p>
<h2 id="5-交换排序—快速排序（Quick-Sort）"><a href="#5-交换排序—快速排序（Quick-Sort）" class="headerlink" title="5. 交换排序—快速排序（Quick Sort）"></a>5. 交换排序—快速排序（Quick Sort）</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,</p>
<p>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</p>
<p>3）此时基准元素在其排好序后的正确位置</p>
<p>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p>
<h3 id="原理演示：-4"><a href="#原理演示：-4" class="headerlink" title="原理演示："></a>原理演示：</h3><p><a href="/file/sortAnimate/index.html" target="_blank">点击查看</a></p>
<h3 id="快速排序的示例："><a href="#快速排序的示例：" class="headerlink" title="快速排序的示例："></a>快速排序的示例：</h3><p>（a）一趟排序的过程：<br><img width="500" src="/images/page/sort/5.jpg"><br>（b）排序的全过程<br><img width="500" src="/images/page/sort/6.jpg"></p>
<h3 id="算法的实现：-1"><a href="#算法的实现：-1" class="headerlink" title="算法的实现："></a>算法的实现：</h3><p> 递归实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void print(int a[], int n)&#123;  </span><br><span class="line">    for(int j= 0; j&lt;n; j++)&#123;  </span><br><span class="line">        cout&lt;&lt;a[j] &lt;&lt;&quot;  &quot;;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout&lt;&lt;endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">void swap(int *a, int *b)  </span><br><span class="line">&#123;  </span><br><span class="line">    int tmp = *a;  </span><br><span class="line">    *a = *b;  </span><br><span class="line">    *b = tmp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int partition(int a[], int low, int high)  </span><br><span class="line">&#123;  </span><br><span class="line">    int privotKey = a[low];                             //基准元素  </span><br><span class="line">    while(low &lt; high)&#123;                                   //从表的两端交替地向中间扫描  </span><br><span class="line">        while(low &lt; high  &amp;&amp; a[high] &gt;= privotKey) --high;  //从high 所指位置向前搜索，至多到low+1 位置。将比基准元素小的交换到低端  </span><br><span class="line">        swap(&amp;a[low], &amp;a[high]);  </span><br><span class="line">        while(low &lt; high  &amp;&amp; a[low] &lt;= privotKey ) ++low;  </span><br><span class="line">        swap(&amp;a[low], &amp;a[high]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    print(a,10);  </span><br><span class="line">    return low;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">void quickSort(int a[], int low, int high)&#123;  </span><br><span class="line">    if(low &lt; high)&#123;  </span><br><span class="line">        int privotLoc = partition(a,  low,  high);  //将表一分为二  </span><br><span class="line">        quickSort(a,  low,  privotLoc -1);          //递归对低子表递归排序  </span><br><span class="line">        quickSort(a,   privotLoc + 1, high);        //递归对高子表递归排序  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main()&#123;  </span><br><span class="line">    int a[10] = &#123;3,1,5,7,2,4,9,6,10,8&#125;;  </span><br><span class="line">    cout&lt;&lt;&quot;初始值：&quot;;  </span><br><span class="line">    print(a,10);  </span><br><span class="line">    quickSort(a,0,9);  </span><br><span class="line">    cout&lt;&lt;&quot;结果：&quot;;  </span><br><span class="line">    print(a,10);  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<h3 id="快速排序的改进"><a href="#快速排序的改进" class="headerlink" title="快速排序的改进"></a>快速排序的改进</h3><p>在本改进算法中,只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当k取值为 8 左右时,改进算法的性能最佳。</p>
<p>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平常在项目中可能都会用到排序，就我本人而言，可能大部分都是用的选择排序或者冒泡排序，简单粗暴，但是这往往都只是实现了功能，而没有去关注性能，所以还是有必要了解常用的排序方法(&lt;b&gt;使用内存&lt;/b&gt;)。&lt;/p&gt;
&lt;h2 id=&quot;插入排序-直接插入排序&quot;&gt;&lt;a href=&quot;#插
    
    </summary>
    
    
      <category term="排序" scheme="http://html-js.site/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法" scheme="http://html-js.site/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Flex布局</title>
    <link href="http://html-js.site/2016/05/10/Flex%E5%B8%83%E5%B1%80/"/>
    <id>http://html-js.site/2016/05/10/Flex布局/</id>
    <published>2016-05-10T09:31:17.000Z</published>
    <updated>2016-06-08T05:34:56.249Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/file/flexbox-playground/index.html" target="_blank">flex测试工具</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前分享过Flex布局，一段时间没有用，忘得差不多了，恰逢我们的前端博客的诞生，在此记录并再次学习下；</p>
<h3 id="布局方式"><a href="#布局方式" class="headerlink" title="布局方式"></a>布局方式</h3><p>首先,我们有<b>表格布局</b>。当不考虑语义并且利用一些适当的嵌套和其他技巧,我们可以用table建立具有一定功能的布局。</p>
<p>然后是现在大多数人都在使用的<b>浮动布局</b>。我们可以使用任何我们想用的元素,但浮动并不适用于初学者。表面上它看起来很基础,但背后复杂的功能可以使经验丰富的开发者看着自己的屏幕不知所措。另外,浮动布局有一个缺点就是需要通过额外的元素清除浮动,或者更好一点,可以清除CSS浮动而不添加额外的标签。</p>
<p>这些缺点使得浮动布局不是很容易掌握，因为没有一个默认的方法可以建立起浮动与元素之间的关系，所以我们还需要更多的方法来实现<b>多栏等高布局</b></p>
<p>然后有些人开始使用<b>display: table，display: table-cell</b>等,但由于直到IE8 Internet Explorer浏览器才支持,人们似乎放弃了而只是接受float作为实际解决方案。</p>
<h3 id="弹性布局（Flex）的优势"><a href="#弹性布局（Flex）的优势" class="headerlink" title="弹性布局（Flex）的优势"></a>弹性布局（Flex）的优势</h3><ul>
<li>独立的高度控制与对齐</li>
<li>独立的元素顺序。</li>
<li>指定元素之间的关系。</li>
<li>灵活的尺寸和对齐方式。</li>
</ul>
<h2 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。<br><img width="571" height="341" src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="Down arrow"></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">display:flex | inline-flex; 定义弹性盒容器</span><br><span class="line">.box&#123;</span><br><span class="line">	display: -webkit-flex; /* Safari */</span><br><span class="line">	display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义弹性盒容器"><a href="#定义弹性盒容器" class="headerlink" title="定义弹性盒容器"></a>定义弹性盒容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display:flex | inline-flex; </span><br><span class="line">flex-direction:row | row-reverse | column | column-reverse 定义主轴方向</span><br><span class="line">flex-wrap:nowrap | wrap | wrap-reverse 定义侧轴方向单行或多行</span><br><span class="line">flex-flow ‘flex-direction’ 和 ‘flex-wrap’的组合简写</span><br></pre></td></tr></table></figure>
<h3 id="定义主轴上子元素的排列方式"><a href="#定义主轴上子元素的排列方式" class="headerlink" title="定义主轴上子元素的排列方式"></a>定义主轴上子元素的排列方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content:flex-start | flex-end | center | space-between | space-around</span><br></pre></td></tr></table></figure>
<p><img width="500" height="320" src="http://cdn.css-tricks.com/wp-content/uploads/2011/08/justify-contetnt.png"></p>
<h3 id="定义侧轴上子元素高度的伸缩"><a href="#定义侧轴上子元素高度的伸缩" class="headerlink" title="定义侧轴上子元素高度的伸缩"></a>定义侧轴上子元素高度的伸缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items:flex-start | flex-end | center | baseline | stretch</span><br></pre></td></tr></table></figure>
<p><img width="500" height="320" src="http://cdn.css-tricks.com/wp-content/uploads/2011/08/align-items.png" alt="Down arrow"></p>
<h3 id="定义侧轴上子元素的排列方式"><a href="#定义侧轴上子元素的排列方式" class="headerlink" title="定义侧轴上子元素的排列方式"></a>定义侧轴上子元素的排列方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content:flex-start | flex-end | center | space-between | space-around | stretch</span><br></pre></td></tr></table></figure>
<p><img width="500" height="320" src="http://cdn.css-tricks.com/wp-content/uploads/2011/08/align-content.png" alt="Down arrow"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">order 子元素的显示顺序</span><br><span class="line">flex-grow 父元素拉伸时子元素的拉伸比例值</span><br><span class="line">flex-shrink 父元素缩小时子元素的收缩比例值</span><br><span class="line">flex-basis 子元素的初始显示比例值</span><br><span class="line">flex flex-grow [，flex-shrink，flex-basis]的简写形式</span><br><span class="line">align-self:auto | flex-start | flex-end | center | baseline | stretch 提供给单个子元素覆盖父元素align-items值的能力</span><br></pre></td></tr></table></figure>
<p>以上的CSS成为“新”的弹性盒模式,事实上，只有最近的几个Chrome内核（包括桌面版Chrome+、Android版Chrome、Opera 15+）支持这种写法，Firefox的支持还不够完善(详细信息点击这里)。更多的现代浏览器从几年前开始支持一种“老的”弹性盒模型语法，除了IE10。IE10似乎支持一种介于老语法与新语法之间的新语法。</p>
<p><img height="600" src="/images/page/333.jpg" alt="Down arrow"></p>
<h3 id="如果你将Flexbox多版本混合在一起使用，可以得到以下浏览器的支持："><a href="#如果你将Flexbox多版本混合在一起使用，可以得到以下浏览器的支持：" class="headerlink" title="如果你将Flexbox多版本混合在一起使用，可以得到以下浏览器的支持："></a>如果你将Flexbox多版本混合在一起使用，可以得到以下浏览器的支持：</h3><ul>
<li>Chrome any</li>
<li>Firefox any (android 上面好像有问题？)</li>
<li>Safari any</li>
<li>Opera 12.1+</li>
<li>IE 10+</li>
<li>iOS any</li>
<li>Android any</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然老版本的flex语法难以匹敌新版语法，但是仍然有很多支持广泛并且有用的特性。<br>像下面这样写CSS，可以方便的应用flex带来的排版上的方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.f-f&#123;display: -webkit-box;display: -webkit-flex;&#125;</span><br><span class="line">.f-vc&#123;-webkit-box-align:center;-webkit-align-items:center;&#125;/*垂直居中*/</span><br><span class="line">.f-hc&#123;-webkit-box-pack:center;-webkit-justify-content:center;&#125;/*水平居中*/</span><br><span class="line">.f-hr&#123;-webkit-box-pack:end;-webkit-justify-content:flex-end;&#125;/*向右靠拢*/</span><br><span class="line">.f-hl&#123;-webkit-box-pack:start;-webkit-justify-content:flex-start;&#125;/*向左靠拢*/</span><br></pre></td></tr></table></figure>
<h3 id="将各种flex语法写成Sass："><a href="#将各种flex语法写成Sass：" class="headerlink" title="将各种flex语法写成Sass："></a>将各种flex语法写成Sass：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@mixin flexbox() &#123;</span><br><span class="line">	display: -webkit-box;</span><br><span class="line">	display: -moz-box;</span><br><span class="line">	display: -ms-flexbox;</span><br><span class="line">	display: -webkit-flex;</span><br><span class="line">	display: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixin flex($values) &#123;</span><br><span class="line">	-webkit-box-flex: $values;</span><br><span class="line">	-moz-box-flex:  $values;</span><br><span class="line">	-webkit-flex:  $values;</span><br><span class="line">	-ms-flex:  $values;</span><br><span class="line">	flex:  $values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixin order($val) &#123;</span><br><span class="line">	-webkit-box-ordinal-group: $val;  </span><br><span class="line">	-moz-box-ordinal-group: $val;     </span><br><span class="line">	-ms-flex-order: $val;     </span><br><span class="line">	-webkit-order: $val;  </span><br><span class="line">	order: $val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="external">A Complete Guide to Flexbox</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="external">阮一峰-Flex 布局教程：语法篇</a></p>
<p><a href="http://my.oschina.net/yinyongcom666/blog/151085?p=NaN#OSC_h2_1" target="_blank" rel="external">Flex弹性布局在移动设备上的应用</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/file/flexbox-playground/index.html&quot; target=&quot;_blank&quot;&gt;flex测试工具&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/
    
    </summary>
    
    
      <category term="flex" scheme="http://html-js.site/tags/flex/"/>
    
      <category term="css布局" scheme="http://html-js.site/tags/css%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>前端资料汇总</title>
    <link href="http://html-js.site/2016/05/10/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB/"/>
    <id>http://html-js.site/2016/05/10/前端资料汇总/</id>
    <published>2016-05-10T09:15:03.000Z</published>
    <updated>2016-06-08T06:14:12.015Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="资料" scheme="http://html-js.site/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的property和attribute的区别</title>
    <link href="http://html-js.site/2016/05/05/attribute-vs-property/"/>
    <id>http://html-js.site/2016/05/05/attribute-vs-property/</id>
    <published>2016-05-05T11:02:45.000Z</published>
    <updated>2016-08-23T09:50:50.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p><b>Property</b>：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型直接继承自</p>
<p>Element并添加了一些属性，添加的这些属性分别对应于每个HTML元素都有下面的这5个标准特性：id，</p>
<p>title，lang，dir，className。DOM节点是一个对象，因此，他可以和其他的JavaScript对象一样添加自</p>
<p>定义的属性以及方法。property的值可以是任何的数据类型，对大小写敏感，自定义的property不会出现</p>
<p>在html代码中，只存在js中。</p>
<p><b>Attribute</b>：特性，区别于property，attribute只能是<b>字符串</b>，大小写不敏感，出现在</p>
<p>innerHTML中，通过类数组attributes可以罗列所有的attribute。</p>
<h2 id="2-相同之处"><a href="#2-相同之处" class="headerlink" title="2. 相同之处"></a>2. 相同之处</h2><p>标准的 DOM properties 与 attributes 是同步的。公认的（非自定义的）特性会被以属性的形式添加到</p>
<p>DOM对象中。如，id，align，style等，这时候操作property或者使用操作特性的DOM方法如getAttribute</p>
<p>()都可以操作属性。不过传递给getAttribute()的特性名与实际的特性名相同。因此对于class的特性值获</p>
<p>取的时候要传入“class”。</p>
<h2 id="3-不同之处"><a href="#3-不同之处" class="headerlink" title="3. 不同之处"></a>3. 不同之处</h2><ul>
<li><p>对于有些标准的特性的操作，getAttribute与点号(.)获取的值存在差异性。如href，src，value，     </p>
<p> style，onclick等事件处理程序。</p>
</li>
<li>href：getAttribute获取的是href的实际值，而点号获取的是完整的url，存在浏览器差异。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"#"</span>&gt;&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> a  = <span class="built_in">document</span>.body.children[<span class="number">0</span>]</span><br><span class="line">    a.href = <span class="string">'/'</span></span><br><span class="line">    alert( <span class="string">'attribute:'</span> + a.getAttribute(<span class="string">'href'</span>) ) <span class="comment">// '/'</span></span><br><span class="line">    alert( <span class="string">'property:'</span> + a.href )  <span class="comment">// IE: '/', others: full URL</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>src的值的获取类似href，不过IE也会返回full URL；</p>
<p>value值同样存在一些 ‘one-way’（单向）同步的内置属性。</p>
<p>例如，input.value 从 attribute 中同步（即 property 从 attribute 中获得同步）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"markup"</span>&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">       var input = document.body.children[0];</span><br><span class="line">       input.setAttribute('value', 'new');</span><br><span class="line">       alert( input.value ); // 'new', input.value changed</span><br><span class="line">       alert( input.getAtrribute(value) ); // 'new'</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>但是 attribute 不能从 property 中获得同步：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"text"</span> value=<span class="string">"markup"</span>&gt;</span><br><span class="line"> &lt;script&gt;</span><br><span class="line">      var input = document.body.children[0];</span><br><span class="line">      input.value = 'new';</span><br><span class="line">      alert(input.getAttribute('value'));  // 'markup', not changed!</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>getAttribute获取的是初始值，而点号获取的是初始值或者.value修改后的值,例如当访问者输入了某些字</p>
<p>符后，’value’ attribute 在 property 更新后维持了原始值。原始值可以用来检验 input 是否变化，或</p>
<p>者重置它。</p>
<p>对于style和onclick等事件处理程序，getAttribute方法访问时会返回字符串，而点号返回的是相应的对</p>
<p>象和事件处理函数。</p>
<p>对于input中的checked属性，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"checkbox"</span> checked&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var input  = document.body.children[0]</span><br><span class="line">    alert( input.checked ) // true</span><br><span class="line">    alert( input.getAttribute('checked') ) // empty string</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>getAttribute获取的是你是实际设置的值。而点号返回的是布尔值。</p>
<h3 id="浏览器兼容性上的差别"><a href="#浏览器兼容性上的差别" class="headerlink" title="浏览器兼容性上的差别"></a>浏览器兼容性上的差别</h3><ul>
<li>在IE&lt;9的浏览器中，可以用点号和getAttribute在相互之间访问自定义属性。</li>
<li>IE&lt;8（包括IE8种的IE7兼容模式），property和attribute相同。因为attribute对大小写不敏感，在这</li>
</ul>
<p>种情况下，用getAttribute访问特性的时候，浏览器会选择第一次出现的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.abba = <span class="number">1</span> <span class="comment">// assign property (now can read it by getAttribute)</span></span><br><span class="line"><span class="built_in">document</span>.body.ABBA = <span class="number">5</span> <span class="comment">// assign property with another case</span></span><br><span class="line"><span class="comment">// must get a property named 'ABba' in case-insensitive way.</span></span><br><span class="line">alert( <span class="built_in">document</span>.body.getAttribute(<span class="string">'ABba'</span>) ) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="优先选择property"><a href="#优先选择property" class="headerlink" title="优先选择property"></a>优先选择property</h3><p>在实际应用中，98%的 DOM 操作都是使用 properties。</p>
<p><b>只有两种情形需要使用attributes</b></p>
<ul>
<li>自定义 HTML attributes，因为它并不同步到DOM property。</li>
<li>访问内置的 HTML attributes，这些 attribute 不能从 property 同步过来。例如 INPUT标签的value</li>
</ul>
<p>值。</p>
<blockquote><br>参考资料：<br><a href="http://javascript.info/tutorial/attributes-and-custom-properties" target="_blank" rel="nofollow">http://javascript.info/tutorial/attributes-and-custom-properties</a><br></blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h2&gt;&lt;p&gt;&lt;b&gt;Property&lt;/b&gt;：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型直
    
    </summary>
    
    
      <category term="javascript" scheme="http://html-js.site/tags/javascript/"/>
    
      <category term="attrbute" scheme="http://html-js.site/tags/attrbute/"/>
    
      <category term="property" scheme="http://html-js.site/tags/property/"/>
    
  </entry>
  
</feed>